// This is the main control program for hydro and traction cars.
// This version is used for ANSI 2000 Compliant boards only.

#define SLC386 0
#define Security 0	     // Full blown security
#define auto_elevator 0	// set to a zero if not automatic elevator

#define d_CONTROL 1
#include "global.h"

#define Sim_Control 1		// Set to 0 for special simulator with actual controller
#define Sim_Motion 1
#define Sim_Door 1
#define ServiceTimer 1
#define Hollister 0

#define CR 13
#define LF 10
#define ESC 27
  
int32 start_int = 0;
extern const int8 version = 6;
extern const int8 revision = 0;	 
extern const int8 interim_revision = 9;		// interim revision valid 1 - 99 


/* Interrupts used in this system

			main 8259

	irq0	18.2 msec Dos interrupt (disabled)
	irq1	Keyboard
	irq2	Slave 8259
	irq3	COM2 (Second user com port)
	irq4	COM1 (User com port)
	irq5	CAN BUS
	irq6	Group 485 com
	irq7 	10 msec inttim interrupt
	
			slave 8259

	irq8	Real time Calendar clock square wave output (disabled)
	irq9	Drive 485 com
	irq10	unused (disabled)
	irq11	unused (disabled)
	irq12	unused (disabled)
	irq13	External 80287 (disabled)
	irq14	AT HD (disabled)
	irq15	unused (disabled)	
		
*/


#define debug_io_enable 0

#if (debug_io_enable == 1)
	#define debug_io_board 11 //Board to Monitor
	#define debug_io_1 debug1
	#define debug_io_2 debug2
	#define debug_io_3 debug3
	#define debug_io_4 debug4
	int writedbgtoFC(uint32);
	int rqst_dbgtoFC = 0;
	/*
	This settings will monitor the inputs on the board listed above. The I/Os will always be recorded everytime you get the fault listed on fvexcflt1
	*/

#endif


int16 led_stat = 0;

uint32 cons_date_code = 0;

int32 debug1 = 0;
int32 debug2 = 0;
int32 debug3 = 0;
int32 debug4 = 0;
int32 debug5 = 0;
int32 debug6 = 0;

int16 int_flag=0;
int16 int_err=0;
int16 ir_mask_1 = 0;
int16 ir_mask_2 = 0;
int16 dpy_io_data = 0;
int16 io_cfg=0;
int16 ps_int_cnt = 0;
int16 power_up_start_time = 0;
int16 inctime_count = 0;

int16 remote_cc=0;
int16 remote_rcc=0;

float Dist_Ratio;
long Pos_Cnt_Ref;
float Dist_Ratio_S;
long Pos_Cnt_Ref_S;


int16 allow_run;						// Allow run during emergency power
int16 okto_run;

int16 reset_nonit = 0;
int16 ignore_uldl_fault = 0;

unsigned char misc_io_data = 0;			// misc io data include brake board inputs

		
// Timers used throught the program
int16 cctim[fl_size];          // car call timers
int16 ccrtim[fl_size];         // car call timers


#define tnmb 300         // number of timers  (last timer number + 1)
int16 timers[tnmb];
#define tinc 0          // Time generated from the 1/100 sec interupt
#define tten 1          // 1 tenth of a second buffer
#define tsec 2          // 1 second buffer
#define tbuf 3          // buffer used to count 1 second
#define tvpat 4         // voltage pattern timer
#define tcom_response 5 // comunication response timer 
#define tcom_que	6	// Comm que timer
#define tiofault 7		// I/O fault timer
#define tpatdly 8		// Pattern delay timer
#define tbep 9          // handicap beep timer
#define tcablnt 10     // cab riding lantern timer
#define tdc 11           // door close timer
#define tdcycle 12      // door cycle timer
#define tdo 13          // door open timer
#define tdwel 14        // door stay open timer
#define tfault 15       // delay after fault timer
#define tgen 16         // generator run timer
#define tlant 17        // door lantern timer
#define tgts 18 	    // time to delay check for gts (gripper input) being on
#define tclf 19    		// time to delay turn off the cab light and fan
#define tmode3 20       // time in mode 3
#define tmode5 21       // time in mode 5
#define tmotion 22      // motion timer
#define tnudge 23       // door nudge timer
#define tpatd 24        // pattern delay timer
#define tpredo 25       // door preopening delay timer
#define trdc 26         // rear door close timer
#define trdo 27         // rear door open timer
#define treset 28       // reset timer
#define trlant 29       // rear door lantern timer
#define trnudge 30      // rear door nudge timer
#define ccct 31         // clear car call timer
#define tfs2t 32        // clear fire service phase 2 timer
#define tnit  33        // non interference timer
#define tfs1t 34        // fire service phase 1 used if on independent
#define tdisplay 35     // diag leds am i alive counter
#define tfltled 36      // fault blinking timer
#define tdoor_reopen 37 // delay timer for high speed reversals on the door
#define tgroup_hcc 38   // group hall call clear timer
#define tsafe 39        // time after the DCL breaks until SAF makes up
#define trst 40			// reset timer
#define tdppflt 41		// digital pulse falure timer
#define tff 42			// field force output timer
#define trdwel 43		// rear door dwel timer
#define trdoor_reopen 44// delay timer for high speed reversals on rear
#define tuser_com 45	// User interface comm timer
#define tuser_com1 45	// User interface comm timer
#define tuser_com2 46	// User interface comm timer
#define tdrive_com 47	// Drive comm timer
#define tgcom_car 47 	// Dummy constant to address car timers 1-6
#define tgcom_car1 48  	// group comunication timer for car 1
#define tgcom_car2 49  	// group comunication timer for car 2
#define tgcom_car3 50 	// group comunication timer for car 3
#define tgcom_car4 51  	// group comunication timer for car 4
#define tgcom_car5 52  	// group comunication timer for car 5
#define tgcom_car6 53  	// group comunication timer for car 6
#define tgcom_car7 54  	// group comunication timer for car 7
#define tgcom_car8 55  	// group comunication timer for car 8
#define tgcom_master 56 // group comm master select timer
#define tgc_tran	57	// com 1 transmit interupt timer
#define tgc_recv	58	// com 1 receive interupt timer
#define tcom1_tran	59	// com 1 transmit interupt timer
#define tcom2_tran	60	// com 2 transmit interupt timer
#define tcom1_recv	61	// com 1 receive interupt timer
#define tcom2_recv	62	// com 2 receive interupt timer
#define thct		63	// Hall call common timer
#define tlct		64	// Logic common timer
#define tsst		65	// Saftey String Timer
#define tsecure		66	// Security timer length of time to enter code
#define tsecbep		67	// Security beep timer
#define tydel		68	// Generator y-delta timer
#define tunused1 	69	// Unused: Previously Debounce timer for Emergency Power Manual Select Switch
#define tepcar		69	// Recall time-out timer for Emergency Power Return Car
#define tepcar1		70	// Recall time-out timer for Emergency Power Return Car
#define tepcar2		71	// Recall time-out timer for Emergency Power Return Car
#define tepcar3		72	// Recall time-out timer for Emergency Power Return Car
#define tepcar4		73	// Recall time-out timer for Emergency Power Return Car
#define tepcar5		74	// Recall time-out timer for Emergency Power Return Car
#define tepcar6		75	// Recall time-out timer for Emergency Power Return Car
#define tepcar7		76	// Recall time-out timer for Emergency Power Return Car
#define tepcar8		77	// Recall time-out timer for Emergency Power Return Car
#define tsoftstp	78	// Soft Stop Timer
#define tiofltrst	79	// I/O fault reset timer  
#define tins_flt	80	// Inspection input fault timer
#define tbyp_flt	81 	// Gate or Lock bypass switch fault timer
#define tgripper	82	// Timer for rope gripper test
#define tparking	83	// Parking delay timer
#define tcan 		84	// Can Bus timer
#define tcantbs		85	// Can Transmit buffer status timer
#define tcanrbs		86	// Can Receive buffer status timer
#define tcantx		87	// Start of can output re-transmit timer
#define tcantx1		87	// Can device 1 output re-transmit timer
#define tcantx2		88	// Can device 2 output re-transmit timer
#define tcantx3		89	// Can device 3 output re-transmit timer
#define tcantx4		90	// Can device 4 output re-transmit timer
#define tcantx5		91	// Can device 5 output re-transmit timer
#define tcantx6		92	// Can device 6 output re-transmit timer
#define tcantx7		93	// Can device 7 output re-transmit timer
#define tcantx8		94	// Can device 8 output re-transmit timer
#define tcantx9		95	// Can device 9 output re-transmit timer
#define tcantx10	96	// Can device 10 output re-transmit timer
#define tcantx11	97	// Can device 11 output re-transmit timer
#define tcantx12	98	// Can device 12 output re-transmit timer
#define tcantx13	99	// Can device 13 output re-transmit timer
#define tcantx14    100	// Can device 14 output re-transmit timer
#define tcantx15    101	// Can device 15 output re-transmit timer
#define tcantx16    102	// Can device 16 output re-transmit timer
#define tcantx17    103	// Can device 17 output re-transmit timer
#define tcantx18    104	// Can device 18 output re-transmit timer
#define tcantx19	105 // Can device 19 output re-transmit timer
#define tcantx20	106 // Can device 20 output re-transmit timer
#define tcantx21	107 // Can device 21 output re-transmit timer
#define tcantx22	108 // Can device 22 output re-transmit timer
#define tcanrx		109 // Start of can input device timer
#define tcanrx1		109	// Can device 1 input timer
#define tcanrx2		110	// Can device 2 input timer
#define tcanrx3		111	// Can device 3 input timer
#define tcanrx4	    112	// Can device 4 input timer
#define tcanrx5	    113	// Can device 5 input timer
#define tcanrx6     114	// Can device 6 input timer
#define tcanrx7	    115	// Can device 7 input timer
#define tcanrx8	    116	// Can device 8 input timer
#define tcanrx9		117 // Can device 9 input timer
#define tcanrx10	118	// Can device 10 input timer
#define tcanrx11	119	// Can device 11 input timer
#define tcanrx12	120	// Can device 12 input timer
#define tcanrx13    121	// Can device 13 input timer
#define tcanrx14    122	// Can device 14 input timer
#define tcanrx15    123	// Can device 15 input timer
#define tcanrx16    124	// Can device 16 input timer
#define tcanrx17    125	// Can device 17 input timer
#define tcanrx18	126 // Can device 18 input timer
#define tcanrx19    127	// Can device 19 input timer
#define tcanrx20	128 // Can device 20 input timer
#define tcanrx21	129 // Can device 20 input timer
#define tcanrx22	130 // Can device 20 input timer
#define tpilant		131  // Can PI and lantern message timer
#define temhc		132 // Emergency diapatch hall call timer index start
#define temhc1		132	// Emergency dispatch hall call timer 1
#define temhc2		133 // Emergency dispatch hall call timer 2
#define temhc3		134	// Emergency dispatch hall call timer 3
#define temhc4		135	// Emergency dispatch hall call timer 4
#define temhc5		136 // Emergency dispatch hall call timer 5
#define temhc6		137	// Emergency dispatch hall call timer 6
#define temrhc		138 // Emergency diapatch rear hall call timer index start
#define temrhc1		138	// Emergency dispatch rear hall call timer 1
#define temrhc2		139 // Emergency dispatch rear hall call timer 2
#define temrhc3		140	// Emergency dispatch rear hall call timer 3
#define temrhc4		141	// Emergency dispatch rear hall call timer 4
#define temrhc5		142	// Emergency dispatch rear hall call timer 5
#define temrhc6		143	// Emergency dispatch rear hall call timer 6
#define tglkout		144	// Group car call lockout update timers (send lockout data to cars)
#define tncu		145	// Next Car Up timer
#define tdlt		146 // door lock top secondary i/o timer
#define tdlm		147 // door lock middle secondary i/o timer
#define tdlb		148 // door lock bottom secondary i/o timer
#define tgs			149 // gate switch secondary i/o timer
#define trlm		150 // rear door lock middle secondary i/o timer
#define trgs		151 // rear gate switch secondary i/o timer
#define tbrkon		152 // brake fail on i/o timer
#define tbrkoff		153 // brake fail off i/o timer
#define tdonon		154 // Drive ON fail on i/o timer
#define tdonoff		155 // Drive ON fail off i/o timer
#define tuppeak		156	// Up peak duration timer
#define tuptrig		157 // Up peak trigger timer
#define tdnpeak		158	// Down Peak duration timer
#define tdptrig		159 // Down Peak trigger timer
#define txasgn		160 // Hall Call cross assignment timer
#define tmedf		161	// Medical Emergency Service timer
#define tfltcarcom	162 // Comm timer for fault to be received from car
#define trhjack		163	// reset hydro jack timer
#define tvideo		164 // Video time out
#define tloadw		165 // Load weigher timer
#define theartbeat	166	// ids Liftnet heartbeat timer
#define trelev 		167 // relevel delay timer
#define tdpm		168 // Door protection module i/o timer
#define trpm		169 // Rear door protection module i/o timer
#define tgpio		170 // Timer to transfer group io to or from car
#define tiract		171 // Inconspicious Riser active timer
#define thbcc		172 // Car call handicap buzzer timer
#define tattbz		173 // Attendant buzzer timer
#define tpst		174 // power status timer
#define tdodly 		175 // door open delay
#define tdcdly		176 // door close delay
#define trdodly		177	// rear door open delay
#define trdcdly		178 // rear door close delay
#define tdoorbz		179 // Manual door buzzer delay timer
#define trcpkdly	180 // retiring cam pick delay timer
#define tlimit     	181 // Terminal limit debounce timer
#define tpfcsfc		182 // pfc and sfc relay test timer
#define tbkdrop		183 // brake drop debounce
#define tpinflt		184 // p-input fault debounce timer
#define tspbupd		185 // Safety processor	update timer
#define tlwupd		186 // Load weigher update timer 
#define tbrkupd		187 // Brake board update timer 
#define tspbts		188 // Safety processor board temperature sensor update timer
#define tvsupd		189 // Voltage sensor board update timer
#define tfltdelay	190 // Fault delay timer to send faults to user interface
#define tupfdnfdly	191	// Fault timer for UPF and DNF ON fault
#define tinsbrk     192 // Lift brake on inspection max timer
#define teeto		193 // Electric Eye Time-out timer
#define treeto		194	// Rear Electric Eye Time-out timer
#define trcablnt    195 // Rear cab riding lantern timer
#define tjackdly	196	// Reset jack delay timer
#define tdrvrst		197 // Drive reset timer
#define tfsdo		198 // Front swing door open timer
#define trsdo		199 // Rear swing door open timer
#define tbksrun		200 // Brake switch run timer
#define tdrvrdy		201 // Drive ready debounce timer
#define tlevto		202	// Leveling time-out timer (time targeting for the floor)
#define tautolnhw	203	// Auto Learn Hoistway timer.
#define tintmot		204 // Intended Motiont timer
#define tattbzcyc	205	// Attendant buzzer cycle timer used to cycle buzzer intermittently
#define tbkpkrate	206	// Brake pick rate time
#define tshortfl	207 // Short floor slowdown timer
#define tdoorupd	208 // Door can update timer
#define trdoorupd	209 // Rear door can update timer
#define tunused2	210 // Unused: Previously Emergency Power Recall Delay timer
#define tgsecovr	211 // Group car call security override comm timer
#define tuldloff	212	// UL/DL off timer
#define tebrkio		213 // Emergency brake contactor i/o debounce timer
#define tebkpick	214 // Emergency brake lift time
#define tebkdrop	215 // Emergency brake drop time
#define tdonbrkflt	216 // DON and BRKi input fault timer
#define tsabbath	217	// Sabbath restart timer
#define thcpl		218	// Hall call power loss timer
#define tpwrdo		219	// Power door open timer
#define tpwrdor		220	// Power rear door open timer
#define tpassword	221 // Password timer
#define tgovrst		222 // Governor reset timer
#define tdoorrq		223	// Door request time-out timer
#define tfdo_adv_de	224	// Front door advance door enable non-simulatneous doors
#define trdo_adv_de	225	// Rear door advance door enable non-simulatneous doors
#define tdl			226 // Dl down limit io check timer
#define tul			227 // Ul Up limit io check timer 
#define taltpi_on   228 // alternate between different ascii characters on digital pi's
#define taltpi_off  229 // alternate bewteen different ascii characters on digital pi's
#define tFlash      230 // LCD  flash timer
#define tFbuff      231 // LCD  flash buffer timer
#define theoff		232 // Heoff switch debounce timer 
#define tbkdroprate 233 // Brake Voltage Drop Rate timer
#define trcdrdly	234	// Retiring cam drop delay timer
#define tlcd_keb_dly 235 // Lcd timer for KEB drive
#define tpwl_pwr_on	236 // Power Loss power on timer
#define tpwl_pwr_off 237 // Power Loss power off timer
#define tsx_txA 	238	// Serial Expansion A Transmit timer
#define tsx_rxA 	239	// Serial Expansion A Receive timer
#define tsx_txB 	240	// Serial Expansion B Transmit timer
#define tsx_rxB 	241	// Serial Expansion B Receive timer
#define tspb_sfc	242 // SPB SFC debounce timer
#define tattbzini 	243 // Attendant timer to initialize buzzer
#define tadvptrq    244	// Advanced pre-torque safe timer
#define tgovtrip	245 // Governor reset timer	
#define tirots  	246	// IR Out of Service Timer to cancel IR hall calls
#define tdmo		247	// Door motor overload timer
#define tEP_npd		248	// Emergency Power Normal Power Drive timer
#define tEP_epd		249	// Emergency Power EP Drive timer
#define tEP_epo		250	// Emergency Power EP Off timer
#define tinst		251 // Inspection debounce timer
#define tcol		252 // Collision switch debounce
#define tospdbk		253 // Overspeed brake hold timer
#define teprcvr		253	// Recover time-out timer for Emergency Power Return Car
#define teprcvr1 	254	// Recover time-out timer for Emergency Power Return Car
#define teprcvr2	255	// Recover time-out timer for Emergency Power Return Car
#define teprcvr3	256	// Recover time-out timer for Emergency Power Return Car
#define teprcvr4	257	// Recover time-out timer for Emergency Power Return Car
#define teprcvr5	258	// Recover time-out timer for Emergency Power Return Car
#define teprcvr6	259	// Recover time-out timer for Emergency Power Return Car
#define teprcvr7	260	// Recover time-out timer for Emergency Power Return Car
#define teprcvr8	261	// Recover time-out timer for Emergency Power Return Car
#define tdoorhold	262	// max door hold timer
#define thyreset 	263	// hydro reset timer
#define tatthc		264	// Attendant hall call annunciator timer
#define tccsync		265 // Car Call security comm sync check timer
#define tattsync	266	// Attendant annunciator sync check timer
#define trcmon		267	// Retiring cam ON energized
#define tebkpkrate	268 // Emergency Brake Pick Rate timer
#define tebkdroprate 269 // Emergency Brake Drop rate timer
#define tebrkupd	 270 // Emergency Brake board update timer
#define tvipseqto	271	// VIP sequence time-out timer
#define talrm_pi	272	// Alarm display timer for PIs
#define tcbovrind	273	// Code Blue Over Independent Delay
#define theofovrind 274 // Hall Elevator Off over ind delay
#define tpwl_brk_on	275 // Power Loss brake on timer
#define tpwl_brk_off 276 // Power Loss brake off timer
#define tosernocall 277	// timer to control oser option 0x01	
#define toserbtwfl	278 // timer to control oser option 0x02
#define	toserssopen 279 // timer to control oser option 0x04
#define tlocalgetdate 280 // tiemr to delay the date check for update of call time tables
#define tkebrun 	281	// Keb run mode check timer
#define trelevstdir 282 // Relevel start direction debounce timer
#define tepsw		283	// Debounce timer for Emergency Power Manual Select Switch (power feeder 0)
#define tepsw1		284	// Debounce timer for Emergency Power Manual Select Switch (power feeder 1)
#define teprcldly	285 // Emergency Power Recall Delay timer (power feeder 0)
#define teprcldly1	286 // Emergency Power Recall Delay timer (power feeder 1)
#define thugs1	287		// Timer for prealarm mode of hugs service type 3
#define thugs2	288		// Timer for Alarm status of hugs service type 3
#define tlantchange	289 // lantern change delay timeer
#define ttoutmandoor 290 // timeout manual door for hall calls
#define ttoutmandoordbnc 291 //timeout manual door for hall calls debopunce
#define tenc_inifail 292 // Encoder init fail timer
#define tenc_hb 293		// Encoder heart beat timer
#define tenc_init 294	// Encoder init timer
#define tenc_pktreq 295 // Encoder packet request timer
#define tprntcomto 296	// print to com time-out
#define tgts_ex 297 	// gts emerency exit timer
#define tfire_fdo 298	// phase 1 fire front door open time for denver fire service
#define tfire_rdo 299	// phase 1 fire rear door open time for denver fire service

// hour timer
int16 rt_day = 0;
int16 rt_hour = 0;
int16 rt_minute = 0;
int16 rt_second = 0;
int16 day_st = 0;
int16 hour_st = 0;
int16 minute_st = 0;
int16 prev_minute = 0;

int16 loop_cnt=0;
int16 loop_cnt_array[10] = {6,6,6,6,6,6,6,6,6,6};
int16 loop_cnt_ptr=0;
int16 avg_loop_cnt = 6;

int16 gripper_flt_timer = 0;
int16 gov_flt_timer = 0;
int16 gripper_spd_trip_timer = 0;
int16 intended_motion = 0;			// intended motion for encoder rope gripper trip
int16 intended_motion_spb = 0;			// intended motion for safety processor board rope gripper trip
int16 em_stop_time = 0;				// emergency stop - time to stop
int32 enc_diff = 0;
int32 spb_diff = 0;
int32 st_spb_vel = 0;
int32 st_enc_vel = 0;
				
int16 pwr_up_reset = 0;				// power up reset flag

// Variables for limit test

int16 tmr_lim_dir = 0;		// Timer for limit direction fault
int16 tmr_vel_diff = 0;		// Timer for velocity difference fault
int16 tmr_spb_enc_dir = 0; 	// Timer for SPB encoder direction fault
int16 tmr_enc_dir = 0; 		// Timer for Controller encoder direction fault
int16 tmr_uldl_dir = 0;		// Timer for UL/DL direction fault check (prevent fault on power cycle)
int16 tmr_spb_vel_diff = 0;	// Timer for SPB velocity difference fault

#if (Traction == 1) || (Tract_OL == 1)

int16 limit_0 = 0;
int16 limit_0_tog = 0;
int16 limit_1 = 0;
int16 limit_1_tog = 0;
int16 limit_2 = 0;
int16 limit_2_tog = 0;
int16 limit_3 = 0;
int16 limit_3_tog = 0;
int16 limit_4 = 0;
int16 limit_4_tog = 0;
int16 limit_5 = 0;
int16 limit_5_tog = 0;
int16 limit_6 = 0;
int16 limit_6_tog = 0;
int16 limit_ts = 0;
int16 limit_ts_tog = 0;
#endif

int16 uldl_seq = 0;		// ul/dl sequence variable
int16 dlul_seq = 0;	// dl/ul sequence variable



// Messages sent out to the user
unsigned char message[2][15] = {
{'U','S','E','R',' ','N','A','M','E',' ',CR,'\n'},
{'P','A','S','S','W','O','R','D',' ',CR,'\n'},
};
// Flags used to direct the program
int16 codebf=0;           // code blue flag
			// codebf = 0 there is no emergency
			// codebf = 1 go to emergency floor
			// codebf = 2 at code blue floor
			// codebf = 3 at code blue floor with door open
			// codebf = 4 finished code blue return 
int16 in_code_blue=0;		// set when in code blue
int16 ind_codeb_alarm=0;	// set to alarm ind car that code blue requested 
int16 cb_over_ind=0;		// Set CB over independent
int16 heof_over_ind=0;	// Set HEOF over IND
int16 hsvf=0;				// hospital service flag
			// hsvf = 1 car on hospital service
int16 vipf=0;    			// priority service (vip) flag
			// vipf = 0 there is no priority call
			// vipf = 1 go to vip floor
			// vipf = 2 at vip floor
			// vipf = 3 at vip with door open
			// vipf = 4 finished vip return 

int16 tugf=0;		// TUG robot interface flag
			// tugf = 1 tehre is a tug call
			//
			//
			//
					 
int16 in_vip=0;	// set when in vip service
int16 in_overload = 0;	// set when car on overload
int16 in_att = 0;			// set when car in attendant service
int16 dcalls=0;           // direction of calls
			// dcalls = 0 there are no calls
			// dcalls = 1 there is a call above
			// dcalls = 2 there is a call below
			// dcalls = 3 the is a call above and below
int16 onward_calls = 0;		// direction of call no at the floor
			// onward_calls = 0 there are no calls
			// onward_calls = 1 there is a call above
			// onward_calls = 2 there is a call below
			// onward_calls = 3 the is a call above and below
int16 onward_cc = 0;
			// onward_cc = 0 there are no car calls
			// onward_cc = 1 there is a car call above
			// onward_cc = 2 there is a car call below
			// onward_cc = 3 the is a car call above and below
int16 onward_hc = 0;
			// onward_hc = 0 there are no hall calls
			// onward_hc = 1 there is a hall call above
			// onward_hc = 2 there is a hall call below
			// onward_hc = 3 the is a hall call above and below
int16 nohcreopen = 0;			// no hall call reopen
			// nohcreopen = 0 reopen the door when hc is pressed at floor
			// nohcreopen = 1 Dont reopen the door
int16 beyond_lby_cc = 0;		// Car call set above = 1 or below = 2 the lobby
int16 beyond_lby_call = 0;	// Car or Hall Call set above = 1 or below = 2 the lobby
int16 top_cc = 0;			// top most car call
int16 bot_cc = 0;			// bottom most car call
int16 nmb_cc = 0;			// number of car calls at different floors

int16 dirf=0;             // direction flag
			// dirf = 0 no direction
			// dirf = 1 last direction of travel was up
			// dirf = 2 last direction of travel was down
int16 prev_dirf=0;	// previous direction of travel

int16 old_doorf=0;
int16 doorf=0;            // door flag
			// doorf = 0 doors closed no action
			// doorf = 1 doors are opening
			// doorf = 2 doors are dwelling
			// doorf = 3 doors are closing
			// doorf = 4 doors are nudging closed
int16 ins_doorf=0;
int16 fdoor_en=0;		// front door enable
int16 fdoor_req=0;	// front door request to open
int16 fdob_req=0;		// front door open button request
int16 fcc_req=0;		// front car call door open request
int16 nudgst=0;		// front door nudging status
						// 0x01 nudged closed with an up pilot
						// 0x02 nudged closed with a dn pilot
						// 0x04 nudged closed with an no pilot
int16 do_seq = 0;		// Set when door reaches full open (DOL)   
						// 0x01 door open sequence with an up pilot
						// 0x02 door open sequence with a dn pilot
						// 0x04 door open sequence with no pilot
int16 do_to = 0;		// Set when door open limit times out.
int16 ee_to = 0;		// Set when electric eye times out.
int16 manual_door = 0;		// set for manual door (added to have manual rear staggered and automatic front)
int16 drop_front_rcm = 0;		// set to drop front RCM
int16 auto_rcm = 0;

int16 doors_open = 0;		// local door open flag

int16 freight_fdoor_alarm = 0;  	// frieght front door alarm
int16 fsdo=0;				// Front swing door open
int16 fsdo_seq=0;			// front swing door open sequence
int16 dpref=0;            // direction preference
			// dpref = 0 no direction selected as preference
			// dpref = 1 direction preference is up
			// dpref = 2 direction preference is down
int16 prev_dpref=0; 
int16 cc_above_lby=0;	// set to 1 if car calls above the lobby 
int16 cc_below_lby=0;	// set to 1 if car calls below the lobby  
int16 run_no_pass_cnt=0;	// Run with no passenger entering the car
int16 pass_det=0;			// Passenger detected in the car
int16 extended_door_time = 0;	// set when extended door time is active
int16 rcm_frght_out_en = 0;				// Retiring Cam for freight output enable


int16 eqf=0;			// Earthquake flag
			// eqf = 0 not on earthquake operation
			// eqf = 1 earthquake sensor has activated
			// eqf = 2 counterweight derailment sensor has activated
			// eqf = 3 recover away from the counterweight
			// eqf = 4 stopped at a floor
int16 old_eqf = 0;
int16 above_cwt = 0;		// 1 = car is above the counterweight
int16 old_above_cwt = 0;
int16 on_cws=0;
int16 eq_pos_reset = 0;		// earthquake position reset flag

int16 empf=0;             // emergency power car status flag
			// empf = 0 not on emergency power
			// empf = 1 on emp waiting 
			// empf = 2 on emp waiting with doors open (cycle door close if hydro)
			// empf = 3 on emp returning home
			// empf = 4 on emp returned home with doors open
			// empf = 5 on emp returned home with doors closed
			// empf = 6 on emp and selected to run
			// empf = 7 on emp waiting with doors closed
				 

// Line voltage variables

int16 L1_Voltage = 0;
int16 L2_Voltage = 0;
int16 L3_Voltage = 0;
int16 Door_Voltage = 0;

int16 voltf = 0;					// voltage status flag 
								// bit 0: L1
								// bit 1: L2
								// bit 2: L3
								// bit 4: Door

// Hugs Security Variables

int16 hugsf=0;	// hugsf = 0 no hugs security
				// hugsf = 1 front door security
				// hugsf = 2 rear door security
				// hugsf = 3 front and rear door security

int16 hugsec=0;					// Front hugs security enable
int16 rhugsec=0;					// Rear hugs security enable
int32 hugs_sec[2] = {0,0};		// Hugs security mask
int32 rhugs_sec[2] = {0,0};		// Hugs rear security mask


int16 adv_pre_trq_run = 0;	// Advanced pre-torque run enable flag
int16 adv_pre_trq_fault = 0;	// Advanced pre-torque run fault flag

int16 run_time = 0;			// Floor to floor run time from tmotion timer.
int16 targetfl_time = 0;		// Target floor tmotion time value when first entered
int16 preopen_time = 0;		// Time car enables preopoening door on tmotion timer
int16 ep_recall_fl = 1;		// emergency power recall floor set from setempf routine
int16 estop = 0; 				// emergency stop
int16 estops_1_run = 0;		// estops counter
int16 fault_run = 0;			// fault during run
int16 fault_run_cnt = 0;		// number of runs with faults
int16 shutdown = 0;			// shutdown car due to too many runs with faults in a row
int16 pwl_ups_fault = 0;		// power loss ups fault (shuts car down)
int16 limit_dir_fault = 0;	// Fault from hitting limits from wrong direction
int16 spb_dir_fault = 0;		// SPB direction opposite from car direction
int16 uldl_dir_fault = 0;		// UL and DL Direction fault 
int16 vel_decel_diff_fault = 0;	// Velocity decel tracking fault
int16 spb_vel_diff_fault = 0;		// SPB velocity difference fault
int16 spb_vel_diff = 0;			// SPB velocity difference greater than parameter value
int16 lev_to = 0;				// leveling time-out while targeting floor
int16 prev_fault=0;
int16 Current_Fault=0;    	// The Current Fault
int16 Display_Fault= 0;
int16 Rotate_Fault=0;
int16 BRK_Fault = 0;			// Brake lift switch fault
int16 BKS_Run_Fault = 0;		// Brake lift switch fault during run
int16 BRK_Pick_Test = 0;		// Brake lift switch Pick Test flag
int16 BRK_Drop_Test = 0;		// Brake lift switch Drop Test flag
int16 Door_Lock_Fault=0;		// Door lock Fault if dli gli or dpr on when doors open
int16 RCM_Lock_Fault=0;		// Retiring lock Fault if lock does not make up after RCM
int16 DZ_ON_Fault=0;			// Door zone failed on fault flag
int16 DZA_ON_Fault=0;			// Door zone A failed on fault flag
int16 DZ_OFF_Fault = 0;		// Door zone failed off fault flag
int16 DZA_OFF_Fault = 0;		// Door zone A failed off fault flag
int16 UL_ON_Fault=0;			// Detect if UL does not turn off during motion
int16 DL_ON_Fault=0;			// Detect if DL does not turn off during motion
int16 UL_DL_OFF_Fault = 0;	// UL or DL did not turn on at level zone
int16 io_fault=0;				// Io device fault
int16 io_fault_cnt=0;			// Lock up after 3 io faults
int16 limit_fault=0;			// UT,UTS,DT or DTS limit fault
int16 fault[25];  		    // fault buffer holds the faults
int16 old_fault[25];
int16 ins_fault = 0;			// inspection fault flag
int16 ins_fault_latch = 0;	// inspection fault latch
int16 ins_sw_err = 0;			// inspection switch error (up or down run)
int16 ins_status = 0;			// inspection status
int16 mr_ins_en = 0;			// motor room inspection enable is used
int16 byp_fault = 0;			// gate or lock bypass fault
int16 byp_fault_latch = 0;	// gate or lock bypass fault latch
int16 gripper_test = 0;		// State flag for gripper test
int16 in_gripper_test = 0;	// In gripper test routine
int16 gripper_fault = 0;		// Rope gripper fault
int16 old_gripper_fault = 0;	// gripper fault memory
int16 gripper_trip_enable = 0; 	// gripper trip enable flag
int16 DBR_Temp_Fault = 0;		// Dynamic Braking Temperature Fault
int16 fault_device = 0;		// device that had the fault
int16 fault_device_2 = 0;		// device 2 that had the fault
int16 fault_prog_flag1 = 0;	// programmer multi-use flag 1
int16 fault_prog_flag2 = 0;	// programmer multi-use flag 2
int16 motion_fault = 0;		// Motion fault occurred: must stop car
int16 pfc_sfc_test = 0;		// pfc and sfc relay test
int16 in_pfc_sfc_test = 0;	// in pfc and sfc relay test
int16 reset_courion = 0;
int16 hy_rdy_test = 0;		// hydro ready test (check P input)
int16 hy_reset_cnt = 0;		// hydro reset count (reset drive)
int16 hydro_on_emp = 0;		// hydro on emergency power
int16 prev_hydro_on_emp = 0;	// previous flag for hydro on emergency power
int16 hy_ep_rdy_test = 0;		// hydro emergency ready test
int16 in_serv_lt = 0;			// in service light control for single automatic pushbutton operation
int16 oserl_enable = 0;		// Special Out of Service Light enable variable
int16 oser_lt = 0;			// Out of service light
int16 oser_bz = 0;			// Out of service buzzer
int16 oser_bz_pulse = 0;		// Out of service buzzer flash
int16 hardware_init_fault = 0;	// 1 if hardware failed on init
int16 drv_rst_cnt = 0;		// Counter for drive ready reset
int16 rdy_flt_latch = 0;		// fault latch for drive ready
bool ResetFaults = false;
int16 spb_sfc_fault = 0;		// SPB SFC input fault
int16 door_motor_ovl = 0;		// Door motor overload flag
int16 safe_fault_latch = 0;	// safe fault latch
int16 keb_run_verify_seq = 0;		// verify keb drive in run mode
int16 delta_off_flag = 0;		// set delta off error only once 
int16 run_hold_1036 = 0;		// prevent the car from running auto if the 1036 is connected


//**************************************************************************
//**************************************************************************
// NOTE: Keep fault type to an even number because MRAM writes are word wide
//**************************************************************************
//**************************************************************************

#if (Tract_HR == 1)
int16 car_has_fault[car_size] = {0,0,0,0,0,0,0,0,0};
#else
int16 car_has_fault[car_size] = {0,0,0,0,0,0,0};
#endif 
typedef struct Fault {
	uint16 code;			// 0,1
	unsigned char count;	// 2
	unsigned char day;		// 3
	unsigned char mon;		// 4
	int16 year;				// 5,6
	unsigned char min;		// 7,8
	unsigned char hour;		// 9
	unsigned char sec;		// 10
	unsigned char pos;		// 11
	unsigned char servf;	// 12	  
	unsigned char procf;	// 13	  
	unsigned char doorf;	// 14
	unsigned char rdoorf;	// 15
	unsigned char dpref;	// 16
	unsigned char dirf;		// 17
	unsigned char empf;		// 18
	unsigned char medf;		// 19
	unsigned char codebf;	// 20
	unsigned char eqf;		// 21
	unsigned char firef;	// 22	   
	unsigned char rfiref;	// 23
	unsigned char hsf;		// 24
	unsigned char startf;   // 25
	unsigned char dcalls;   // 26
	unsigned char estop;	// 27
	unsigned char nstopf;	// 28
	unsigned char relevel;	// 29
	unsigned char stepf;	// 30
	unsigned char predof;		// 31
	unsigned char stops0;		// 32   
	unsigned char ins_status;	// 33  
	unsigned char ncu_door_seq;	// 34
	unsigned char device;		// 35
	unsigned char prog_flag1;	// 36
	unsigned char prog_flag2;	// 37
	unsigned char device_2;		// 38
	unsigned char iodata [14];	// 39-52
	int32 statusf;		 		// 53-56
	int32 dpp_count;		 	// 57-60
	int32 dpp_target;	 		// 61-64
	float velocity;	 			// 65-72
	float enc_vel;		 		// 73-80
	unsigned char SPB_service;	// 81
	unsigned char SPB_status;	// 82
	int16 SPB_vel;				// 83-84
	int32 SPB_poscnt;			// 85-88
	unsigned char spare89;		// 89		
	unsigned char spare90;		// 90		
	unsigned char spare91;		// 91		
	unsigned char spare92;		// 92		
	unsigned char spare93;		// 93		
	unsigned char spare94;		// 94		
	unsigned char spare95;		// 95		
	unsigned char spare96;		// 96	
	unsigned char spare97;		// 97		
	unsigned char spare98;		// 98		
	unsigned char spare99;		// 99		// keep an even number
} Fault_type;			// 100 * 50 = 5000 bytes

#define max_flt_ix 50
union fault_union {
	unsigned char fltb[max_flt_ix][sizeof(Fault_type)];
	struct Fault Flts[max_flt_ix];
}f;

union car_fault_union {
	unsigned char fltb[max_flt_ix][sizeof(Fault_type)];
	struct Fault Flts[max_flt_ix];
}cf;

int16 Flt_ix = 0;
int16 Car_Flt_ix = 0;
	 
#define max_nmbflts 416		// set to last error code number

#define f_reset 1			// Reset fauilure
#define f_pos_error 2		// Elevator lost failure (position error)
#define f_binary 3			// Binary floor input failure
#define f_sstring 4			// Saftey string failure or no P
#define f_dz_on 5			// Door zone on failure
#define f_stall_fault 6		// Stall failure
#define f_door_open 7		// Door open failure
#define f_door_close 8		// Door close failure
#define f_un_open 9			// Up directional open
#define f_dn_open 10		// Down directional open
#define f_hw_learn 11		// Hoistway not Learned
#define f_stop_sw 12		// Stop switch open
#define f_dpm_on 13			// Door lock PRotection (DPM) on fault
#define f_LC_fuse 14		// LC fuse Blown
#define f_HC_fuse 15		// HC fuse Blown
#define f_drive_rdy 16	 	// Drive Ready off
#define f_P_off	17			// Potential input off
#define f_car_safe 18	  	// Car Safe Fault
#define f_ul_dl_off 19		// UL and DL off when expected on
#define f_delta_off 20	 	// Delta off when expected on
#define f_UT_count 21		// Up Terminal limit count error
#define f_UT1_count 22		// Up Terminal 1 limit count error
#define f_UT2_count 23		// Up Terminal 2 limit count error
#define f_UT3_count 24		// Up Terminal 3 limit count error
#define f_DT_count 25		// Down Terminal limit count error
#define f_DT1_count 26		// Down Terminal 1 limit count error
#define f_DT2_count 27		// Down Terminal 2 limit count error
#define f_DT3_count 28		// Down Terminal 3 limit count error
#define f_rdoor_open 29		// Door open failure
#define f_rdoor_close 30	// Door close failure
#define f_Group_Comm 31		// Group Comm loss 
#define f_Car_Comm 31		// Car Comm loss  (Start of index + Car number)
#define f_Car1_Comm 32		// Car 1 Comm Loss (Cannot have a Car 1 comm loss)
#define f_Car2_Comm 33		// Car 2 Comm Loss
#define f_Car3_Comm 34		// Car 3 Comm Loss
#define f_Car4_Comm 35		// Car 4 Comm Loss
#define f_Car5_Comm 36		// Car 5 Comm Loss
#define f_Car6_Comm 37		// Car 6 Comm Loss
#define f_run_on 38			// RUN input or output failed on
#define f_runo_runai 39		// Run output or runa input failed
#define f_run_off 40		// RUN input or output failed off 
#define f_runa_on 41		// RUNA input or output failed on
#define f_runa_off 42 		// RUNA input or output failed off
#define f_up_on 43			// UP input or output failed on
#define f_up_off 44			// UP input or output failed off
#define f_dnr_on 45			// DNR input or output failed on
#define f_dnr_off 46		// DNR input or output failed off
#define f_upf_on 47			// UP Fast input or output failed on
#define f_upf_off 48	   	// UP Fast input or output failed off
#define f_df_on 49			// DN Fast input or output failed on
#define f_df_off 50			// DN Fast input or output failed off
#define f_MCC_on 51			// MCC input or output failed on
#define f_runo_runi 52		// Run output or run input failed
#define f_MCC_off 53			// MCC input or output failed off 
#define f_MCA_on 54			// MC input or output failed on
#define f_MCA_off 55			// MC input or output failed off
#define f_brk_on 56			// BRK input or output failed on
#define f_brk_off 57 		// BRK input or output failed off
#define f_don_on 58			// DON input failed on
#define f_don_off 59 		// DON input failed off
#define f_run_runa_up 60 	// RUN input/output or UP output failed off
#define f_run_runa_dn 61 	// RUN input/output or DNR output failed off
#define f_dlt_on 62			// Door Lock Top failed on
#define f_dlm_on 63			// Door Lock Middle failed on
#define f_dlb_on 64			// Door Lock Bottom failed on
#define f_gs_on	 65			// Gate Switch failed on	
#define f_rdlt_on 66		// Rear Door Lock Top failed on
#define f_rlm_on 67			// Rear Door Lock Middle failed on
#define f_rdlb_on 68		// Rear Door Lock Bottom failed on
#define f_rgs_on 69			// Rear Gate Switch failed on
#define f_P_on 70			// Potential input failed on
#define f_estop 71 			// Three estops in a row
#define f_ins_err 72		// Inspection input error
#define f_byp_err 73		// Gate or lock bypass error
#define f_grt1_on 74		// Gripper input 1 failed on
#define f_grt1_off 75		// Gripper input 1 failed off
#define f_grt2_on 76		// Gripper input 2 failed on
#define f_grt2_off 77		// Gripper input 2 failed off
#define f_gts_pick 78		// Gripper did not pick
#define f_grip_trip 79		// Gripper tripped from an un-safe condition
#define f_dlt_fail 80		// Door Lock Top DLT and DLT_1 failed opposite
#define f_dlm_fail 81		// Door Lock Middle DLM and DLM_1 failed opposite
#define f_dlb_fail 82		// Door Lock Bottom DLB and DLB_1 failed opposite
#define f_gs_fail 83		// Gate Switch GS and GS_1 failed opposite	
#define f_rlm_fail 84		// Rear Door Lock Middle RLM and RLM_1 failed opposite
#define f_rgs_fail 85		// Rear Gate Switch RGS and RGS_1 failed opposite
#define f_brk_pick 86		// Brake failed to pick 
#define f_brk_drop 87		// Brake failed to drop
#define f_grip_set 88		// Gripper set from brake failure
#define f_delta_on 89		// DEL input failed on when should be off
#define f_cws_dt 90			// Above cwt flag set incorrectly at DT limit
#define f_cws_ut 91			// Above cwt flag set incorrectly at UT limit
#define f_UT_Target 92		// Target error at UT slowdown limit
#define f_UT1_Target 93		// Target error at UT1 slowdown limit
#define f_UT2_Target 94		// Target error at UT2 slowdown limit
#define f_UT3_Target 95		// Target error at UT3 slowdown limit
#define f_DT_Target 96		// Target error at DT slowdown limit
#define f_DT1_Target 97		// Target error at DT1 slowdown limit
#define f_DT2_Target 98		// Target error at DT2 slowdown limit
#define f_DT3_Target 99		// Target error at DT3 slowdown limit
#define f_vel_overspeed 100	// Velocity Over speed
#define f_hc_dev_reset 101 	// Hall call device reset
#define f_car_dev_reset 102 // Car comm device reset
#define f_toc_can_error 103 // Top car device can comm error
#define f_drv_rcv_error 104 // Drive comm receive error 
#define f_pwrup_reset 105	// Power Up Reset
#define f_DRV_SP_flt 106	// Drive or Safety Processor Fault
#define f_car_safe_preop 107	  	// Car Safe Fault during preopening
#define f_car_safe_start 108	  	// Car Safe Fault during start (door possible not closed)
#define f_ins_up_dn_sw 109	// Up or down inspections switch error
#define f_drv_trm_error 110	// Drive Comm transmit error
#define f_drv_inten_error 111 // Drive Comm interrupt enable error
#define f_drv_txempty_error 112 // Drive comm transmit empty error
#define f_UTS_count 113			// Up ETS Terminal limit count error
#define f_DTS_count 114			// Down ETS Terminal limit count error
#define f_UTS_Target 115		// Target error at UTS slowdown limit
#define f_DTS_Target 116		// Target error at DTS slowdown limit
#define f_drv_8259_error 117 	// Drive comm 8256 error
#define f_drv_tx_stop_error 118	// Drive transmitter stopped error
#define f_spb_can_error 119		// Safety Processor board can communications error
#define f_dbr_temp_flt 120		// Dynamic Brake Resistors are too hot fault
#define f_seb_can_error 121		// Serial Expansion Board Can comm error
#define f_lw_calibrate 122		// Load weigher calibration error
#define f_can_init_error 123	// Can bus initialization error (bus or timer failure)
#define f_shutdown 124			// Too many consecutive runs with faults
#define f_drv_com_error 125		// Drive has a comm error
#define f_encoder 126			// Encoder Fault
#define f_can_bus_off 127		// Can Bus Off error
#define f_zero_vel_error 128	// Zero Velocity Error during roll into decel
#define f_bus_error 129			// bus error during encoder read
#define f_lowpress 130			// low pressure switch error
#define f_UTS_flt 131			// UTS failed on
#define f_DTS_flt 132			// DTS failed on
#define f_UT_flt 133			// UT failed on
#define f_DT_flt 134			// DT failed on
#define f_rpm_on 135			// Rear Door lock PRotection (RPM) on fault
#define f_dpm_gl 136			// DPM off with gate or lock on
#define f_rpm_gl 137			// RPM off with rear gate or lock on 
#define f_pulse_75fpm_2in 138	// Pulse count error, car > 75 fpm travel < 2in
#define f_pulse_dir_up 139		// Pulse count wrong direction running up
#define f_pulse_dir_dn 140		// Pulse count wrong direction running down
#define f_pulse_75speed	141		// Pulse count error, 75% top speed not enough counts
#define f_brk_can_error 142		// Brake board can error
#define f_gov 143				// Governor switch
#define f_top_final 144			// Top final limit
#define f_bottom_final 145		// Bottom final limit
#define f_pit_sw 146			// Pit switch
#define f_pit_door_sw 147		// Pit door switch
#define f_buffer_sw 148			// Buffer switch
#define f_comp_sw 149			// Comp rope switch
#define f_top_em_exit 150		// Top emergency exit switch
#define f_side_em_exit 151		// Side Emergency exit switch
#define f_car_safety_sw 152		// Car safety switch
#define f_CC_fuse 153			// Car call common fuse
#define f_CCL_fuse 154			// Car call light common fuse
#define f_HCL_fuse 155			// Hall call light common fuse
#define f_FF_stop_sw 156		// Fire Fighters Stop Switch
#define f_PFC_failed_on 157		// PFC relay failed on 
#define f_PFC_failed_off 158	// PFC relay failed off
#define f_SFC_failed_on 159		// SFC relay failed on
#define f_SFC_failed_off 160	// SFC relay failed off
#define f_dza_on 161 			// Door zone A on fault
#define f_dz_off 162			// Door zone off fault
#define f_dza_off 163			// Door zone A off fault
#define f_PFC_SFC_DZ_lost 164	// Lost DZ during PFC SFC test
#define f_FST_failed_on 165		// FST output failed on or FSTI input failed on
#define f_FST_failed_off 166 	// FST output failed off or FSTI input failed off
#define f_FSTP_failed_on 167	// FSTP output failed on
#define f_FSTP_failed_off 168 	// FSTP output failed off
#define f_sel_can_error 169		// Selector board can error
#define f_runa_runi 170			// Runa or runi failed
#define f_eexit 171				// Emergency exit
#define f_ul_on 172				// UL failed on
#define f_dl_on 173				// DL failed on
#define f_ul_dl_dz_off 174		// UL DL and DZ off at floor
#define f_UT4_count 175			// Up Terminal 4 limit count error
#define f_UT5_count 176			// Up Terminal 5 limit count error
#define f_UT6_count 177			// Up Terminal 6 limit count error
#define f_DT4_count 178			// Down Terminal 4 limit count error
#define f_DT5_count 179			// Down Terminal 5 limit count error
#define f_DT6_count 180			// Down Terminal 6 limit count error
#define f_UT4_Target 181		// Target error at UT4 slowdown limit
#define f_UT5_Target 182		// Target error at UT5 slowdown limit
#define f_UT6_Target 183		// Target error at UT6 slowdown limit
#define f_DT4_Target 184 		// Target error at DT4 slowdown limit
#define f_DT5_Target 185 		// Target error at DT5 slowdown limit
#define f_DT6_Target 186 		// Target error at DT6 slowdown limit
#define f_fvars_reloc 187		// Field variables relocated
#define f_fvars_init 188		// Field variables initialized
#define f_hw_init 189			// Hoistway initialized
#define f_Car7_Comm 190			// Car 7 Comm Loss
#define f_Car8_Comm 191			// Car 8 Comm Loss
#define f_EE_fault 192			// EE Ram fault
#define f_NV_fault 193			// NV Ram Fault
#define f_hw_upd_init 194		// Hoistway update table initialized
#define f_lowoil_switch 195		// Low oil switch input fault
#define f_leveling_fault 196	// Leveling fault
#define f_SEL_Cnt_fault 197		// Selector Count fault
#define f_hw_inv_fl_cnt	198 	// Invalid floor count
#define f_hw_topf_cnt 199 		// Invalid top floor count
#define f_hw_dn_dt_cnt 200 		// Invalid DN or DT count
#define f_hw_dt_dt1_cnt	201 	// Invalid DT or DT1 count
#define f_hw_dt1_dt2_cnt 202	// Invalid DT1 or DT2 count
#define f_hw_dt2_dt3_cnt 203	// Invalid DT2 or DT3 count
#define f_hw_dt3_dt4_cnt 204	// Invalid DT3 or DT4 count
#define f_hw_dt4_dt5_cnt 205	// Invalid DT4 or DT5 count
#define f_hw_dt5_dt6_cnt 206	// Invalid DT5 or DT6 count
#define f_hw_ut6_ut5_cnt 207	// Invalid UT6 or UT5 count
#define f_hw_ut5_ut4_cnt 208	// Invalid UT5 or UT4 count
#define f_hw_ut4_ut3_cnt 209	// Invalid UT4 or UT3 count
#define f_hw_ut3_ut2_cnt 210	// Invalid UT3 or UT2 count
#define f_hw_ut2_ut1_cnt 211	// Invalid UT2 or UT1 count
#define f_hw_ut1_ut_cnt	212		// Invalid UT1 or UT  count
#define f_hw_ut_un_cnt 213		// Invalid UT or UN count
#define f_hw_sel_bot_cnt 214	// Invalid Selector Bottom Count
#define f_hw_sel_top_cnt 215	// Invalid Selector Top Count
#define f_hw_dzu_dzd_cnt 216	// Invalid DZU or DZD Count
#define f_hw_fl_off_cnt 217		// Invalid FL offset Count
#define f_asv_to_car 217		// Start of fault index for auto service time-out
#define f_asv_to_car_1 218		// Auto Service Time-out Car 1
#define f_asv_to_car_2 219		// Auto Service Time-out Car 2
#define f_asv_to_car_3 220		// Auto Service Time-out Car 3
#define f_asv_to_car_4 221		// Auto Service Time-out Car 4
#define f_asv_to_car_5 222		// Auto Service Time-out Car 5
#define f_asv_to_car_6 223		// Auto Service Time-out Car 6
#define f_asv_to_car_7 224		// Auto Service Time-out Car 7
#define f_asv_to_car_8 225		// Auto Service Time-out Car 8
#define f_bks_run 226			// Brake switch fail slowdown
#define f_levto 227				// Time-out leveling fault targeting floor
#define f_hw_safe_fault 228		// Auto learn hoistway safe fault
#define f_hw_stall_fault 229	// Auto learn hoistway stall fault
#define f_em_brk_off 230		// Emergency Brake failed off fault
#define f_em_brk_on 231			// Emergency Brake failed on fault
#define f_em_brk_sw_off 232		// Emergency Brake failed off fault
#define f_em_brk_sw_on 233		// Emergency Brake failed on fault
#define f_brk_over_current 234	// Brake board over current fault (brake error 2)
#define f_brk_over_volt 235		// Brake board over voltage fault (3)
#define f_brk_no_current 236	// Brake board no current fault with voltage applied (4)
#define f_brk_no_dc_bus_volt 237	// Brake board no dc bus voltage fault (5)
#define f_brk_no_output_volt 238	// Brake board not output voltage fault	(6)
#define f_brk_low_dc_bus_volt 239	// Brake board low dc bus voltage fault	 (7)
#define f_brk_dmd_gt_dc_bus 240		// Brake board dmd voltage greater than dc bus voltage fault (8)
#define f_com_config 241		// Group Comm configuration error (hall call i/o address configuration error)
#define f_hc_rx_top 242  		// Rx from top HC board fault	(nest 8 errors must be consecutive)
#define f_hc_tx_top 243			// Tx to top HC board fault
#define f_hc_too_few 244		// Too few stations on bus
#define f_hc_too_many 245		// Too many stations on bus
#define f_hc_rx_bot 246			// Rx from bottom HC board fault
#define f_hc_tx_bot 247			// Tx to bottom HC board fault
#define f_hc_reserved_248		// Reserved for hc board fault
#define f_hc_reserved_249		// Reserved for hc board fault	
#define f_lev_stop_cnt 250		// Leveling stop fault occured from incorrect count
#define f_GTS_failed_on 251		// GTS input failed on  
#define f_GTS_failed_off 252	// GTS input failed off
#define f_inv_fault 253			// Invalid fault code
#define f_spb_umotion 254		// SPB Unintended Motion
#define f_ids_last_error 255	// Largest error IDS can do
#define f_hcb_tx_dn 256			// HCB Tx fault down to below floor	  (next 14 errors must be consecutive)
#define f_hcb_tx_up 257			// HCB tx fault up to above floor
#define f_hcb_rx_dn	258			// HCB rx fault down from below floor
#define f_hcb_rx_up 259			// HCB rx fault up to above floor
#define f_hcb_stuck_dn 260		// HCB stuck button down
#define f_hcb_stuck_up 261		// HCB stuck button up
#define f_hcb_led_open_dn 262	// HCB led open down
#define f_hcb_led_open_up 263	// HCB led open up
#define f_hcb_led_short_dn 264	// HCB led short down
#define f_hcb_led_short_up 265	// HCB led short up
#define f_hcb_fet_open_dn 266	// HCB fet open down
#define f_hcb_fet_open_up 267	// HCB fet open up
#define f_hcb_fet_short_dn 268	// HCB fet short down
#define f_hcb_fet_short_up 269	// HCB fet short up
#define f_EBAi_on 270			// Emergency brake A1,A2 input failed on
#define f_EBAi_off 271			// Emergency brake A1,A2 input failed off
#define f_EBBi_on 272			// Emergency brake B1,B2 input failed on
#define f_EBBi_off 273			// Emergency brake B1,B2 input failed off
#define f_dl_fail 274			// DL and DL1 do not match
#define f_ul_fail 275			// UL and UL1 do not match
#define f_hcb_inv_fl 276		// HCB has invalid floor
#define f_hcb_no_com 277		// HCB no comm to individual hc board
#define f_hcb_dev_reset 278		// HCB device reset
#define f_hcb_dn_led_brd 279	// HCB No Down Led Board Detected
#define f_hcb_up_led_brd 280	// HCB No Up Led Board Detected
#define f_hcb_led_short_red_up	 281	// HCB led short red up
#define f_hcb_led_short_green_up 282	// HCB led short green up
#define f_hcb_led_short_blue_up	 283	// HCB led short blue up
#define f_hcb_led_short_blue_dn	 284	// HCB led short blue down
#define f_hcb_led_short_green_dn 285	// HCB led short green down
#define f_hcb_led_short_red_dn	 286	// HCB led short red down
#define f_hcb_led_open_red_up	 287	// HCB led short red up
#define f_hcb_led_open_green_up  288	// HCB led open green up
#define f_hcb_led_open_blue_up	 289	// HCB led open blue up
#define f_hcb_led_open_blue_dn	 290	// HCB led open blue down
#define f_hcb_led_open_green_dn  291	// HCB led open green down
#define f_hcb_led_open_red_dn	 292	// HCB led open red down
#define f_hcb_fet_short_red_up	 293	// HCB fet short red up
#define f_hcb_fet_short_green_up 294	// HCB fet short green up
#define f_hcb_fet_short_blue_up	 295	// HCB fet short blue up
#define f_hcb_fet_short_blue_dn	 296	// HCB fet short blue down
#define f_hcb_fet_short_green_dn 297	// HCB fet short green down
#define f_hcb_fet_short_red_dn	 298	// HCB fet short red down
#define f_hcb_fet_open_red_up	 299	// HCB fet short red up
#define f_hcb_fet_open_green_up  300	// HCB fet open green up
#define f_hcb_fet_open_blue_up	 301	// HCB fet open blue up
#define f_hcb_fet_open_blue_dn	 302	// HCB fet open blue down
#define f_hcb_fet_open_green_dn  303	// HCB fet open green down
#define f_hcb_fet_open_red_dn	 304	// HCB fet open red down
#define f_pwl_ups_low_bat		 305	// power loss ups batter fault
#define f_pwl_ups_on_bat_pwr	 306	// power loss ups on battery power
#define f_pwl_ups_turned_off	 307	// power loss ups turned off
#define f_pwl_ups_online		 308	// power loss ups online fault
#define f_pwl_ups_low_bat_volt	 309	// power loss ups batter fault
#define f_uldl_setup_count		 310	// UL,DL setup count fault
#define f_ep_to_car 310			// Start of fault index for Emergency Power Recall time-out
#define f_ep_to_car_1 311		// Emergency Power Recall Time-out Car 1
#define f_ep_to_car_2 312		// Emergency Power Recall Time-out Car 2
#define f_ep_to_car_3 313		// Emergency Power Recall Time-out Car 3
#define f_ep_to_car_4 314		// Emergency Power Recall Time-out Car 4
#define f_ep_to_car_5 315		// Emergency Power Recall Time-out Car 5
#define f_ep_to_car_6 316		// Emergency Power Recall Time-out Car 6
#define f_ep_to_car_7 317		// Emergency Power Recall Time-out Car 7
#define f_ep_to_car_8 318		// Emergency Power Recall Time-out Car 8
#define f_SPB_SFC_flt 319		// Safety Processor Board SFC fault
#define f_ep_ots_car 319		// Start of fault index for Emergency Power Recall Car Out of Service
#define f_ep_ots_car_1 320		// Emergency Power Recall Car Out of Service Car 1
#define f_ep_ots_car_2 321		// Emergency Power Recall Car Out of Service Car 2
#define f_ep_ots_car_3 322		// Emergency Power Recall Car Out of Service Car 3
#define f_ep_ots_car_4 323		// Emergency Power Recall Car Out of Service Car 4
#define f_ep_ots_car_5 324		// Emergency Power Recall Car Out of Service Car 5
#define f_ep_ots_car_6 325		// Emergency Power Recall Car Out of Service Car 6
#define f_ep_ots_car_7 326		// Emergency Power Recall Car Out of Service Car 7
#define f_ep_ots_car_8 327		// Emergency Power Recall Car Out of Service Car 8
#define f_dn_setup 328			// Down Normal must turn on before reaching bottom floor dead level
#define f_un_setup 329			// Up Normal must turn off after reaching the top floor dead level
#define f_advpt_start 330		// Did not get safe on advance pre-torque start
#define f_sel_preset 331		// Selector preset position fault
#define f_umotion_flt 332		// Unintended Motion fault
#define f_EMBK_trip 333			// Emergency Brake Trip fault
#define f_utm_gts_flt 334		// UTS contact/GTS input pick fault
#define f_EMBK_set 335			// Emergency brake set from brake fault
#define f_fdet_edg_to 336		// Front Detector Edge Time-out
#define f_rdet_edg_to 337		// Rear Detector Edge Time-out
#define f_L1_Voltage_Low 338	// L1 Line Voltage Low
#define f_L2_Voltage_Low 339	// L2 Line Voltage Low
#define f_L3_Voltage_Low 340	// L3 Line Voltage Low
#define f_Door_Voltage_Low 341	// Door Line Voltage Low
#define f_LHC_fuse 342			// Lobby Call common fuse
#define f_Door_Motor_OVL 343	// Door Motor Overload
#define f_Hoist_Motor_OVL 344	// Hoist Motor Overload
#define f_Car_Top_Stop_Sw 345	// Car top stop switch 
#define f_dl_safe_flt 346 		// Door lock safe fault
#define f_cg_safe_flt 347		// Car Gate safe fault
#define f_fdcc_safe_flt 348		// Door Close Contact safe fault
#define f_rdcc_safe_flt 349		// Rear Door Close Contact safe fault
#define f_pwl_ups_low_bat_cap 350	// power loss ups battery capacity low fault
#define f_ins_eexit 351			// emergency motion exit from inspection 
#define f_reset_run_inhibit 352	// Run inhibit from reset count
#define f_atfloor_shutdown 353	// At floor shutdown
#define f_hotoil 354			// Hot Oil Fault
#define f_epr_pwr_mov_flt 355	// EP Recovery power lost while moving
#define f_ccb_led_short_red 356	// Car Call Board LED short red 
#define f_ccb_led_short_green 357	// Car Call Board LED short green
#define f_ccb_led_short_blue 358 // Car Call Board LED short blue
#define f_ccb_led_open_red 359	 // Car Call Board LED open red
#define f_ccb_led_open_green 360 // Car Call Board LED open green
#define f_ccb_led_open_blue 361	 // Car Call Board LED open blue
#define f_ccb_fet_short_red 362	 // Car Call Board FET short red 
#define f_ccb_fet_short_green 363	// Car Call Board FET short green 
#define f_ccb_fet_short_blue 364 // Car Call Board FET short blue 
#define f_ccb_fet_open_red 365	 // Car Call Board FET open red 
#define f_ccb_fet_open_green 366 // Car Call Board FET open green 
#define f_ccb_fet_open_blue 367	 // Car Call Board FET open blue
#define f_ccb_led_board 368		 // Car Call LED board missing
#define f_ccb_stuck_button 369	 // Car Call Board stuck button
#define f_ccb_comm_bd1 370		 // Car Call Board local board 1 comm loss
#define f_ccb_comm_bd2 371		 // Car Call Board local board 2 comm loss
#define f_ccb_comm_xbd1 372		 // Car Call Board local aux board 1 comm loss
#define f_ccb_comm_xbd2 373		 // Car Call Board local aux board 2 comm loss
#define f_hcb_low_supply_voltage 374 // Hall call board has low supply voltage
#define f_hcb_up_input_overload 375	 // HCB Up input overload
#define f_hcb_dn_input_overload 376	// HCB Down input overload
#define f_hcb_xu_input_overload 377	// HCB Aux Up input overloadmomentary_dcb
#define f_hcb_xd_input_overload 378	// HCB Aux Down input overload
#define f_fvars_partial_init 379	// Field variables partial table initialized
#define f_rcm_lock_off	380		// Retiring Cam/Lock fault
#define f_ebrk_can_error 381	// Emergency Brake board can error
#define f_encoder_preset 382	// encoder Preset error
#define f_encoder_preset 382	// encoder Preset error
#define f_encoder_ppr_err 383	// encoder ppr error
#define f_encoder_com_err 384 	// encoder com error
#define f_encoder_init 385		// encoder init
#define f_vel_decel_diff 386	// Velocity decel difference fault
#define f_spb_dir_fault 387		// SPB encoder opposite direction fault
#define f_limit_dir_flt 388		// Car hit limits in wrong direction fault
#define f_dir_fault	389			// Encoder direction fault
#define f_keb_no_run_mode 390	// Keb drive not in run mode
#define f_uldl_dir_flt 391		// UL and DL Direction Fault
#define f_can_bus_idle 392		// can bus idle error
#define f_can_ack_err 393		// can bus acknowledge error
#define f_encoder_busy_flt 394 // Encoder busy fault
#define f_spb_vel_diff 395		// SPB Velocity difference fault
#define f_user_init 396			// User variable init
#define f_lw_init 397			// Load weigher init
#define f_MRAM_fault 398		// Mram Fault
#define f_enc_can_bus_off 399	// Encoder can bus off
#define f_enc_can_bus_idle 400	// Encoder can bus idle
#define f_enc_can_ack_err 401	// Encoder can bus acknowledge error
#define f_enc_can_pkt_flt 402	// Encoder can bus packet fault
#define f_xbrk_over_current 403		// Aux Brake board over current fault (brake error 2)
#define f_xbrk_over_volt 404		// Aux Brake board over voltage fault (3)
#define f_xbrk_no_current 405		// Aux Brake board no current fault with voltage applied (4)
#define f_xbrk_no_dc_bus_volt 406	// Aux Brake board no dc bus voltage fault (5)
#define f_xbrk_no_output_volt 407	// Aux Brake board not output voltage fault	(6)
#define f_xbrk_low_dc_bus_volt 408	// Aux Brake board low dc bus voltage fault	 (7)
#define f_xbrk_dmd_gt_dc_bus 409	// Aux Brake board dmd voltage greater than dc bus voltage fault (8)
#define f_gts_eexit 410			// GTS Motion emergency exit
#define f_EBK1_off 411			// Emergency Brake EBK1 failed off fault
#define f_EBK1_on 412			// Emergency Brake EBK1 failed on fault
#define f_EBK2_off 413			// Emergency Brake EBK2 failed off fault
#define f_EBK2_on 414			// Emergency Brake EBK2 failed on fault
#define f_grip_levflt 415			// Gripper set from leveling fault
#define f_EMBK_levflt 416			// Emergency brake set from leveling fault

#if ((Traction == 0) || (Tract_OL == 1))
int16 off_FSL_state;
bool can_enc_init = 0;
bool can_enc_com_err = 0;
bool EncCan_Upd = 0;
#endif

int16 FS_DOB_DIS=0;       // fire phase 1 door open button dissable
int16 fs2_to_fs1=0;       // fire phase 2 changing modes to fire phase 1
int16 fs2_on = 0;			// fire phase 2 switch on
int16 fs2_hold = 0;		// fire phase 2 switch hold
int16 fs2_start = 0;		// fire phase 2 switch start
int16 fs_on = 0;			// fire phase 1 switch input
int16 prev_fs_on = 0;		// previous value fire phase 1 switch input
int16 fsx_on = 0;			// fire phase 1 aux switch input
int16 mes_on = 0;			// main egress input 
int16 alt_on = 0;			// alternate egress input
int16 mrs_on = 0;			// machine room sensor input
int16 hws_on = 0;			// hoistway sensor input
int16 hws2_on = 0;		// hoistway 2 sensor input
int16 fs1_reset_on = 0;	// fs1 reset input
int16 fs1_effect=0;       // fire service phase 1 is in effect
int16 fs1_effect_reset=0;	// fire phase 1 effect reset flag
int16 fire_sensor=0;		// fire sensor has been activated 1 = main recall, 2 = alternate recall
int16 fire_reset=0;		// fire reset enabled from reset switch
int16 fire_floor=1;		// fire recall floor
int16 old_fire_floor=0;	// old fire floor
int16 old_firef=0;        // old fire service phase flag
int16 old_rfiref=0;        // old rear fire service phase flag
int16 rfiref=0;           // rear door fire service phase flag
int16 Blink_FSL=0;        // Blinking FSL light fire in Machine room or hatch
int16 Extinguish_FSL=0;	// Extinguish Fire Service Output (Phase one before/after device actuation)
int16 off_FSL_state;
int16 firef=0;            // door fire service phase flag
			// firef = 0 not on fire service
			// firef = 1 phase 1 main eggress return
			// firef = 2 phase 1 alternate eggress return
			// firef = 3 phase 1 completed
			// firef = 4 phase 2 door hold operation
			// firef = 5 phase 2 peek-boo door open
			// firef = 6 phase 2 constant pressure dc
			// firef = 7 phase 2 reboot stay put
			// firef = 8 phase 2 momentary dcb door close
int16 fire_stopsw_hold=0;	// used in a17.1 2000 to hold car until car call entered after stop switch hit.
int16 fire_status=0;		// Fire Status:
						// 	bit0: MES
						//	bit1: ALT
						// 	bit2: MRS
						//  bit3: HWS
						//  bit4: HWS2
						//  bit5: FS or FSX Switch
						//  bit6: unused
						//  bit7: Fire from other car
int16 fire_fdo_seq = 0;		// denver fire service phase 1 front door open sequence flag
int16 fire_rdo_seq = 0;		// denver fire service phase 1 rear door open sequence flag
int16 car_hc_fire_door_open = 0;	// 	hall call fire door open sent from group

int16 momentary_dcb=0;	//momentary door close button
int16 momentary_rdcb=0;	//momentary rear door close button						
int16 hsf = 0;            // high speed flag
			// hsf = 0 no high speed hsf = 1 go high speed
int16 startf = 0;		// Start flag 1 = valid start, 0 = no start
int16 stallf=0;          // low oil or stalled flag
			// stallf = 0 no low oil condition
			// stallf = 1 low oil go to bottom 
			// stallf = 2 open doors
			// stallf = 3 at bottom dwelling doors
			// stallf = 4 at bottom closing doors
int16 old_stallf=0;
int16 lps_stall=0;		// 1 = low pressure switch stall
int16 nstopf = 0;         // need to stop flag
			// nstopf = 0 no need to stop
			// nstopf = 1 stop at next floor
int16 short_fl_run = 0;		// Short floor run flag
int16 no_high_speed = 0;		// No high speed output
int16 front_slowdown = 0;		// Front slowdown
int16 rear_slowdown = 0;		// Rear slowdown
#define uc_sd 1				// up hall call slowdown
#define dc_sd 2				// down hall call slowdown
#define cc_sd 4				// car call slowdown
#define uc_do 0x10			// request up call door open
#define dc_do 0x20			// request down call door open
#define cc_do 0x40			// request car call door open
#define iruc_sd 0x100		// up hall call slowdown
#define irdc_sd 0x200		// down hall call slowdown

int16 predof = 0;         // preopen door flag
			// predof = 0 doors are not preopening
			// predof = 1 doors are preopening
int16 old_procf = 0;
int16 prev_procf=0;
int16 procf=0;            // procedure flag
			// procf = 1 elevator is in reset
			// procf = 2 elevator is in inspection
			// procf = 3 elevator is in motion
			// procf = 4 elevator is in motion mode1
			// procf = 5 elevator is in motion mode2
			// procf = 6 elevator is in motion mode3
			// procf = 7 elevator is in motion mode4
			// procf = 8 elevator is in motion mode5
			// procf = 9 elevator is in motion mode6
			// procf = 10 elevator is in motion mode7
			// procf = 11 elevator is in motion mode8
			// procf = 12 elevator is in open saftey string
			// procf = 13 elevator is turned off
			// procf = 14 elevator is parked
			// procf = 15 elevator is waiting assignment
			// procf = 16 elevator is working doors
			// procf = 17 elevator is in low oil mode
			// procf = 18 elevator is resetting hydro jack
			// procf = 19 elevator is on Low Oil Pressure mode
			// procf = 20 elevator is in automatic learn hoistway
			// procf = 21 elevator is in emergency power recovery

int32 prev_statusf=0;
int32 statusf=0;				// Status flag
#define sf_LC 0x1L			// Status: NO LC power
#define sf_HC 0x2L			// Status: NO HC power
#define sf_SS 0x4L			// Status: NO SS input
#define sf_READY 0x8L		// Status: Drive not ready
#define sf_GRIP 0x10L		// Status: Gripper error
#define sf_IO 0x20L 		// Status: I/O error during redundancy check
#define sf_INS 0x40L		// Status: Inspection or lock bypass fault
#define sf_BPI 0x80L		// Status: Binary Position Input Error
#define sf_POS 0x100L 		// Status: Position Error
#define sf_AD 0x200L		// Status: No automatic Doors
#define sf_STP 0x400L		// Status: Stop switch open
#define sf_DZ 0x800L		// Status: Door Zone fault
#define sf_GDL 0x1000L		// Status: Gate or Door lock fault
#define sf_P 0x2000L   		// Status: No Potential Input
#define sf_DCL 0x4000L		// Status: No DCL
#define sf_DCC 0x8000L		// Status: No Door Close Contact
#define sf_BRKS 0x10000L	// Status: Brake lift switch error
#define sf_TOC 0x20000L		// Status: Top of Car Comm Error
#define sf_DRV 0x40000L		// Status: Drive Comm Error
#define sf_SPB 0x80000L		// Status: Safety Processor Board Comm Error
#define sf_DBR 0x100000L  	// Status: DB Resistor Temp. Error
#define sf_SHUTDN 0x200000L	// Status: Shutdown (too many fault runs)
#define sf_ASTST 0x400000L	// Status: Annual Safety Test
#define sf_SAFE 0x800000L	// Status: Waiting for Car to be safe()
#define sf_TLimit 0x1000000L // Status: UT,UTS,DT or DTS limit error
#define sf_GTS 0x2000000L	// Status: GTS input off
#define sf_ULDLDZ 0x4000000L	// Status: UL, DL and DZ off at floor
#define sf_BKCAN 0x8000000L // Status: Brake Board Can Error
#define sf_FSTP 0x10000000L // Status: Fire Fighter Stop Switch
#define sf_SELCAN 0x20000000L // Status: Selector Can error
#define sf_ULDL 0x40000000L	// Status: UL or DL fault
#define sf_LEV 0x80000000L	// Status: Leveling fault

int32 prev_statusf2=0;
int32 statusf2=0;			// Status flag
#define sf_HWINIT 0x1L		// Status: Hardware Init fault
#define sf_FDC 0x2L			// Status: Front Door Closing Fault
#define sf_RDC 0x4L			// Status: Rear Door Closing Fault
#define sf_LVolt 0x8L 	  	// Status: Line Voltage Fault
#define sf_DVolt 0x10L 	  	// Status: Door Voltage Fault
#define sf_BKSR 0x20L		// Status: Brake lift switch run error 
#define sf_DMO 0x40L		// Status: Door motor overload
#define sf_LearnHW 0x80L	// Status: Learn Hoistway Fault
#define sf_PWLUPS 0x100L	// Status: Power Loss UPS Fault
#define sf_EBKCAN 0x200L	// Status: Emergency Brake Can error
#define sf_KEBRUN 0x400L	// Status: KEB Drive Not in Run Mode
#define sf_AF_SHUTDN 0x800L	// Status: At Floor Shutdown
#define sf_1036 0x1000L		// Status: 1036 board connected

int16 safety_string_status=0;
#define sss_GOV 0x0001		// Governor input open
#define sss_TF  0x0002		// Top Final Limit Open
#define sss_BF  0x0004		// Bottom Final Limit open
#define sss_PS  0x0008		// Pit Switch open
#define sss_PDS 0x0010		// Pit Door Switch open
#define sss_BS  0x0020		// Buffer Switch open
#define sss_CMP 0x0040		// Compensating Rope Switch open
#define sss_TEE	0x0080		// Top Emergency Exit Switch open
#define sss_SEE 0x0100		// Side Emergency Exit Switch open
#define sss_CSS 0x0200		// Car Safety Switch open
#define sss_SS  0x0400		// Car Top Stop Switch or Fire Fighter Stop Switch
#define sss_CTS 0x0800		// Car Top Stop switch open
#define sss_HMO 0x1000		// Hoist Motor Overload

int16 power_status = 0;
#define ps_HC   0x0001		// Hall call power loss
#define ps_HCL	0x0002		// Hall call light power loss
#define ps_CC	0x0004		// Car call power loss
#define ps_CCL	0x0008		// Car call light power loss
#define ps_LHC  0x0010		// Lobby Hall common power loss

int16 old_rdoorf=0;
int16 rdoorf=0;           // rear door flag
			// rdoorf = 0 doors closed no action
			// rdoorf = 1 doors are opening
			// rdoorf = 2 doors are dwelling
			// rdoorf = 3 doors are closing
			// rdoorf = 4 doors are nudging closed
int16 ins_rdoorf=0;
int16 rdo_seq = 0;	// Set when rear door reaches full open (RDOL) 
int16 rdoor_en=0;		// rear door enable
int16 rdoor_req=0;	// rear door request to open
int16 rdob_req=0;		// rear door open button request
int16 rcc_req=0;		// rear car call door open request
int16 rnudgst=0;		// rear door nudging status
int16 rdo_to = 0;		// Set when door open limit times out.
int16 ree_to = 0;		// Set when rear electric eye times out.
int16 manual_rdoor = 0;		// set for manual door (added to have swing rear door with automatic front)
int16 drop_rear_rcm = 0;		// set to drop rear RCM
int16 freight_rdoor_alarm = 0;	// freight rear door alarm
int16 rsdo=0;				// Rear swing door open
int16 rsdo_seq=0;			// Rear swing door open sequence
int16 relevel=0;          // relevel
			// relevel = 0 elevator is not releveling
			// relevel = 1 elevator is releveling
int16 relevel_req=0;		// request to relevel 
						// 1 = car is not level and needs to relevel
						// 0 = car is level or in leveling
int16 stop_seq = 0;		// Stop sequence
						// 0 = stopped and run and mc dropped
						// 1 = stopped with soft stop timming
						// 2 = stopped with soft stop timmed out but run and mc timming
int16 leveling_fault_cnt = 0;	// Leveling fault counter (relevel called before the stop sequence went to zero
int16 leveling_fault = 0;	// leveling fault flag: 1 = leveling fault in the up, 2 = leveling fault in the down.
int16 micro_relevel = 0;	// set to 1 for active micro releveling 
int16 lev_startf = 0;		// leveling start flag
int16 prev_servf=0;
int16 servf=0;            // service flag
			// servf = 0 out of service
			// servf = 1 full automatic service
			// servf = 2 independent service
			// servf = 3 load weighing by pass service
			// servf = 4 attendant service
			// servf = 5 code blue service
			// servf = 6 fire phase 2 service
			// servf = 7 emergency power service
			// servf = 8 earth quake emergency service
			// servf = 9 fire service phase 1 main eggress
			// servf = 10 fire service phase 1 alt eggress
			// servf = 11 homing operation
			// servf = 12 reset dive up
			// servf = 13 reset dive down
			// servf = 14 Stalled operation
			// servf = 15 return to lobby
			// servf = 16 load overload
			// servf = 17 Medical Emergency Service
			// servf = 18 Calibrate load weigher
			// servf = 19 CS Elevator Off
			// servf = 20 HS Elevator Off
			// servf = 21 Low Pressure Operation
			// servf = 22 Hospital Service Operation.
			// servf = 23 Vip Service Operation
			// servf = 24 Security Recall
			// servf = 25 Sabbath service
			// servf = 26 TUG Service operation

int16 rhjackf=0;			// Reset Hydro Jack Flag
			// rhjackf = 0	normal operation
			// rhjackf = 1	begin timing for reset jack operation
			// rhjackf = 2	run car down onto jack
			// rhjackf = 3	turn everything off for 2 seconds
			// rhjackf = 4  run car up to 1st floor
			// rhjackf = 5  reset jack complete

int16 stepf=1;            // position stepping flag
			// stepf = 1 allows a change of position (set when car hits DZ)
			// stepf = 0 the position can't change (Cleared when car hits US or DS)
int16 rev_stepf=0;	// Reverse step, 
			// rev_stepf = 0 car is between door zone and reverse direction slowdown
			// rev_stepf = 1 car passed the reverse direction slowdown
int16 pass_fl = 0;	// pass the next floor at leveling speed  (short floor operation)
			// pass_fl = 0 stop at the next floor when hsf is 0
			// pass_fl = 1 pass the next floor, inc or dec position then clear flag
/* Releationship of rev_stepf and stepf
				R=rev_stepf, S=stepf, P=pass_fl
				Down run			Up run				On a reversal direction mid flight stop
				R,S,P				R,S,P					  R,S --> R,S
		DZ		0,1,0				0,1,0					  1,0 --> 1,1
		US		1,1,0				1,0,0					  1,1 --> 1,0

		DS		1,0,0				1,1,0					  0,1 --> 0,1
		DZ		0,1,0				0,1,0
		US		1,1,0				1,0,0

		DS		1,0,0				1,1,0
		DZ		0,1,0				0,1,0
		US		1,1,0				1,0,0

		DS		1,0,1 no sd			1,1,0
		 DS off	1,1,1 no sd			1,1,0
		DS 		1,0,1
		DZ		0,1,1				0,1,0
											   Short floor
		DZ		0,1,0				0,1,1
		US		1,1,0				1,0,1	   dec position on recovery if pass fl set and clear stepf  
		 US off	1,1,0				1,1,1 no sd				  on forward run and set stepf on reversal
		US		1,1,0				1,0,1 no sd

		DS		1,0,0				1,1,0
		DZ		0,1,0				0,1,0
		US		1,1,0				1,0,0

		DS		1,0,0				1,1,0
		DZ		0,1,0	   			0,1,0
*/

int16 medf=0;			 // Mass. Medical Emergency Service
			// medf = 0 no medical emergency service
			// medf = 1 recall car to medical emergency floor
			// medf = 2 car at medical emergency floor with door open (return complete)
			// medf = 4 On EMS car call service
			// medf = 5 On EMS car hold service (key off but not at the recall floor)
int16 med_latch = 0;	// Switch latch for medical emergency service
int16 govrstf = 0;		// Governor reset flag			
int16 govtripf = 0;		// Governor trip flag			
int16 pwl_brakef = 0;		// Flag to pick brake with power loss
			 
int16 keep_lants_on=0;    // keeps the cab riding lanterns on
int16 keep_rlants_on=0;   // keeps the rear cab riding lanterns on
int16 lant_up=0;			// logical boolean for lantern up
int16 lant_dn=0;			// logical boolean for lantern down
int16 rlant_up=0;			// logical boolean for rear lantern up
int16 rlant_dn=0;			// logical boolean for rear lantern down
int16 cab_lant_up=0;		// logical boolean for cab lantern up
int16 cab_lant_dn=0;		// logical boolean for cab lantern dn
int16 cab_rlant_up=0;		// logical boolean for cab rear lantern up
int16 cab_rlant_dn=0;		// logical boolean for cab rear lantern dn
int16 up_dir_arrow = 0;	// logical boolean for up direction arrow
int16 dn_dir_arrow = 0;	// logical boolean for down direction arrow

int16 flight_times[fl_size][fl_size];
int16 Viscosity = 0;
int16 bypass_hc = 0;
int16 hb_en = 0;			// handicap buzzer enable control flag
int16 handicap_buz = 0;	// handicap buzzer flag
int16 hb_cc_buz = 0;		// handicap car call buzzer flag
int16 cc_sec_buz = 0;		// car call security buzzer flag
int16 nudg_buz = 0;		// Nudging buzzer boolean
int16 rnudg_buz = 0;		// Nudging buzzer boolean for rear door
int16 fire_buz = 0;		// Fire service buzzer boolean
int16 med_buz = 0;		// Medical Emergency service buzzer boolean
int16 att_buz = 0;		// Attendant Buzzer
int16 att_buz_on = 0;		// Attendant Buzzer On timer 
int16 att_nmb_hc2buz = 0; // Attendant Number of Hall Calls to Buzz
int16 att_nmb_hc = 0;		// Attendant Number of Hall Calls 
int16 update_att_nmb_hc = 0;	//Update the number of hall calls that the system needs to Buzz
int16 att_buz_hc = 0;		// Attendant Buzz on hall call
int16 att_buz_hc_en = 0;	// Attendant Buzz on hall call enable
int16 door_buz = 0;		// Manual door left open buzzer
int16 sabb_buz = 0;		// Sabbath warning buzzer before doors close
int16 sabb_ee_en = 0;		//sabbath electric eye enable
int16 sabbath_active = 0;	// Sabbath active flag (when sabbath is running)
int16 sabbath_start = 0;	// Wait until set to 1 to start sabbath operation
int16 timeout_mandoor = 0; //	timeout manual door for hall calls
int16	stp_sw = 0;			// debounced stp input
int16 ut_limit = 0;		// Debounced ut input
int16 dt_limit = 0;		// Debounced dt input
int16 uts_limit = 0;		// Debounced uts input
int16 dts_limit = 0;		// Debounced dts input
int16 start_floor;
int16 no_fault;
int16 zone_fl=0;			// floor to zone car
int16 latch_HEOF=0;		// Latch HEOF operation
int16 latch_JAIL=0;		// Latch for Jail break input
int16 galcom_ver = 0;
int16 galcom_rev = 0;
int16 prev_disp_com2 = 0;		// previous dispatcher


// interger variables used throughout the program
int16 nmb_carcalls=0;		// number of latched car calls
int16 all_cars_ots=0;     // all cars are out of service
int16 nmb_cars_in_svc = 0;			// number of cars in service
int16 stops[fl_size * 2];          // keep an array of the sequence of stops
int16 nmbstops;           // number of stops to clear calls
int16 carcb[fl_size];          // car call buffer value = 1 there is a call
int16 rcarcb[fl_size];         // rear car call buffer value = 1 there is a rear call
int16 closetry = 0;       // number of times the doors have tryed to close
int16 rclosetry = 0; 		// number of times the rear doors have tryed to close
int16 safe_closetry = 0;  	// number of times the doors have tryed to close to get safe
int16 safe_rclosetry = 0; 	// number of times the rear doors have tryed to close to get safe
int16 codebfl=0;          // code blue floor value is position of emergency
int16 vipfl=0;			// priority service (vip) floor
int16 doort=50;           // door dwell time
int16 rdoort=50;          // rear door dwell time
int16 dtmrf = 0;			// door dwell timer flag
#define cc_dt 1			// car call door time was set
#define hc_dt 2			// hall call door time was set
int16 upcb[fl_size];           // up hall call buffer value = 1 there is a call
int16 rupcb[fl_size];          // rear up hall call buffer value = 1 there is a call
int16 downcb[fl_size];         // down hall call buffer value = 1 there is a call
int16 rdowncb[fl_size];        // rear down hall call buffer value = 1 there is a call
int16 nmbflts=0;          // number of faults that have occured
int16 position;           // the position of the elevator
int16 prev_position;		// the previous position of the elevator
int16 scnd_pos;		// temporary position between floors 
int16 prev_scnd_pos;
int16 preset = 0;			// set to 1 when binary preset is set
int16 preset_pos = 0;		// set to 1 to update the preset the position
int16 Lev_Mode=0;         // Used for emergency slowdown traction's
int16 Hoistway_Learned=0; // Hoistway Learned 1 to run automatic
int16 Field_Force=0;		// Field Force
int16 rset=1;             // in reset and have not found a floor yet
int16 rset_run_cnt=0;			// reset run count: consecutive times the car runs to find a floor
int16 rset_error_cnt=0;		// max times to log reset error looping in reset mode
int16 baud_default = 0;
int16 ext_temperature=0;	// External temperature
int16 mr_temperature=0;	// Motor room temperature
int16 safe_override_seq = 0;		// safe override sequence to lift brake on inspection

#if (Traction == 1)
float Max_Lant_Time = 0;
#endif

int16 epr_dirf = 0;				// Emergency power recovery direction
int16 prev_epr_dirf = 0;			// Emergency power recovery direction debounce flag

int16 speed_clamp[9] = {0,0,0,0,0,0,0,0,0};	// Software velocity clamp stored in non-volitile memory
#define sc_ins_lev 0
#define sc_UT_DT   1
#define sc_UT1_DT1 2
#define sc_UT2_DT2 3
#define sc_UT3_DT3 4
#define sc_UTS_DTS 5
#define sc_UT4_DT4 6
#define sc_UT5_DT5 7
#define sc_UT6_DT6 8

int16 enc_vel_timer=0;		// velocity timer for encoder velocity calculation 
int16 enc_dir_timer=0;
int16 enc_start_read_cnt=0;
int16 dz_dbn_timer=0;
int16 drive_update_timer=0;
int16 dpyspi_timer=0;
int16 can_sel_timer=0;
int16 can_sync_timer=0;
int16 ovs_dbn_tim=0;
int16 Overspeed_Test = 0;
int16 hold_brake_overspeed = 0;
int16 Buffer_Test = 0;
int16 don_delay = 0;			// drive on delay timer


// Security variables

unsigned char zero_Code[4]={0,0,0,0};		// Holdes the security code being entered

#if (Tract_HR == 1)
int16 Security_Type[car_size] = {0,0,0,0,0,0,0,0,0};	// 0 = No Security, 
#else
int16 Security_Type[car_size] = {0,0,0,0,0,0,0};	// 0 = No Security, 
#endif
										// 1 = Car call lockouts in the car,  CCS
										// 2 = Group car call lockouts,  GCS
										// 4 = Group car call lockouts GCS and seperate hall call lockouts on rear cc lockout board	HCS
										// 8 = Group car and hall call lockouts	FLS
										// 16 = Car lockout override using lockout inputs on car   OCS
										// 32 = Seperate hall call security inputs on the GPIO boards  HCS
										// 64 = Car call latch ouputs to security system (use or'ed with option 1 (cc lockouts))
										// 128 = Override car call lockouts through group (use or'ed with option 1 (cc lockouts))
int16 Car_Call_Lockouts = 0; // Car call lockouts and car reader security
int16 Lockout_Override = 0;	// Key input to override group floor or ids floor security (uses car call lockout inputs)
int16 Sec_Fl_Mask = 0;		// Security Floor mask select switch
int16 Grp_CC_Lockouts = 0;	// Group car call lockouts security option flag
int16 Grp_CC_Override = 0;	// Group car call lockout override security option flag
int16 Grp_HC_Lockouts = 0;	// Group hall call lockouts security option flag
int16 ind_override = 0;		// Independent overrides security when set
int16 sec_recall = 0;			// Set to recall car on security.
int16 recall_dir = 0;			// recall in the same direction as the recall floor 
int16 sec_recall_complete = 0;	// Set when security recall is complete.
int16 sec_panic_recall = 0;		// panic recall flag to cancel car calls and recall to security floor
int16 ind_sec_recall = 0;			// Initiate Independent security recall

int32 cc_sec_mask[2] = {0,0};		// Car call security mask
int32 rcc_sec_mask[2] = {0,0};		// Rear Car call security mask
int32 master_cc_sec[2] = {0,0};		// Car call security mask
int32 master_rcc_sec[2] = {0,0};		// Rear Car call security mask
int32 master_cc_sec_prev[2] = {0,0};		// Car call security mask
int32 master_rcc_sec_prev[2] = {0,0};		// Rear Car call security mask


int16 group_alrm[9] = {0,0,0,0,0,0,0,0,0};
int16 car_alrm = 0;

// Group I/O's common to car and group ... Must be set in car z6 cpu

uint8 gin_EMP = 0;
uint8 gin_EPT = 0;
uint8 gin_ATTHC = 0;
uint8 gin_DOL = 0;
uint8 gin_DOLR = 0;
uint8 gin_SAB = 0;
uint8 gin_SECFM = 0;
uint8 gin_HCP = 0;
uint8 gin_UC[6] = {0,0,0,0,0,0};
uint8 gout_UC[6] = {0,0,0,0,0,0};
uint8 gin_DC[6] = {0,0,0,0,0,0};
uint8 gout_DC[6] = {0,0,0,0,0,0};




// int32 variables used throught the program
#define nmblvar 20
int32 lvars[nmblvar];
#define nmbcc 0         // number of car calls
#define nmbuc 1         // number of up calls
#define nmbdc 2         // number of down calls
#define uc_less15 3     // number of up calls answered in less than 15 sec
#define uc_less30 4     // number of up calls answered in less than 30 sec
#define uc_less45 5     // number of up calls answered in less than 45 sec
#define uc_less60 6     // number of up calls answered in less than 60 sec
#define uc_more60 7     // number of up calls answered in more than 60 sec
#define dc_less15 8     // number of down calls answered in less than 15 sec
#define dc_less30 9     // number of down calls answered in less than 30 sec
#define dc_less45 10    // number of down calls answered in less than 45 sec
#define dc_less60 11    // number of down calls answered in less than 60 sec
#define dc_more60 12    // number of down calls answered in more than 60 sec



int16 day_of_week;
int16 old_day_of_week;

int16 t_door_open = 30;
int16 t_door_dwell = 30;
int16 t_door_close = 30;
int16 t_rdoor_open = 30;
int16 t_rdoor_dwell = 30;
int16 t_rdoor_close = 30;


int16 sr_cc_mask = 0;	// second riser mask has been set when 1


// float floating point variables used throught the program
#define nmbdvar 20
float dvars[nmbdvar];


//#pragma section sdata_type ".sdata"

__declspec(section ".sdata") unsigned char *ccmsk[car_size];     	// car call mask pointer to screen unused calls
__declspec(section ".sdata")unsigned char *ucmsk[car_size];     	// up call mask pointer to screen unused calls
__declspec(section ".sdata")unsigned char *dcmsk[car_size];     	// down call mask pointer to screen unused calls
__declspec(section ".sdata")unsigned char *rccmsk[car_size];    	// rear car call mask pointer to screen unused calls
__declspec(section ".sdata")unsigned char *rucmsk[car_size];    	// rear up call mask pointer to screen unused calls
__declspec(section ".sdata")unsigned char *rdcmsk[car_size];    	// rear down call mask pointer to screen unused calls


unsigned char ccsmsk[car_size][fl_size];    // car call security mask to screen unused calls
unsigned char ucsmsk[car_size][fl_size];    // up call security mask to screen unused calls
unsigned char dcsmsk[car_size][fl_size];    // down call security mask to screen unused calls
unsigned char rccsmsk[car_size][fl_size];   // rear car call security mask to screen unused calls
unsigned char rucsmsk[car_size][fl_size];   // rear up call security mask to screen unused calls
unsigned char rdcsmsk[car_size][fl_size];   // rear down call security mask to screen unused calls

unsigned char ccs2msk[car_size][fl_size];    // car call security mask to screen unused calls
unsigned char ucs2msk[car_size][fl_size];    // up call security mask to screen unused calls
unsigned char dcs2msk[car_size][fl_size];    // down call security mask to screen unused calls
unsigned char rccs2msk[car_size][fl_size];   // rear car call security mask to screen unused calls
unsigned char rucs2msk[car_size][fl_size];   // rear up call security mask to screen unused calls
unsigned char rdcs2msk[car_size][fl_size];   // rear down call security mask to screen unused calls

unsigned char ccs3msk[car_size][fl_size];    // car call security mask to screen unused calls
unsigned char ucs3msk[car_size][fl_size];    // up call security mask to screen unused calls
unsigned char dcs3msk[car_size][fl_size];    // down call security mask to screen unused calls
unsigned char rccs3msk[car_size][fl_size];   // rear car call security mask to screen unused calls
unsigned char rucs3msk[car_size][fl_size];   // rear up call security mask to screen unused calls
unsigned char rdcs3msk[car_size][fl_size];   // rear down call security mask to screen unused calls

unsigned char ccs4msk[car_size][fl_size];    // car call security mask to screen unused calls
unsigned char ucs4msk[car_size][fl_size];    // up call security mask to screen unused calls
unsigned char dcs4msk[car_size][fl_size];    // down call security mask to screen unused calls
unsigned char rccs4msk[car_size][fl_size];   // rear car call security mask to screen unused calls
unsigned char rucs4msk[car_size][fl_size];   // rear up call security mask to screen unused calls
unsigned char rdcs4msk[car_size][fl_size];   // rear down call security mask to screen unused calls

unsigned char ccnmsk[car_size][fl_size];    // car call normal mask to screen unused calls
unsigned char ucnmsk[car_size][fl_size];    // up call normal mask to screen unused calls
unsigned char dcnmsk[car_size][fl_size];    // down call normal mask to screen unused calls
unsigned char rccnmsk[car_size][fl_size];   // rear car call normal mask to screen unused calls
unsigned char rucnmsk[car_size][fl_size];   // rear up call normal mask to screen unused calls
unsigned char rdcnmsk[car_size][fl_size];   // rear down call normal mask to screen unused calls

unsigned char irccmsk[car_size][fl_size];    	// ir car call mask to screen unused calls
unsigned char irucmsk[car_size][fl_size];     	// ir up call mask pointer to screen unused calls
unsigned char irdcmsk[car_size][fl_size];     	// ir down call mask pointer to screen unused calls
unsigned char rirccmsk[car_size][fl_size];   	// rear ir car call mask to screen unused calls
unsigned char rirucmsk[car_size][fl_size];    	// rear ir up call mask pointer to screen unused calls
unsigned char rirdcmsk[car_size][fl_size];    	// rear ir down call mask pointer to screen unused calls

unsigned char xa_uc_msk[fl_size];			// cross assignment up call mask to decide which group gets the floor hall call 1=gal,2=other,3=both 
unsigned char xa_dc_msk[fl_size];			// cross assignment down call mask to decide which group gets the floor hall call 1=gal,2=other,3=both
unsigned char valid_fl[fl_size];		// valid floors for this car
unsigned char stag_rmsk[fl_size];	// staggered rear floor mask
unsigned char heavy_door_fmsk[fl_size];	// heavy door front floor mask
unsigned char heavy_door_rmsk[fl_size];	// heavy door rear floor mask
unsigned char stag_ado_msk[fl_size];	// staggered auto door floor mask
unsigned char stag_ado_rmsk[fl_size];	// staggered auto door rear floor mask

unsigned char sab_ccmsk[fl_size];     	// Sabbath service car call mask pointer to screen unused calls
unsigned char sab_ucmsk[fl_size];     	// Sabbath service up call mask pointer to screen unused calls
unsigned char sab_dcmsk[fl_size];     	// Sabbath service down call mask pointer to screen unused calls
unsigned char sab_rccmsk[fl_size];    	// Sabbath service rear car call mask pointer to screen unused calls
unsigned char sab_rucmsk[fl_size];    	// Sabbath service rear up call mask pointer to screen unused calls
unsigned char sab_rdcmsk[fl_size];   	// Sabbath service rear down call mask pointer to screen unused calls

unsigned char flmrk[fl_size][2];     // floor markings
unsigned char alt_flmrk[fl_size][2]; // alternate floor markings
unsigned char Blind_flmrk[2][2];     // Blind floor markings to display on digital PI indicator.
unsigned char xpi_pos[fl_size];
unsigned char jobnm[26];        // job name
unsigned char add1[26];         // address line #1
unsigned char add2[26];         // address line #2
unsigned char cmp[26];          // company name
unsigned char pass[8][26];      // password
unsigned char user[8][26];      // user name
unsigned char vidmes[3][26];    // video message three lines


// Car call color variables
																				
int16 ccOnBright=0;			// Call On Brightness
int16 ccOffBright=0;		// Call Off Brightness

int16 ccOnRed=0;			// Call On Red
int16 ccOnGreen=0;			// Call On Green
int16 ccOnBlue=0;			// Call On Blue

int16 ccOffRed=0;			// Call Off Red
int16 ccOffGreen=0;			// Call Off Green
int16 ccOffBlue=0;			// Call Off Blue

int16 ccSecOnRed=0;			// Call Security On Red
int16 ccSecOnGreen=0;		// Call Security On Green
int16 ccSecOnBlue=0;		// Call Security On Blue

int16 ccAttUpOnRed=0;		// Call Attendant Up On Red
int16 ccAttUpOnGreen=0;		// Call Attendant Up On Green
int16 ccAttUpOnBlue=0;		// Call Attendant Up On Blue

int16 ccAttDnOnRed=0;		// Call Attendant Down On Red
int16 ccAttDnOnGreen=0;		// Call Attendant Down On Green
int16 ccAttDnOnBlue=0;		// Call Attendant Down On Blue

int16 copFireOnRed=0;		// COP Fire On Red
int16 copFireOnGreen=0;		// COP Fire On Green
int16 copFireOnBlue=0;		// COP Fire On Blue

int16 copMedOnRed=0;		// COP Medical On Red
int16 copMedOnGreen=0;		// COP Medical On Green
int16 copMedOnBlue=0;		// COP Medical On Blue

int16 copEmOnRed=0;			// COP Emergency On Red
int16 copEmOnGreen=0;		// COP Emergency On Green
int16 copEmOnBlue=0;		// COP Emergency On Blue

int16 copOTSOnRed=0;		// COP OTS On Red
int16 copOTSOnGreen=0;		// COP OTS On Green
int16 copOTSOnBlue=0;		// COP OTS On Blue

int16 ccOnBright_prev=0;		
int16 ccOffBright_prev=0;		

int16 ccOnRed_prev = 0;
int16 ccOnGreen_prev = 0;
int16 ccOnBlue_prev = 0;

int16 ccOffRed_prev = 0;
int16 ccOffGreen_prev = 0;
int16 ccOffBlue_prev = 0;

int16 ccSecOnRed_prev = 0;
int16 ccSecOnGreen_prev = 0;
int16 ccSecOnBlue_prev = 0;

int16 ccAttUpOnRed_prev=0;		// Call Attendant Up On Red
int16 ccAttUpOnGreen_prev=0;	// Call Attendant Up On Green
int16 ccAttUpOnBlue_prev=0;		// Call Attendant Up On Blue

int16 ccAttDnOnRed_prev=0;		// Call Attendant Down On Red
int16 ccAttDnOnGreen_prev=0;	// Call Attendant Down On Green
int16 ccAttDnOnBlue_prev=0;		// Call Attendant Down On Blue

int16 copFireOnRed_prev=0;		// COP Fire On Red
int16 copFireOnGreen_prev=0;	// COP Fire On Green
int16 copFireOnBlue_prev=0;		// COP Fire On Blue

int16 copMedOnRed_prev=0;		// COP Medical On Red
int16 copMedOnGreen_prev=0;		// COP Medical On Green
int16 copMedOnBlue_prev=0;		// COP Medical On Blue

int16 copEmOnRed_prev=0;		// COP Emergency On Red
int16 copEmOnGreen_prev=0;		// COP Emergency On Green
int16 copEmOnBlue_prev=0;		// COP Emergency On Blue

int16 copOTSOnRed_prev=0;		// COP OTS On Red
int16 copOTSOnGreen_prev=0;		// COP OTS On Green
int16 copOTSOnBlue_prev=0;		// COP OTS On Blue

int16 CC_ColorOnOffChecksum = 0;


// Drive Type	1=hydro 2=Vector cl-ndf, 3=vector cl-df, 4=gen cl-df, 
//              5=scr cl-df (DSD-412), 6=vector ol-ndf, 7=gen cl-ndf, 8=scr cl-ndf (DSD-412),
//				9=hydro soft starter, 10-Quatro SCR-df, 11-Quatro AC-df,
//              12=KEB AC-df, 14=Delta VDF-VL, 15 = Yaskawa (L1000)
#if (Tract_HR == 1)
int8 Drive_Type[car_size] = {0,0,0,0,0,0,0,0,0}; 
int8 valid_cb_car[car_size] = {0,0,0,0,0,0,0,0,0};	 	// set to 1 for each valid code blue car
int8 valid_cbpr_car[car_size] = {0,0,0,0,0,0,0,0,0};	// set to 1 for each valid code blue primary riser car
int8 valid_cbsr_car[car_size] = {0,0,0,0,0,0,0,0,0};	// set to 1 for each valid code blue secondary riser car
int8 valid_ep_car[car_size] = {0,0,0,0,0,0,0,0,0};		// set to 1 for each valid emergency power car
int8 valid_vip_car[car_size] = {0,0,0,0,0,0,0,0,0};	 	// set to 1 for each valid vip car
#else
int8 Drive_Type[car_size] = {0,0,0,0,0,0,0}; 
int8 valid_cb_car[car_size] = {0,0,0,0,0,0,0};	  		// set to 1 for each valid code blue car
int8 valid_cbpr_car[car_size] = {0,0,0,0,0,0,0};	  	// set to 1 for each valid code blue primary riser car
int8 valid_cbsr_car[car_size] = {0,0,0,0,0,0,0};	  	// set to 1 for each valid code blue secondary riser car
int8 valid_ep_car[car_size] = {0,0,0,0,0,0,0};	  		// set to 1 for each valid code emergency power car
int8 valid_vip_car[car_size] = {0,0,0,0,0,0,0};	  		// set to 1 for each valid vip car
#endif

#define connmb 132
int16 cons[connmb];
#define loadw 0         // cons[loadw]=1 if load weighing switches, 2 = analog load weighing, 3 = load weigher board on machine room can bus
#define arst 1          // cons[arst]=1 if automatic reset is enabled 0=no
#define att 2           // cons[att]=1 if attendant operation, 0=no, 2=annuciator in att + auto
#define behindc 3       // cons[behindc]=1 if behind the car call cancel 0=no
#define bipolar 4       // cons[bipolar]=1 if bipolar scurve 0 if unipolar
#define bottomf 5       // cons[bottomf]= position of the bottom floor
#define carnmb 6        // cons[carnmb] is the car number in the group
#define cblue 7         // cons[cblue]=1 if code blue operation 0=no
#define dcpo 8          // cons[dcpo]=1 if run with door close power 0=no
#define sercom 9   		// cons[sercom] 1= Serial Hall Call, 2=Serial Car, 4=CC in COP, 8=drive, 16=door, 32=hc drivers
#define dispis 10       // cons[dispis]= 0 = Binary, 1 if discrete position indicators, 
						//               +2 = Lobby lantern instead of ISER or RCM
						//               4 = Binary with OS flash Out of Service
						//               6 = Binary with Lobby Lanter and OS flash Out of Service
						//               8 = Use UDA and DDA on car for Att Up and Dn light
						//				16 = Use UDA and DDA on ATT but not on automatic
						//				32 = PI I/Os on 2nd car call board (used with RGB Car Call boards)
						//				64 = Use digital PIs
#define equake 11       // cons[equake]=1 if california earth quake 0=no
#define fax 12          // cons[fax]=1 if fax modem installed
#define frghtd 13       // cons[frghtd]: 0=no
						//				 1=automatic power freight door  
						//				 2=peele
						//				 3=courion model E						
						//				 4=ems,											
						//				 5=courion model D						
						//				 6=front automatic power freight door 						
						//				 7=rear automatic power freight door 						
						//				 8=front and rear  automatic power freight door 						
						//				 9=Guilbert Freight Door						
#define home 14         // cons[home] is the floor number for simplex homing
#define ansi 15      	// cons[ansi] = Ansi code compliance, 1996, 2000, etc --- Previously = cons[hydro] 1=hydro 2=invert 3=vector 4=gen 5=scr 6=vector open loop
#define incrs 16        // cons[incrs]=1 if inconscpicous riser, 2=ir or'ed with std hall calls, 3=special ir for car op in group
#define mand 17         // cons[mand]: 	1 = if manual doors 0 if automatic doors, 
						// 				2 = swing door w/power gate, 
						// 				3 = fixed cam special (deleted), 
						// 				4 = manual staggered rear/automatic front,
						// 				5 = swing w/pwr gate stggered rear/auto front
						// 				6 = Swing rear door with automatic front.
						//				7 = Automatic front/swing front and manual rear
						//				8 = Swing front/manual doors at staggered floor with manual rear
						//				9 = Guilbert Door Operator
#define modem 18        // cons[modem]=1 if modem installed
#define nmbcars 19      // cons[nmbcars] is the number of cars in the group
#define nodzdc 20       // cons[nodzdc]=1 if canadian no door zone close door
#define firesv 21       // cons[firesv]= fire service type: 0=Ansi 1996, 1=New York, 2=Ansi2000, 3=Chicago
#define otslbp 22       // cons[otslbp]=1 out of service lobby park door open, 2 = cycle door closed, 4=Sec Em Recall (RTLDC) and (RTL)
#define predo 23        // cons[predo]=1 if preopen doors on stop 0=no
#define rear 24         // cons[rear]=1 if rear doors 0=no
#define epgrp 25 		// cons[epgrp]=car number if inter-group emergency operation; previously = cons[Encoder_PPM]
#define speed 26        // cons[speed]= elevator speed in fpm
#define topf 27         // cons[topf]= position of the top floor
#define brake 28        // cons[brake] = 2 for electronic brake board, 3=3phase brake
#define grtopf 29       // cons[grtopf]= the top floor of the group
#define BinPiIn 30      // cons[BinPiIn] = 1 for binary input floor confirm
#define SecFlCfg 31		// cons[SecFlCfg] = 1 to set masks for security floor configuration, 2 = multiple floor mask security, 3=secure hall call per floor per car from keyswitch 
#define hben 32			// cons[hben] = 1 to use enable button on car to hear handicap buzzer, 2 = beep when car call hit 4== beep on car call ONLY
#define exDHwL 33		// cons[exDHwL] = 1 extended door hold w/light and car call cancel door hold time      
#define medEm 34		// cons[medEm] = 1 Medical Emergency Service
#define rsbuffer 35		// cons[rsbuffer] = 1 Reduced stroke buffer, 0 = normal
#define naec 36			// cons[naec] = 1 Set for special show software
#define access_type 37 	// cons[access_type] = 0 No access, 1 = front top access, 2 front bottom, 4 = rear top, 8 = rear bottom
#define shortfl 38		// cons[shortfl] = 0 No short floor, # of bottom short floor
#define saf_test 39		// cons[saf_test] = 1 Shutdown if annual safety test flag not updated
#define ids 40			// cons[ids] = 1 Enable Lift-Net Protocol from IDS
#define LW_dis_sw 41 	// cons[LW_dis_sw] = 1 Load weigher disable switch
#define Elev_off 42		// cons[Elev_off]:	+1 = Elevator off switch in COP EOF, +2 = Elevator Switch in Hall HEOF, +4 = Elevator off reset EOR,
						//					+8 = Elevator Off Output ELOO,
#define Remote_CC 43	// cons[Remote_CC] = 1 Remote car call stations (car calls, DOB and DCB) :=2 use ED instead of INDC
#define GLBP_LED 44		// cons[GLBP_LED] = 1 Rudy rule: output status of gate or lock bypass to LED mounted exernally.
#define Low_Press 45	// cons[Low_Press] = 1 Hydro Pressure Switch input (EMH)
#define Low_Oil 46		// cons[Low_Oil] = 1 Low Oil Switch	(COL)
#define MtrBlower 47	// cons[MtrBlower] = 1 Motor blower output (uses GEN)
#define Sabbath 48		// cons[Sabbath] = 1 Sabbath car calls, 2=cc set from gio, 3=Sabbath Hall calls 4 = car calls  5 = ir to ovride sabbath
#define Car_Sw 49		// cons[Car_Sw] = 1 Car Switch
#define StagRear 50		// cons[StagRear] = 0, No staggered rear, 1 = staggered Rear floor flag
#define LbyUpReq 51		// cons[LbyUpReq] = 1 Lobby Up Hall Call Request (UC grtopf + 1), 1 in option but 5 in array = Lobby Up hall call but secf decides on standard hc assignment.
#define door_type 52	// cons[door_type] = 1 OVL/6970
#define housing	53		// cons[housing] = 1, NJ Housing Authority Job, 2 = NYCHA, 3 = Toronto housing
#define rearsel	54		// cons[rearsel] = 1, Rear door i/o on seperate board
#define EMPop	55		// cons[EMPop]: +1=Emergency Power Transfer, +2 = Hydro Emp Seq, +4 = Hydro S EPS, +8 Emp Status Indicators 
#define SFC_2004_IO	56		// cons[SFC_2004_IO] == 1, SFC test (v3.06+) and 2004 I/O change: SS to CWS, FFS to SS and CTS.
#define sel_type 57		// cons[sel_type]: 1=Rail Target Selector/Governor Encoder, 2=Encoded Tape, 3=Rail Target/CPU Gov Enc
#define pbdoor	58		// cons[pbdoor] = 1, Momentary Push Button door operation, 2=Constant pressure pbdoor. 
#define DZDoorEn 59		// cons[DZDoorEn] = 1, Door Zone Door Enable output on EML
#define dpp_upd	60		// cons[dpp_upd] = 1, Dpp update and offset control if using dz interrupt (1038 j26 to +DZ) (1036 j6 to Ri1)
#define FSX_rear 61		// cons[FSX_rear] = 1, Special operation for FSX as the rear door fire key switch and FS is front
#define RCM_HWDoor 62	// cons[RCM_HWDoor] = 1, Retiring Cam to Close Hoistway Door, or with auto door
#define vshort_tfl 63 	// cons[vshort_tfl] = 0 No very short floor, # of top very short floor (DTR used to switch door zone inputs)
#define Reset_Jack 64	// cons[Reset_Jack] = 1, home and reset jack once a day
#define Micro_Relev 65	// cons[Micro_Relev] = 1, micro releveling using UPML and DNML outputs.
#define Auto_Swing_DO 66  // cons[Auto_Swing_DO] = 1, automatic swing door w/manual gate
#define Park_NCU_ALB 67	// cons[Park_NCU_ALB] = 1, Inputs for APRK, ALBY, NCU 
#define Handicap_HPB 68	// cons[Handicap_HPB] = 1, Input for handicap car request
#define F1_CT 69		// cons[F1CT] = 1, FB, FL on 1040 Car Top
#define F1_ML_AL 70		// cons[F1_ML_AL] = 1, F1ML replaces EQL, F1AL replaces EML
#define shortflmid 71	// cons[shortflmid] = 1, Second short floor in middle of hoistway
#define EM_BRK 72		// cons[EM_BRK] = 1 Secondary Emergency Brake, 2=Sheave brake, 3=Sheave brake 2007, 
						// 4=Secondary Em Brake OR Sheave brake 2007 pick and drop each run, 5=Sheave Brake seperate BC and UTM.
						// 6=Electronic emergency brake
#define heavy_door 73	// cons[heavy_door] = 1 heavy door operation.
#define stag_auto_door 74	// cons[stag_auto_door] = 1 for staggered auto/swing door (cons[mand] == 7)
#define CBCar 75		// cons[CBCar] = 1, Valid code blue car set in array in cons file.
#define Car_Asgn_Fl 76	// cons[Car_Asgn_Fl] = 1, Car assigned to particular floor in cons floor array.
#define EPCarRun 77		// cons[EPCarRun] = 1, Mask defines particular cars to run on EP.
#define Second_Riser 78		// cons[Second_Riser] = 1, Dispatch call from Second Riser to multiple cars
#define VipSvc 79		// cons[VipSvc] = 1 Priority Service (vip) flag
#define IndSec 80		// cons[IndSec] = 1 Independent Security Service
#define hugs 81			// cons[hugs] 	== 1, Hugs Security Service in Group Operation HCS; 
						//				== 2, Hugs Security Service in Group Operation GCS;
						//				== 3, Hugs security Service in Car Operation
#define GOV_Reset 82	// cons[GOV_Reset] == 1, Electronic governor reset
#define cc_pb_sec 83	// cons[cc_pb_sec] == 1, car call push button security
#define loc_svc_tmr 84	// cons[loc_svc_tmr] == 1, Run service timer for non dispatcher car
#define Emp_Recover 85	// cons[Emp_Recover] == 1, Traction with battery recovery, 2 = single phase ups
#define Cycle_Run 86	// cons[Cycle_Run] == 1, Cycle car after sitting for cycle run hours (adjustable timer)
#define HCP_Fuse 87		// cons[HCP_Fuse] == 1, Seperate hall call fuse split from fire service hall power
#define Smoke_2004 88	// cons[Smoke_2004] == 1, for HWS2 Input, previously cons[Dual_Ser_Riser].
#define PWL_Brake 89	// cons[PWL_Brake] == 1, Manual Power Loss Brake, 2=MBC control only
#define INS_EN_SFC 90	// cons[INS_EN_SFC] == 1, Inspection switch enable and read SFC input
#define FS2_SW 91		// cons[FS2_SW] == 1, Reverse FS2 switch logic
#define Voltage_Sensor 92	// Cons[Voltage_Sensor] == 1, Analog voltage sensor to detect phase loss and low voltage (3-phase + door)
#define Galileo 93		// cons[Galileo] == 1, Enable control function of Galileo
#define EP_Profile 94	// cons[EP_Profile] == 1, Use Emergency Power Speed profile parameters on EP.
#define UPS_Type 95		// cons[UPS_Type], 0 for APC, 1 for Eaton (used for serial protocol)
#define RGB_CC 96		// cons[RGB_CC], 1 = RBG Car call boards
#define aux_RGB_CC 97	// cons[aux_RGB_CC], 1 = Aux RGB car call station
#define FSautoRST 98	// cons[FSautoRST], 1 = FS Auto reset operation
#define Aux_Brake 99	// cons[Aux_Brake], 1 = Aux Electronic Brake follows normal electronic brake 
#define SAB_Fl 100			// cons[SAB_Fl] = 1, use floors from cons file table (if cons[Sabbath] == 1) use car call, (if cons[Sabbath] == 3) use hall calls
#define XA_Mask 101		// Cross-Assignment Mask for which group floors are assigned.  1=GAL, 2=Other, 3=both
#define Alt_Ascii_pi 102 // enable alternate ascii pi's
#define Xref_PI_Pos 103		// Cross Reference PI (Use a different number for the PI position at the floor)
#define Dual_Ser_Riser 104	// cons[Dual_Ser_Riser] == 1, Dual Serial Risers
#define Blind_Floor 105 // cons[Blind_Floor] == Floor, floor above the blind shaft to display blind shaft character on digital PI indicator.
#define Blind_Floor_2 106 // cons[Blind_Floor_2] == Floor, floor below the blind shaft to display blind shaft character on digital PI indicator.
#define SecFlCfg_2 107		// cons[SecFlCfg_2] = 1 to set masks for security floor configuration, cons[SecFlCfg] must be set to 2 
#define SecFlCfg_3 108		// cons[SecFlCfg_3] = 1 to set masks for security floor configuration, cons[SecFlCfg] must be set to 2 
#define SecFlCfg_4 109		// cons[SecFlCfg_4] = 1 to set masks for security floor configuration, cons[SecFlCfg] must be set to 2 
#define CB_VIP_msk 110		// cons[CB_VIP_msk] = 1 use floor mask for CB or VIP valid floors
#define FI_EP_Ext 111		// cons[FI_EP_Ext] = 1 when 24 Volt Hall calls used	or for external Fire and Emp i/o	
#define Prison 112			//cons[Prison] = 1. Special service for REMOTE COP as well as emergency recall
#define Super_Sabbath 113	// cons[Super_Sabbath] will enable the ouputs for SABUZ and SABEE for special Sabbath operation
#define incrs2 114			// cons[incrs2] Enable Second IR Set (3rd riser) front groups only
#define exDHwLatFL 115		// cons[exDHwLatFL] = 1 extended door hold w/light and car call cancel door hold time for one floor only (fvar) 
#define distress 116		// cons[distress] = 1 enables osrL light output osrB buzzer output and osrA acknowledge input on external IO baord.
#define Australia 117		// cons[Australia] = 1 enables special code and i/o's for Australia
#define TUG 118				// cons[TUG] = 1 enables I/O interface and operation for TUG Hospital Robots
#define Ser_IGEP 119		// cons[Ser_IGEP] = 1 Serial Intergroup Emergency Power
#define dflt_MOVFR 120		// cons[dflt_MOVFR] = 1 EE to TOC with CAN MOVFR
#define MR_FBZ 121			// cons[MR_FBZ] = 1, Fire buzzer in the machine room.
#define MR_INE 122			// cons[MR_INE] = 1,2,3 Machine Room inspection enable input used (for controllers with added switch not on 1064)
#define EM_BKS 123			// cons[EM_BKS] = 1,2,3 Seperate brake input (each value for a different location on Main I/O board) 
							//     Not needed when cons[EM_BRK] equals 2 or 3. When cons[EM_BRK] = 5, cons[EM_BKS] must be non zero to use BKS input on board 27
#define unused124 124
#define unused125 125
#define unused126 126
#define unused127 127
#define unused128 128
#define unused129 129
#define unused130 130
#define CB_SR 131			// cons[CB_SR] = 1 for code blue second riser
#define EPSF 132			// cons[EPSF] = 1 for Emergency Power Split Feeder





//*******************
// Field Vairables
//*******************

// Field adjustable variables
unsigned char telnmb[20];
#define nmbfvar 600				// changed from 360 to 420 6/7/10
uint16 fvars[nmbfvar];
#define fvydel 0        		// y delta time in 1/10 sec
#define fvfltt 1        		// fault time in 1/10 sec
#define fvrst 2         		// reset time in 1/10 sec
#define fvdbl 3         		// double stroke on lanters 0 = no 1 = yes
#define fvlnton 4       		// lantern on time for double stroking in 1/10sec
#define fvlntof 5       		// lanten off time for double stroking in 1/10 secs
#define fvhbept 6       		// handicap floor passing beep time in 1/10 sec
#define fvdpt 7         		// door protection time in 1/10 sec
#define fvndt 8         		// nudge time in 1/10 sec
#define fvpred 9        		// preoping delay time in 1/10 sec
#define fvccdt 10       		// car call door time in 1/10 sec
#define fvhcdt 11       		// hall call door time in 1/10 sec
#define fvldt 12        		// lobby door time in 1/10 sec
#define fvexdt 13       		// extra door time in 1/10 sec
#define fvnit 14        		// non interferance time in 1/10 sec
#define fvlob 15        		// lobby floor
#define fvfs1f 16       		// fire service phase 1 main eggress floor
#define fvfs1af 17      		// fire service phase 1 alternate eggress floor
#define fvstall 18      		// stall time in tenth of a second
#define fvsst 19        		// soft stop time in 1/10 sec
#define fvgrt 20        		// generator run time in 1/10 sec
#define fvbrkpickdly 21    		// break delay on start in 1/10 sec
#define fvbrkdropdly 22        	// break delay on stop in 1/10 sec
#define fvjrk 23        		// acceleration jerk1 rate in FPM per second squared
#define fvacc 24        		// acceleration rate in FPM per second
#define fvdjrk 25       		// deceleration jerk rate in FPM per second squared
#define fvdec 26        		// deceleration rate in FPM per second
#define fvm7dst 27      		// distance from the floor to enter mode seven
#define fvlvs 28        		// leveling speed in tenths of a fpm
#define fvrlvs 29       		// relevel speed in tenths of a fpm
#define fvins 30        		// inspection speed in fpm
#define fvyear 31       		// year
#define fvmon 32        		// month
#define fvday 33        		// day
#define fvhour 34       		// hour
#define fvmin 35        		// minute
#define fvjrk3 36       		// acceleration jerk3 rate in FPM per second squared
#define fveemem 37       		// EE memory Size 0 = 32K, 1 = 8K (previously - diagnostic led's 0 to disable 1 to enable)
#define fvspt_year 38   		// service protection time year
#define fvspt_mon 39    		// service protection time month
#define fvspt_day 40    		// service protection time day
#define fvpat_del 41    		// patern delay
#define fvfweak 42				// Field Weaken velocity
#define fvencppr 43				// Encoder PPR
#define fvencrpm 44				// Encoder RPM
#define fvbaud 45				// User interface baud rate: 0=2400,1=4800,2=9600,3=19200
#define fvpark 46				// Parking 0=disable, 1-4 number cars to park
#define fvepfl 47				// Emergency Power Return floor
#define fvepcars 48				// Number of Cars to run on Emergency Power
#define fvretcar 49				// First Return Car (the rest are done sequentially in a loop)
#define fvselcar 50				// First Car Selected (the rest are done sequentially in a loop)
#define fvrettim 51				// Return Car time-out Time
#define fvdobndg 52				// DOB opens door on nudging if set
#define fvemdisp 53				// Emergency Dispatch Enable
#define fvlbyreq 54				// Number Cars Requested at lobby
#define fvncu 55				// Next Up Selection 0=OFF, 1=NCU DO, 2=NCU DC , 4=NCU DO on up peak, 
#define fvcbcar 56				// Code Blue car select
#define fvircar 57				// IR Car Select
#define fvbkliftsw 58			// Brake Lift Switch, 0=disable, 1=enable, 2=set gripper on fault
#define fvlwa 59				// Load Weighing anti-nuisance count
#define fvfiresw 60				// Fire Switch location: 0 = front, 1=main rear, 2=alt rear, 3=main/alt rear
#define fvetamin 61				// ETA min time
#define fvetacocc 62			// ETA for coincident car call 
#define fvvidc 62				// dummy for video car position index
#define fvvidc1 63				// Video position for car 1
#define fvvidc2 64				// Video position for car 2
#define fvvidc3 65				// Video position for car 3
#define fvvidc4 66				// Video position for car 4
#define fvvidc5 67				// Video position for car 5
#define fvvidc6 68				// Video position for car 6
#define fvrunct 69				// Run count with no passengers to cancel car calls
#define fvindsec 70				// Independent overrides security if set
#define fvbksrel 71				// Brake pick delay time on relevel
#define fvbkcrel 72				// Brake cool on relevel 0 = std brake cool, 1 = brake cool immediately (produce partial brake lift)
#define fvuptrigtim 73			// Up peak trigger time
#define fvuptrigcnt 74			// Up Peak trigger count
#define fvupcccnt 75			// Up Peak car call count
#define fvupdurtim 76			// Up Peak Duration time
#define fvdptrigtim 77			// Down Peak trigger time
#define fvdptrigcnt 78			// Down Peak trigger count
#define fvdpdurtim 79 			// Down Peak Duration time
#define fvparkdly 80			// Parking time delay
#define fvxasgn 81				// Hall call cross assignment, 0 = 0FF, 1 = ON
#define fvxeta 82				// Hall Call cross assignment ETA
#define fvmedfl 83				// Medical Emergency 
#define fvmedloc 84				// Medical Emergency Hall switch door location 0 = front, 1 = rear
#define fvfmrsen 85				// Fire service Motor room sensor return floor: 0=main 1 = alt 
#define fvfhwsen 86				// Fire service hoistway sensor return floor: 0=main 1 = alt 
#define fvfire_rst 87			// Fire recall reset: 0 = reset after ph1 sequence, 1 = reset immediately, +2 = FS only reset from OFF
#define fvacclim 88				// Accel and decel limit at final stop
#define fvpatrel 89				// Pattern delay during relevel
#define fvdon 90				// Delay start until drive on
#define fvoptodly 91			// Brake Opto trigger delay - - Previously Dynamic Brake Temperature Trip point degrees Fahrenheit
#define fvbls 92				// Invert logic of brake lift switch
#define fviser 93				// Invert logic of in-serice light output or in-use light or out of service alarm
#define fvcmaster 94    		// Ability to change a car other than 1 or 2 to become the master
#define fvtovideo 95    		// Time-out video display
#define fvdcinsp 96				// Close doors while trying to run on inspection
#define fvparkfl1 97			// Parking floor 1
#define fvparkfl2 98			// Parking floor 2
#define fvparkfl3 99			// Parking floor 3
#define fvparkfl4 100			// Parking floor 4
#define fvparkfl5 101			// Parking floor 5
#define fvparkwidth 102			// Parking width
#define fvbalance 103			// Percent of load to balance the counterweights
#define fvtorque 104			// Torque amount variable
#define fvloadbp 105 			// Load bypass percent
#define fvloadan 106			// Load antinuisance percent
#define fvloaddis 107 			// Load dispatch percent
#define fvloadovl 108			// Load overload percent
#define fvirctl 109				// IR control flag bit0: 1 = go on ir when any ir call active.
								//                 bit1: 1 = finish car call then answer IR call
								//                 bit2: 1 = finish car call before going off off IR call (bit 0 must also be set)
#define fvbkpick 110			// Brake pick voltage
#define fvbkpktm 111			// Brake pick duration time
#define fvbkhold 112			// Brake hold voltage
#define fvbkrelv 113			// Brake Relevel Voltage
#define fvbkaclv 114			// Brake Ac line to line voltage
#define fvbkres  115			// Brake resistance
#define fvattbz  116  			// Attendant Buzzer delay time 
#define fvfsx 	 117			// Hall Fire Aux Switch 0 = no sw, 1=switch used
#define fvfsofl	 118			// Operation of hall fire light 0 = fire 1&2, 1 = phase 1 in effect, 2 = flash.
#define fvrmcc	 119			// COP/Remote CC Select 0=both,1=Seperate,+2=COP->Remote,+4=Remote->COP Ack Light
#define fvdrdly	 120			// Door open or close delay time 
#define fvsecrec 121			// Security recall option: 1=recall to lobby, +2 = cycle door at lobby, +4 rear door, +8=Always Recall
#define fvdobsec 122			// DOB overrides Security when 1.
#define fvdoorbz 123			// Manual door Buzzer delay time
#define fvsecfl  124			// Security Floor
#define fvrcpkdly 125   		 // Retiring Cam pick delay timer
#define fvshortdt 126			// Short door time from a reopen signal
#define fvircar2  127			// 2nd IR car select 
#define fvstplby 128			// Stop at lobby: 1=going up, 2=down, 3=both, 4=Onward HC too 8 = Return to lobby after hall call
#define fvclf 	 129			// Invert Cab light Fan output
#define fvtpl	 130			// Invert Temperature Low switch (tpl)
#define fvlps	 131			// Invert Low Pressure Switch
#define fvlos	 132			// Invert Low Oil Switch
#define fvnudowc 133			// Nudging with no onward call
#define fvfireop 134			// Fire option flag +1=disable blink on FS Key,+2=Turn Buzzer off at recall floor, 
#define fvattcc  135			// Attendant car call flag, 1= set car call when hall call set.
#define fvcbtim  136			// Code blue door open time
#define fvcbind	 137			// Request Ind car for code blue
#define fvcblight 138			// Code blue light control
#define fvhsvdccc 139			// Hospital Service door close on car call
#define fvgriprst 140			// Gripper reset timer
#define fvinddccc 141			// Independent door close on car call
#define fvtorqoff 142			// Torque offset (compensate for no compensating chains).
#define fvspbgrip 143  			// Gripper test from safety processor board speed.
#define fvsapb 144				// Single automatic pushbutton control 1=enable 2=disable, 4= allows one car call door open
#define fvdonodol 145			// Door Open when DOL signal not active
#define fvunused146	146			// Previously: fvdisglt - Disable Gate and Lock Test for New York City
#define fvrlvst  147    		// Relevel Start speed in tenths of a fpm
#define fvemdec  148			// Emergency Deceleration Rate
#define fvdcbdt  149 			// Disable dcb from shortening door time
#define fvrtl 150				// Return to lobby option, +1 = cycle door, +2 = cancel car calls,+4 = cycle door on reversal
#define fvvidc7 151				// Video position for car 7
#define fvvidc8 152				// Video position for car 8
#define fvparktype 153			// Parking type 0 = busy floor park, 1 = divide hoistway, 2 = fixed park
#define fvparkfl6 154			// Parking floor 6
#define fvparkfl7 155			// Parking floor 7
#define fvno_simul_do 156 		// Non-Simultaneous Door operation = 1 (front first), 2 = rear first.
#define fvpredo 157				// Pre-open doors = 1, 0 = no preopen, +2 = no predo shortfl.
#define fvovrspd 158			// Over speed precent
#define fvppupd 159				// Position pulse count update
#define fvppdly 160				// Position Pulse delay error in 1/seconds (enc vel/fvppdly = pulses)
#define fvgripbz 161			// Gripper buzzer
#define fvrlvtim 162			// Relevel delay timer
#define fvfireop2 163			// Fire Option 2: +1=ph2 recall open door first, +2 blink disable ph2
#define fvclgate 164			// Close gate on swing door operation when no preference
#define fvlevfltcnt 165			// Leveling fault count
#define fvtorqdn 166			// Torque amount in the down direction (if non zero then fvtorque is for the up direction)
#define fvtrqrmptim 167			// Ramp torque time during pattern delay
#define fveeto 168				// Electric Eye time-out
#define fvotshc 169 			// Cars out of service No hall call cancel
#define fvndgctl 170			// Nudging Ctl 1=Disable Nudging Output, +2=reopen door on ee or se, +4 = buz blocked door 
#define fvfs1dto 171 			// Fire phase1 door time-out (ind and att).
#define fvnohcreop 172			// No hall call button door reopen with onward call
#define fvdrvrst 173			// Drive ready reset count
#define fvrtldt 174				// Return to Lobby Dwell time
#define fvncul 175				// Next Up Lobby Lantern control 1=Turn off hall lantern, 2=turn off cab lantern 
#define fvncupref 176			// Next Up Preference,0=keep pref until door closed, 1 = after ncu time
#define fvsrctl 177				// Second Riser Control, 1 = SR Cars Std HC no assign, 2 = Or SR with std riser
#define fvsrlant 178			// Second Riser Lantern Control, 1=Cab Lant on SR
#define fvatt_eta_pref 179		// Attendant ETA preference time

#define fvhbz_nvfl 180			// Handicap buzzer disabled at non valid floor
#define fvviptim 181 			// Vip door time
#define fvvipop 182				// Vip Operation Flags +1=Cancel HC if no cars, +2=Cancel car calls 1st
#define fvnmbvipcars 183 		// Number of vip cars
#define fvepopled 184			// Emergency Power Op LED function: 0 = Operational, 1=normal pwr, 2=emPower, 3=ep recall
#define fveppkled 185			// Emergency Power Park LED Function: 0=Parked, 1= Recalled
#define fveloff 186				// Elevator Off Options: +1=Recall, +2=Keep Door Open, +4=Turn off CLF
#define fvdrvbaud 187			// Drive baud rate: 0=19200, 1=38400, 2=57600, 3=115200, 4=9600
#define fvdrvupd 188			// Drive update rate: 0 = 10 msec, 1 = 15 msec, 2 = 20 msec 
#define fvaltlob 189			// Alternate Lobby Floor
#define fvaltpark 190			// Alternate Parking Floor
#define fvlrqctl 191			// Lobby Request Control 1=NCU
#define fvhandcap 192			// Handicap Car Capacity
#define fvfrtdcto 193			// Freight door close time-out
#define fvhandwait 194			// Handicap Car wait time
#define fvshortdis 195			// Short floor distance in inches
#define fvrcmctl 196			// +1=Hold retiring cam if door pilot at the floor, +2=advance auto door
#define fvrecallfs1a 197 		// Recall from fire alternate floor 
#define fvhwstall 198			// Auto learn hoistway stall time
#define fvpperror 199 			// Position Pulse Count Error
#define fvattbzoff 200			// Attendant buzzer timer min=0 max=30
#define fvattbzon 201			// Attendant buzzer timer min=0 max=30
#define fvbkpkrate 202			// Brake pick voltage rate time
#define fvbkrvrate 203			// Brake relevel voltage rate time
#define fvbkpkst 204			// Brake Pick Start Voltage
#define fvbkrvst 205			// Brake relevel Start Voltage
#define fvshort_dsdt 206  		// Short floor down slowdown time
#define fvshortm_dsdt 207 		// Mid Short floor down slowdown time
#define fvshort_usdt 208  		// Short floor up slowdown time
#define fvshortm_usdt 209 		// Mid Short floor up slowdown time
#define fvheoffl 210			// Hall Switch Elevator Off return floor
#define fvsvcmsg1 211			// Service message 1 display
#define fvsvcmsg2 212			// Service message 2 display
#define fvgovgrip 213			// Governor Gripper Trip Control, 0=gripper trip on GOV, 1=no gripper trip on GOV
#define fvjrk_sf 214    		// acceleration jerk1 rate for short floor in FPM per second squared
#define fvacc_sf 215    		// acceleration rate for short floor in FPM per second
#define fvjrk3_sf 216   		// acceleration jerk3 rate for short floor in FPM per second squared
#define fvdjrk_sf 217   		// deceleration jerk rate for short floor in FPM per second squared
#define fvdec_sf 218    		// deceleration rate for short floor in FPM per second
#define fvm7dst_sf 219  		// distance from the short floor to enter mode seven
#define fvshrtflctl 220			// Short floor control 1=very short floor run, 2=short fl sd between fl, 4=short mid fl sd between fl
#define fvsecrec2 221			// Security Recall Control 2: 0=out of group on first recall, 1=OoG all recalls, 2=no out of group recalls
#define fveprcldly 222			// Emergency Power Recall Delay time.
#define fvgccsect 223			// Group car call security override time
#define fvebkdropdly 224		// Emergency brake drop delay
#define fvebkpktim 225			// Emergency brake pick time
#define fvhcbonbright 226 		// Hall Call output on brightness for led (higher number is brighter)
#define fvhcboffbright 227		// Hall Call output off brightness for led (higher number is brighter)
#define fvacctopfl 228			// Access top floor
#define fvaccbotfl 229			// Access bottom floor
#define fvppstop 230			// Stop on position pulse
#define fvsabtim 231			// Sabbath Svc restart time
#define fvpwrdotim 232			// Power Door open relay on Time
#define fvfltdpy   233	 		//Display fault automatically on LCD when fault occurs
#define fvpassword 234   		// Password for adjusting variables.
#define fvpwtime 235			// Password time-out time
#define fvbehindcc 236			// Behind car call cancel
#define fvdo_adv_de 237			// Door open advance door enable non-simultaneous doors
#define fvgsvcpark 238			// Group service number of parking cars
#define fvpresetupd 239			// Binary preset update when position does not match
#define fvsfnohsv 240			// Short floor hsf with no hsv high speed valve
#define fvuppkctl 241			// Up peak control: +1=Heavy Up
#define fvuppkpool 242			// Up peak pool: Cars taken out
#define fvdnpkctl 243			// Down peak control: +1=Heavy Down
#define fvdnpkpool 244			// Down peak pool: Cars taken out
#define fvxacars 245			// Cross Assignment Cars from old group
#define fvmodbus 246			// Modbus protocol, 0-5=N1,N2,E1,E1,O1,O2 (Always 8 data bits, parity, stop bits)
#define fvaltrclfs 247			// Fire alternate recall after fs turned off
#define fvinsdecstp 248 		// Inspection Decel Stop Rate
#define fveprdir 249			// Emergency Power Recovery Direction
#define fvbkdrop 250			// Brake Drop Voltage
#define fvbkdroprate 251		// Brake Voltage Drop Rate
#define fvbkdroplev 252			// Brake Drop timing during Leveling flag
#define fvrecvel 253			// Recovery Velocity
#define fvemdeclev 254			// Emergency Deceleration to Leveling Rate
#define fveprecvel 255			// Emergency Power Recovery Velocity
#define fvcycrun 256			// Run Cycle time in hours
#define fvhcbuponred 257		// Hall Call Up On red intensity
#define fvhcbupoffred 258  		// Hall Call UpOff red intensity
#define fvhcbupongreen 259  	// Hall Call Up On green intensity
#define fvhcbupoffgreen 260		// Hall Call UpOff green intensity
#define fvhcbuponblue 261		// Hall Call UP On blue intensity
#define fvhcbupoffblue 262 		// Hall Call Up Off blue intensity
#define fvopenlctl 263			// Door Open Light control in CCS board
#define fvhcbuponcolor 264  	// Hall Call Button Up On Color
#define fvhcbupoffcolor 265  	// Hall Call Button Up Off Color
#define fvhcbseccolor 266  		// Hall Call Button Security Color
#define fvhcbseclt 267 			// Hall Call Button Security Light 1 = invert security, +2=flash security, +4 Sec Master Enable
#define fvhcbsecbright 268		// Hall Call Security brightness
#define fvhcbsecred 269 		// Hall Call Security red intensity
#define fvhcbsecgreen 270		// Hall Call Security green intensity
#define fvhcbsecblue 271 		// Hall Call Security blue intensity
#define fvfhws2en 272 			// Fire service hoistway sensor 2 return floor: 0=main 1 = alt 
#define fvdrvmult 273			// Drive Speed Multiplier
#define fvadvpretrq 274			// Advanced pre-torque
#define fvcconcolor 275  		// Car Call Button On Color
#define fvccoffcolor 276  		// Car Call Button Off Color
#define fvcconbright 277 		// Car Call output on brightness for led	(higher number is brighter)
#define fvccoffbright 278		// Car Call output off brightness for led	(higher number is brighter)
#define fvcconred 279			// Car Call On red intensity
#define fvccoffred 280   		// Car Call Off red intensity
#define fvccongreen 281  		// Car Call On green intensity
#define fvccoffgreen 282		// Car Call Off green intensity
#define fvcconblue 283			// Car Call On blue intensity
#define fvccoffblue 284 		// Car Call Off blue intensity
#define fvccltctl 285 			// Car Call Button Light Control: 1 = flash security, 2=Alternate Att Flash Sequence 
#define fvccseccolor 286  		// Car Call Button Security Color
#define fvccsecbright 287		// Car Call Security brightness
#define fvccsecred 288 			// Car Call Security red intensity
#define fvccsecgreen 289		// Car Call Security green intensity
#define fvccsecblue 290 		// Car Call Security blue intensity
#define fvsabben 291			// Sabbath Enable control variable,  1=allow momentary ir to override sabbath, 2 = Lobby Dwell timer, 4= Lobby off
#define fvlowlinevolt 292		// Low Line Voltage (RMS value)
#define fvlowdoorvolt 293		// Low Door Voltage (RMS value)
#define fvts_ep 294				// top speed for Emergency Power 
#define fvjrk_ep 295    		// acceleration jerk1 rate for emergency power in FPM per second squared
#define fvacc_ep 296    		// acceleration rate for emergency power in FPM per second
#define fvjrk3_ep 297   		// acceleration jerk3 rate for emergency power in FPM per second squared
#define fvdjrk_ep 298   		// deceleration jerk rate for emergency power in FPM per second squared
#define fvdec_ep 299    		// deceleration rate for emergency power in FPM per second
#define fvm7dst_ep 300  		// distance from the floor to enter mode seven for emergency power 
#define fvtopspeed 301			// Car Top Speed
#define fvinsiser 302			// Inspection Velocity from ISER output
#define fvrcvrtim 303			// Emergency Power Recover to floor time
#define fvflemp 304				// Fire Light control during EP
#define fvepmanselen 305		// Emergency Power Manual Select Enable
#define fvflots 306				// Fire Light control with car out of service (low pressure, eaq, stall)
#define fvsadt 307				// Sabbath Door Dwell Time
#define fvsabuzt 308			// Sabbath Door Buzzer timer prior to doors closing
#define fvbatcap 309			// Low Battery Capacity Level
#define fvsabbdis 310			// Sabbath disable control variable, +1=PI, +2=Lanterns, +4=arrow
#define fveeshortdt 311			// Electric Eye cancel door time
#define fvepRclflDO 312			// Emergency power car at recall floor with door open, 0=override immediately, 1=override after time-delay
#define fvepNRclflDO 313 		// Emergency power car not at recall floor with door open, 0=override immediately, 1= override after time-delay
#define fvAsgParkFlDO 314 		// Assign parking floor to car with door open							    
#define fvhlandelay 315			// Hall lanterns delay
#define fvsabben2 316			// Sabbath Enable control 2 variable,  1=Lobby On, 2 = Cab Lanterns as Direction Lanterns
#define fvclantctl 317			// Cab Lantern Control 1 = on door open, 2 = on dpm limit
#define fvmaxdoorhld 318		// Max Door Hold time from ED input 0 = disabled
#define fvaccdoorcl 319			// Access run door close
#define fvccattupcolor 320  	// Car Call Button Attendant Up Color
#define fvccattupbright 321		// Car Call Attendant Up brightness
#define fvccattupred 322 		// Car Call Attendant Up red intensity
#define fvccattupgreen 323		// Car Call Attendant Up green intensity
#define fvccattupblue 324 		// Car Call Attendant Up blue intensity
#define fvccattdncolor 325  	// Car Call Button Attendant Dn Color
#define fvccattdnbright 326		// Car Call Attendant Dn brightness
#define fvccattdnred 327 		// Car Call Attendant Dn red intensity
#define fvccattdngreen 328		// Car Call Attendant Dn green intensity
#define fvccattdnblue 329 		// Car Call Attendant Dn blue intensity
#define fvcopfirecolor 330  	// Fire light Color
#define fvcopfirebright 331		// Fire light brightness
#define fvcopfirered 332 		// Fire light red intensity
#define fvcopfiregreen 333		// Fire light green intensity
#define fvcopfireblue 334 		// Fire light blue intensity
#define fvcopmedcolor 335  		// Medical light Color
#define fvcopmedbright 336		// Medical light brightness
#define fvcopmedred 337 		// Medical light red intensity
#define fvcopmedgreen 338		// Medical light green intensity
#define fvcopmedblue 339 		// Medical light blue intensity
#define fvcopemcolor 340  		// Emergency light Color
#define fvcopembright 341		// Emergency light brightness
#define fvcopemred 342 			// Emergency light red intensity
#define fvcopemgreen 343		// Emergency light green intensity
#define fvcopemblue 344 		// Emergency light blue intensity
#define fvcopotscolor 345  		// OTS light Color
#define fvcopotsbright 346		// OTS light brightness
#define fvcopotsred 347 		// OTS light red intensity
#define fvcopotsgreen 348		// OTS light green intensity
#define fvcopotsblue 349 		// OTS light blue intensity
#define fvbklton 350			// Backlight Output lights Bit0: Fire, Bit1: Medical, Bit2: Emergency, Bit3: OTS, Bit4: Att Up/Dn Light, Bit5: Non-CC
#define fvcansynccnt 351		// Can Sync Count in 250 msec increments
#define fvhcbdnoncolor 352		// Hall Call Dn On color
#define fvhcbdnonbright 353		// Hall Call Dn On brightness
#define fvhcbdnonred 354		// Hall Call Dn On red intensity
#define fvhcbdnongreen 355  	// Hall Call Dn On green intensity
#define fvhcbdnonblue 356		// Hall Call Dn On blue intensity
#define fvhcbdnoffcolor 357		// Hall Call Dn Off color
#define fvhcbdnoffbright 358	// Hall Call Dn Off brightness
#define fvhcbdnoffred 359		// Hall Call Dn Off red intensity

#define fvhcbdnoffgreen 360  	// Hall Call Dn Off green intensity
#define fvhcbdnoffblue 361		// Hall Call Dn Off blue intensity
#define fvhcbcboncolor 362		// Hall Call CB On color
#define fvhcbcbonbright 363		// Hall Call CB On brightness
#define fvhcbcbonred 364		// Hall Call CB On red intensity
#define fvhcbcbongreen 365  	// Hall Call CB On green intensity
#define fvhcbcbonblue 366		// Hall Call CB On blue intensity
#define fvhcbviponcolor 367		// Hall Call Vip On color
#define fvhcbviponbright 368	// Hall Call Vip On brightness
#define fvhcbviponred 369		// Hall Call Vip On red intensity
#define fvhcbvipongreen 370  	// Hall Call Vip On green intensity
#define fvhcbviponblue 371		// Hall Call Vip On blue intensity
#define fvhcbiruponcolor 372	// Hall Call IR Up On color
#define fvhcbiruponbright 373	// Hall Call IR Up On brightness
#define fvhcbiruponred 374		// Hall Call IR Up On red intensity
#define fvhcbirupongreen 375  	// Hall Call IR Up On green intensity
#define fvhcbiruponblue 376		// Hall Call IR Up On blue intensity
#define fvhcbirdnoncolor 377	// Hall Call IR Dn On color
#define fvhcbirdnonbright 378	// Hall Call IR Dn On brightness
#define fvhcbirdnonred 379		// Hall Call IR Dn On red intensity
#define fvhcbirdnongreen 380  	// Hall Call IR Dn On green intensity
#define fvhcbirdnonblue 381		// Hall Call IR Dn On blue intensity
#define fvhcbirupoffcolor 382	// Hall Call IR Up Off color
#define fvhcbirupoffbright 383	// Hall Call IR Up Off brightness
#define fvhcbirupoffred 384		// Hall Call IR Up Off red intensity
#define fvhcbirupoffgreen 385  	// Hall Call IR Up Off green intensity
#define fvhcbirupoffblue 386	// Hall Call IR Up Off blue intensity
#define fvhcbirdnoffcolor 387	// Hall Call IR Dn Off color
#define fvhcbirdnoffbright 388	// Hall Call IR Dn Off brightness
#define fvhcbirdnoffred 389		// Hall Call IR Dn Off red intensity
#define fvhcbirdnoffgreen 390  	// Hall Call IR Dn Off green intensity
#define fvhcbirdnoffblue 391	// Hall Call IR Dn Off blue intensity
#define fvhcbuponbright 392 	// Hall Call output Up on brightness for led (higher number is brighter)
#define fvhcbupoffbright 393	// Hall Call output off brightness for led (higher number is brighter)
#define fvhcbcbloc 394			// Code Blue Location: 0=CB on CB, 1 = CB on HCB, 2 = CB on IR,
#define fvhcbviploc 395			// Vip Location 0 = vip on vip, 1 = Vip on HCB, 2 = Vip on IR
#define fvhcbirlt 396			// IR light color control: 0=IR Color, 1=HC Color until IR activated
#define fvhcbcboffcolor 397		// Hall Call CB Off color
#define fvhcbcboffbright 398 	// Hall Call CB Off brightness
#define fvhcbcboffred 399		// Hall Call CB Off red intensity
#define fvhcbcboffgreen 400  	// Hall Call CB Off green intensity
#define fvhcbcboffblue 401		// Hall Call CB Off blue intensity
#define fvhcbvipoffcolor 402 	// Hall Call Vip Off color
#define fvhcbvipoffbright 403	// Hall Call Vip Off brightness
#define fvhcbvipoffred 404		// Hall Call Vip Off red intensity
#define fvhcbvipoffgreen 405  	// Hall Call Vip Off green intensity
#define fvhcbvipoffblue 406		// Hall Call Vip Off blue intensity
#define fvviplant 407			// Vip lantern control: 1 = ring up and down at vip floor
#define fvgccovride 408			// Group Car Call Override Control: 1=Key Switch Direct
#define fvexcflt1 409			// Exclusion fault 1
#define fvexcflt2 410			// Exclusion fault 2 
#define fvexcflt3 411			// Exclusion fault 3
#define fvexcflt4 412			// Exclusion fault 4 
#define fvexcflt5 413			// Exclusion fault 5
#define fvexcflt6 414			// Exclusion fault 6 
#define fvebkpick 415			// Emergency Brake Pick voltage
#define fvebkhold 416			// Emergency Brake hold voltage
#define fvebkpkrate 417			// Emergency Brake Pick Rate
#define fvebkdroprate 418		// Emergency Brake Drop Rate
#define fvebkaclv 419			// Emergency Brake Ac line to line voltage
#define fvebkoptodly 420 		// Emergency Brake Opto trigger delay 
#define fvcanbaud 421			// Can Baud Rate, 0=115.2K, 1=57.6K
#define fvarrivallant 422		// Arrival Lantern, 1 = activate lant/gong without onward call
#define fvcbsrcar 423 			// Code Blue second riser car select
#define fvcbovrir 424			// Code blue over IR car
#define fvircbpenalty 425		// IR Car Code Blue penalty time
#define fvinsec 426				// INSEC - in security Output invert
#define fvattmandir 427			// Attendant manual direction enable 1= in att ; 3 not in att.
#define fvencinterval 428 		// Encoder Debounce Interval
#define fvencsamples 429		// Encoder number of samples
#define fvhboncct 430       	// handicap buzzer on car call beep time in 1/10 sec
#define fvsrvups 431			// Service UPS mode
#define fvcomdiag 432			// Serial port comm diag
#define fvbaud2 433				// User port 2 Baud Rate
#define fvcputiming 434			// Cpu timing output control
#define fvsvcmsg3 435			// Service message 3 display
#define fvhcasgnsectype 436		// Hall Call assignment secure type
#define fvupsbaud 437			// UPS baud rate: 0=2400,1=4800,2=9600,3=19200
#define fvhcattbuz	438			// HC Acknowledge Attendant Buzzer - Buzz once(1s) every time a call comes in 0 = disable 1 =  enable
#define fvcbcar2 439			// Second Code Blue car select
#define fveloff2 440			// Elevator Off Options 2: +1= Keep doors Closed  (do not cylcle)	+2 = do not blink ELOO	
#define fvcbbuz 441				// Code blue Buzzer Control: 1 =  Turn on while in code blue recall 
#define fvcbovrind 442			// Code Blue Override Independent 1 = wait for timer to expire and then recall the car
#define fvcbanycar 443			// Code Blue Recall any car if CB car 1 and 2 are not available
#define fvheofovrind 444		// Hall Elevator off override independent 1 = wait for timer to expire and then recall the car
#define fvunused4 445			// Unused 4 Previously fvreopendoorfs2 Car door Reopen on open lock for NYC fire service	 
#define fvpwlbkon 446			// Power loss brake on time
#define fvpwlbkoff 447			// Power loss brake off time
#define fvattempcar 448		   	// Select and Prioratize the attendant car for running on emergency power service. It won't be recalled. It recovers from it was left at.
#define fvencdir  449			// Encoder direction for can encoder
#define fvemprecall	450			// Emergency cars finished Recalling Output enable
#define fvoser1	451				// Out of Service Light control +1 = not responding to calls; +2 = between floors for over a minute +4 = SS open 
#define fvexdtflr 452			// Extra door time Location - floor number. Follows fvexdt timer. It will operate for EDHL only
#define fvoser2	453				// Out of Service Light control + 1= Alarm
#define fvosernocall 454		// timer to control oser control option 0x01
#define fvoserbtwfl 455			// timer to control oser control option 0x02
#define fvoserssopen 456		// timer to control oser control option 0x04
#define fvfhws2loc 457 			// Fire service hoistway sensor location 0 =  same HW 1 = Seprate HW
#define fvrcdrdly 458			// Retiring cam drop fail safe delay
#define fvveldiff 459			// Velocity difference 
#define fvveldifffltdis	460		// Velocity difference fault disable
#define fvspbdirfltdis 461		// SPB direction fault disable
#define fvlimdirfltdis 462		// Limit direction fault disable
#define fvdirfltdis 463			// Encoder direction fault disable
#define fvuldldirfltdis 464		// UL/DL direction fault disable
#define fvrelevsttim 465		// Relevel Start Velocity Hold Time
#define fvmedreopen 466			// Med door open sequence for re-open: 0=Stop, 1=Constant pressure, 2=momentary to DOL
#define fvmedindovr 467			// Med Ind override: 0=Immediate, 1=After Delay, 2=No ovarride
#define fvhsaftercb 468			// Code Blue Bypass Disable 0 = from Auto to HS if EMS turns on; 1 = HS only after CB recall
#define fvextdoormsg 469		// Extended Door PI Message
#define fvretcar2 470			// First Return Car (the rest are done sequentially in a loop) for power feeder 2
#define fvselcar2 471			// First Car Selected (the rest are done sequentially in a loop) for power feeder 2
#define fvrcmfrght 472			// Retiring Cam for freight output enable (reboot required)	
#define fvlantprefdly 473		// Lantern preference change delay
#define fvslipveldiff 474		// Slip velocity difference fault trip value
#define fvdobovrdcb 475			// DOB overrides DCB on phase 2
#define fvdenfsv 476			// Denver Fire service ammendment to close the phase 1 doors after recall and reopen from a hall call
#define fvf1dwell 477			// Denver FS phase1 dwell time
#define fvhcsecctrl 478			// Hall call security control 0 = only std hall halls; 1 = std plus SR hall call ; 2 = only SR hall calls
#define fvslipveldiffdis 479  	// Slip velocity difference disable
#define fvlevflt 480			// Leveling fault trip. 0=drop everything, 1= set em brake or gripper
#define fvembksw 481			// Emergency Brake Switch Control 0 = don't start if brake switch does not pick, 1 = ignore brake switch on start

#define lastfvar 481			// set to the last variable number

 
int16 fvars_deci[nmbfvar] ={	// 0 if fvars has no decimal place 1 if it does
	1,		// Max=5.0 Y Delta Time
	1,		// Max=10.0 Fault Time
	1,		// Max=10.0 Reset Time
	0,		// Max=1, 1 = 2 Gongs Double Stoke
	1,		// Max=2.0 Lantern On Time
	1,		// Max=2.0 Latern Off Time
	1,		// Max=2.0 Floor Passing Chime Time
	1,		// Max=3200.0 Door Failure Time
	1,		// Max=3200.0 Nudging Time
	1,		// Max=3200.0 Preopenning Delay Time
	1,		// Max=60.0 Car Call Door Dwell Time
	1,		// Max=60.0 Hall Call Door Dwell Time
	1,		// Max=60.0 Lobby Call Door Dwell Time
	1,		// Max=120.0 Handicap Door Dwell Time
	1,		// Max=60.0 Non Interfance Timer
	0,		// Max=Top Floor Lobby Floor
	0,		// Max=Top Floor Fire Service Main Return
	0,		// Max=Top Floor Fire Service Alternate Return
	1,		// Max=3200.0 Stall Time
	1,		// Max=3.0 Soft Stop Time
	1,		// Max=3200.0 Generator Run Time
	1,		// Max=5.0 Brake Pick Delay Time
	1,		// Max=5.0 Brake Drop Delay Time
	0,		// Max=320 fpm/ss Soft Start Jerk Rate
	0,		// Max=225  fpm/s Acceleration
	0,		// Max=320 fpm/ss Decel Jerk
	0,		// Max=225  fpm/s Decel Rate
	1,		// Max=25.0 in. Floor Targ Dis
	1,		// Max=15.0 fpm Leveling Speed
	1,		// Max=15.0 fpm Relevel Speed
	0,		// Max=150 fpm Inspect Speed
	0,		// Max=2999 Year
	0,		// Max=12 Month
	0,		// Max=31 Day
	0,		// Max=23 Hour
	0,		// Max=59 Minute
	0,		// Max=320 fpm/ss Roll Over Jerk
	0,		// Max=1 EE memory Size 0 = 32K, 1 = 8K (previously - diagnostic led's 0 to disable 1 to enable)
	0,		// Max=2999 Annual Safty Test Year
	0,		// Max=12 Annual Safty Test Month
	0,		// Max=31 Annual Safty Test Day
	2,		// Max=3.00 sec Pattern Delay
	0,  	// Max=110% Field Weakening
    0,  	// Max=20000 Encoder PPR
	0,  	// Max=3000 Encoder RPM
	0,		// Max=3 for 19200 
	0,		// 0 = no parking, 1-4 number of cars to park
	0,		// Max=Top Floor Emergency Power Recall Floor
	0,		// Max=4 Number of Emergency Power Cars
	0,		// Max=4 Car to return first on Emergency Power
	0,		// Max=4 Car to select first to run auto on Emergency Power
	1,		// Max=600.0 EP Return Car Time-out
	0,		// Max=1 DOB opens door during nudging
	0,		// Max=1 Emergency Dispatch Enable
	0,		// Max=4 Number Cars Requested at lobby
	0,		// Next Up Selection 0=OFF, 1=NCU DO, 2=NCU DC, 4=NCU up peak
	0,		// Code blue car select
	0,		// IR car select
	0,		// Brake Lift Switch, 0=disable, 1=enable, 2=set gripper on fault
	0,		// Load Weighing anti-nuisance count
	0,		// Fire Switch location: 0 = front, 1=main rear, 2=alt rear, 3=main/alt rear 
	0,		// ETA min time
	0,		// ETA for coincident car call
	0,		// Video position for car 1
	0,		// Video position for car 2
	0,		// Video position for car 3
	0,		// Video position for car 4
	0,		// Video position for car 5
	0,		// Video position for car 6
	0,		// No passenger run count
	0,		// Independent overrides Security when set
	1,		// Brake pick delay time on relevel
	0,		// Brake cool on relevel 0 = std brake cool, 1 = brake cool immediately (produce partial brake lift)
	1,		// Up peak trigger time
	0,		// Up Peak trigger count
	0,		// Up Peak car call count
	1,		// Up Peak Duration time
	1,		// Down Peak trigger time
	0,		// Down Peak trigger count
	1,		// Down Peak Duration time
	1,		// Parking delay time
	0,		// Hall call cross assignment, 0 = 0FF, 1 = ON
	0,		// Hall Call cross assignment ETA
	0,		// Medical Emergency Floor
	0,		// Medical Emergency Switch location 0 = front, 1= rear
	0,		// Fire service Motor room sensor return floor: 0=main 1 = alt
	0,		// Fire service hoistway sensor return floor: 0=main 1 = alt 
	0,		// Phase 1 fire recall reset: 0 = after recall, 1=immediate, +2=FS only reset from OFF
	0,		// Accel and decel limit at final stop
	2,		// Max=3.00 sec Pattern Delay Relevel
	0,		// Delay start until drive on
	0,		// Brake Opto Trigger delay
	0,		// Invert logic of brake lift switch
	0,		// Invert in-service light output
	0,		// Ability to change a car other than 1 or 2 to become the master
	1,		// Time-out video display
	0,		// Close doors while trying to run on inspection
	0,		// Parking floor 1
	0,		// Parking floor 2
	0,		// Parking floor 3
	0,		// Parking floor 4
	0,		// Parking floor 5
	0,		// Parking width
	1,		// Balanced load percent
	2,		// Drive starting Torque Multiplier
	0,		// Load bypass percent
	0,		// Load antinuisance percent
	0,		// Load dispatch percent
	0,		// Load overload percent
	0,		// IR control flag
	0,		// Brake pick voltage	 110
	1,		// Brake pick duration time
	0,		// Brake hold voltage
	0,		// Brake Relevel Voltage
	0,		// Brake Ac line to line voltage
	1,		// Brake resistance
	1,		// Attendant buzzer delay time
	0,		// Hall Fire Aux. Switch
	0,		// Fire service override or phase 1 in effect
	0,		// COP/Remote CC Select 0=both,1=Seperate,+2=COP->Remote,+4=Remote->COP Ack Light
	1,		// Door open or close delay time
	0,		// Security Recall: 1=recall to lobby, +2=cycle front door, +4=cycle rear door
	0,		// DOB overrides Security when 1.
	1,		// Manual Door Buzzer Delay
	0,		// Security Floor
	1,		// Retiring cam pick delay timer
	1,		// Short door time
	0,		// Second IR Car Select
	0,		// Stop At Lobby
	0,		// Invert Cab Light Fan output
	0,		// Invert Temperature Low switch (tpl)
	0,		// Invert Low Pressure Switch
	0,		// Invert Low Oil Switch
	0,		// Nudging with no onward call
	0,		// Fire option flags
	0,		// Attendant Car Call
	1,		// Code blue door open time
	0,		// Request Ind car for code blue
	0,		// Flash light on code blue
	0,		// Hospital Service door close on car call
	1,		// Gripper reset time
	0,		// Independent door close on car call
	2,		// Torque offset
	0,		// Gripper test from safety processor board speed and overspeed.
	0,		// Single automatic pushbutton control
	0,		// Door Open when DOL signal not active
	0,		// Previously: fvdisglt - Disable Gate and Lock Test for New York City
	1,		// Relevel Start Speed
	0,		// Emergency Decel Rate	 fpm/s
	0,		// Disable DCB cancel door time
	0,		// Return to Lobby option
	0,		// Video position for car 7
	0,		// Video position for car 8
	0,		// Parking type 0 = busy floor park, 1 = divide hoistway, 2 = fixed park
	0,		// Parking floor 6
	0,		// Parking floor 7
	0,		// Non-Simultaneous Doors = 1 (front first), 2 = rear first
	0,		// Pre-open doors = 1, 0 = no preopen, +2 = no predo shortfl.
	0,		// Over speed precent
	0,		// Position pulse count update, +1 = enable, +2 use dz int
	0,		// Position pulse delay error
	0,		// Gripper buzzer, 1 = enable	 
	1,		// Relevel delay time
	0,		// Fire OPtion 2, +1= ph2 recall open door first,, +2 blink disable ph2
	0,		// Close gate on swing door with no preference
	0,		// Leveling fault count
	2,		// Torque amount for down direction
	2,		// Ramp torque time during pattern delay
	1,		// Electric Eye time-out Time
	0,		// Cars out of service hall call cancel, 1 = enable
	0,		// Nudging Ctl 1=Disable Nudging Output, +2=reopen door on ee or se, +4 = buz blocked door
	1,		// Fire phase1 door time-out (ind and att).
	0,		// No hall call button door reopen with onward call
	0,		// Drive ready reset count
	1,		// Return to Lobby Door Dwell Time
	0,		// Next Up Lobby Lantern control 1=Turn off hall lantern, 2=turn off cab lantern
	0,		// Next Up Preference Control 0=Keep until DCL, 1 = after ncu time
	0,		// Second Riser Control, 1 = SR Cars Std HC no assign, 2 = Or SR with std riser
	0,		// Second Riser Lantern Control, 1=Cab Lant on SR
	0,		// Attendant ETA preference time

	0,		// Handicap buzzer disabled at non valid floor	 
	1,		// Vip door open time
	0,		// Vip Operation Flags +1=Cancel HC if no cars, +2=Cancel car calls 1st
	0,		// Number of VIP cars
	0,		// Emergency Power Op LED function
	0,		// Emergency Power Park LED Function
	0,		// Elevator Off Options: +1=Recall, +2=Keep Door Open, +4=Turn off CLF
	0,		// Drive baud rate: 0=19200, 1=38400, 2=57600, 3=115200, 4=9600
	0,		// Drive update rate: 0 = 10 msec, 1 = 15 msec, 2 = 20 msec 
	0,		// Alternate Lobby Floor
	0,		// Alternate Parking Floor
	0,		// Lobby Request Control 1=NCU
	0,		// Handicap Car Capacity
	1,		// Max=3200.0 Freight door close time-out
	0,		// Handicap Car wait time
	1,		// Short floor distance in inches
	0,		// Retiring Cam Control: +1=Hold retiring cam if door pilot at the floor, +2=advance auto door
	0,		// Recall from fire alternate floor
	1,		// Auto learn hoistway stall time
	2,		// Position Pulse Count Error
	1,		// Attendant buzzer timer min=0 max=30 [on by fvattbzon off by fvattbzoff]
	1,		// Attendant buzzer timer min=0 max=30 [on by fvattbzon off by fvattbzoff]
	1,		// Brake pick voltage rate time
	1,		// Brake relevel voltage rate time
	0,		// Brake Pick Start Voltage
	0,		// Brake relevel Start Voltage
	1,		// Short floor down slowdown time
	1,		// Mid Short floor down slowdown time
	1,		// Short floor up slowdown time
	1,		// Mid Short floor up slowdown time
	0,		// Hall Switch Elevator Off return floor
	0,		// Service message 1 display
	0,		// Service message 2 display
	0,		// Governor Gripper Trip Control
	0,		// Short Floor Soft Start Jerk Rate
	0,		// Short Floor Acceleration
	0,		// Short floor Roll Over Jerk
	0,		// Short floor Decel Jerk
	0,		// Short floor Decel Rate
	1,		// Short Floor Targ Dis
	0,		// Short floor control
	0,		// Security Recall Control 2: 0=out of group on first recall, 1=OoG all recalls, 2=no out of group recalls
	1,		// Emergency Power Recall Delay time
	0,		// Group car call security override time
	1,		// Emergency brake drop delay
	1,		// Emergency brake pick time
	1,		// Hall Call output on brightness for led
	1,		// Hall Call output off brightness for led
	0,		// Access top floor
	0,		// Access bottom floor
	0,		// Stop on position pulse
	1,		// Sabbath Svc restart time
	1,		// Power Door open relay on Time
	0,		// Display fault automatically on LCD when fault occurs	
	0,		// Password for adjusting field variables
	1,		// Password time-out time
	0,		// Behind car call cancel
	1,		// Door open advance door enable non-simultaneous doors
	0,		// Group service number of parking cars
	0,		// Binary preset update when position does not match
	0,		// Short floor hsf with no hsv high speed valve
	0,		// Up peak control: +1=Heavy Up
	0,		// Up peak pool: Cars taken out
	0,		// Down peak control: +1=Heavy Down
	0,		// Down peak pool: Cars taken out
	0,		// Cross Assignment Cars from old group
	0,		// Modbus protocol, 0-5=N1,N2,E1,E1,O1,O2 (Always 8 data bits, parity, stop bits)
	0,		// Fire alternate recall after fs turned off
	0,		// Inspection Decel Stop Rate
	0,		// Emergency Power Recovery Dir
	0,		// Brake drop voltage 
	1,		// Brake drop voltage rate time
	0,		// Brake Drop timing during Leveling flag
	0,		// Recovery Velocity fpm
	0,		// Emergency Deceleration to Leveling Rate
	0,		// Emergency Power Recovery Velocity
	0,		// Run Cycle time in hours
	1,		// Hall Call Up On red intensity
	1,		// Hall Call Up Off red intensity
	1,		// Hall Call Up On green intensity
	1,		// Hall Call Up Off green intensity
	1,		// Hall Call Up On blue intensity
	1,		// Hall Call Up Off blue intensity
	0,		// Door Open Light control in CCS board
	0,		// Hall Call Button Up On Color
	0,		// Hall Call Button Up Off Color
	0,		// Hall Call Button Security Color
	0,		// Hall Call Button Security Light 1 = invert security, +2=flash security , +4 Master enable sec
	1,		// Hall Call Security brightness
	1,		// Hall Call Security red intensity
	1,		// Hall Call Security green intensity
	1,		// Hall Call Security blue intensity
	0,		// Fire service hoistway sensor 2 return floor: 0=main 1 = alt 
	3,		// Drive Speed Multiplier
	0,		// Advanced pre-torque
	0,		// Car Call Button On Color
	0,		// Car Call Button Off Color
	1,		// Car Call output on brightness for led	(higher number is brighter)
	1,		// Car Call output off brightness	for led	(higher number is brighter)
	1,		// Car Call On red intensity
	1,		// Car Call Off red intensity
	1,		// Car Call On green intensity
	1,		// Car Call Off green intensity
	1,		// Car Call On blue intensity
	1,		// Car Call Off blue intensity
	0,		// Car Call Button Light Control: 1 = flash security, 2=Alternate Att Flash Sequence
	0,		// Car Call Button Security Color
	1,		// Car Call Security brightness
	1,		// Car Call Security red intensity
	1,		// Car Call Security green intensity
	1,		// Car Call Security blue intensity
	0,		// Sabbath Enable control variable,  1=allow momentary ir to override sabbath, 2 = Lobby Dwell timer, 4= Lobby off
	1,		// Low Line Voltage (RMS value)
	1,		// Low Door Voltage (RMS value)
	0,		// Emergency Power top speed
	0,		// Emergency Power Soft Start Jerk Rate
	0,		// Emergency Power Acceleration
	0,		// Emergency Power Roll Over Jerk
	0,		// Emergency Power Decel Jerk
	0,		// Emergency Power Decel Rate
	1,		// Emergency Power Targ Dis
	0,		// Car Top Speed
	0,		// Inspection Velocity from ISER output
	1,		// Emergency Power Recover to floor time
	0,		// Fire Light control during EP
	0,		// Emergency Power Manual Select Enable
	0,		// Fire Light control with car out of service (low pressure, eaq, stall)
	1,		// Sabbath Door Dwell Time
	1,		// Sabbath Door Buzzer timer prior to doors closing
	1,		// Low Battery Capacity Level
	0,		// Sabbath disable control variable, +1=PI, +2=Lanterns, +4=arrow
	0,		// Electric Eye cancel door time
	0,		// Emergency power car at recall floor with door open, 0=override immediately, 1=override after time-delay
	0,		// Emergency power car not at recall floor with door open, 0=override immediately, 1= override after time-delay
	0,		// Assign parking floor to car with door open
	1,		// Hall lantern delay
	0,		// Sabbath Enable control 2 variable,  1=Lobby On, 2 = Cab Lanterns as Direction Lanterns
	0,		// Cab Lantern Control 1 = on door open, 2 = on dpm limit
	1,		// Max Door Hold time from ED input 0 = disabled
	0,		// Access run door close
	0,		// Car Call Button Attendant Up Color
	1,		// Car Call Attendant Up brightness
	1,		// Car Call Attendant Up red intensity
	1,		// Car Call Attendant Up green intensity
	1,		// Car Call Attendant Up blue intensity
	0,		// Car Call Button Attendant Dn Color
	1,		// Car Call Attendant Dn brightness
	1,		// Car Call Attendant Dn red intensity
	1,		// Car Call Attendant Dn green intensity
	1,		// Car Call Attendant Dn blue intensity
	0,		// Fire light Color
	1,		// Fire light brightness
	1,		// Fire light red intensity
	1,		// Fire light green intensity
	1,		// Fire light blue intensity
	0,		// Medical light Color
	1,		// Medical light brightness
	1,		// Medical light red intensity
	1,		// Medical light green intensity
	1,		// Medical light blue intensity
	0,		// Emergency light Color
	1,		// Emergency light brightness
	1,		// Emergency light red intensity
	1,		// Emergency light green intensity
	1,		// Emergency light blue intensity
	0,		// OTS light Color
	1,		// OTS light brightness
	1,		// OTS light red intensity
	1,		// OTS light green intensity
	1,		// OTS light blue intensity
	0,		// Backlight Output lights Bit0: Fire, Bit1: Medical, Bit2: Emergency, Bit3: OTS, Bit4: Att Up/Dn Light
	0,		// Can Sync Count in 250 msec increments
	0,		// Hall Call Dn On color
	1,		// Hall Call Dn On brightness
	1,		// Hall Call Dn On red intensity
	1,		// Hall Call Dn On green intensity
	1,		// Hall Call Dn On blue intensity
	0,		// Hall Call Dn Off color
	1,		// Hall Call Dn Off brightness
	1,		// Hall Call Dn Off red intensity

	1,		// Hall Call Dn Off green intensity
	1,		// Hall Call Dn Off blue intensity
	0,		// Hall Call CB On color
	1,		// Hall Call CB On brightness
	1,		// Hall Call CB On red intensity
	1,		// Hall Call CB On green intensity
	1,		// Hall Call CB On blue intensity
	0,		// Hall Call Vip On color
	1,		// Hall Call Vip On brightness
	1,		// Hall Call Vip On red intensity
	1,		// Hall Call Vip On green intensity
	1,		// Hall Call Vip On blue intensity
	0,		// Hall Call IR Up On color
	1,		// Hall Call IR Up On brightness
	1,		// Hall Call IR Up On red intensity
	1,		// Hall Call IR Up On green intensity
	1,		// Hall Call IR Up On blue intensity
	0,		// Hall Call IR Dn On color
	1,		// Hall Call IR Dn On brightness
	1,		// Hall Call IR Dn On red intensity
	1,		// Hall Call IR Dn On green intensity
	1,		// Hall Call IR Dn On blue intensity
	0,		// Hall Call IR Up Off color
	1,		// Hall Call IR Up Off brightness
	1,		// Hall Call IR Up Off red intensity
	1,		// Hall Call IR Up Off green intensity
	1,		// Hall Call IR Up Off blue intensity
	0,		// Hall Call IR Dn Off color
	1,		// Hall Call IR Dn Off brightness
	1,		// Hall Call IR Dn Off red intensity
	1,		// Hall Call IR Dn Off green intensity
	1,		// Hall Call IR Dn Off blue intensity
	1,		// Hall Call output Up on brightness for led (higher number is brighter)
	1,		// Hall Call output off brightness for led (higher number is brighter)
	0,		// Code Blue Location: 0=CB on CB, 1 = CB on HCB, 2 = CB on IR,
	0,		// Vip Location 0 = vip on vip, 1 = Vip on HCB, 2 = Vip on IR
	0,		// IR light color control: 0=IR Color, 1=HC Color until IR activated
	0,		// Hall Call CB Off color
	1,		// Hall Call CB Off brightness
	1,		// Hall Call CB Off red intensity
	1,		// Hall Call CB Off green intensity
	1,		// Hall Call CB Off blue intensity
	0,		// Hall Call Vip Off color
	1,		// Hall Call Vip Off brightness
	1,		// Hall Call Vip Off red intensity
	1,		// Hall Call Vip Off green intensity
	1,		// Hall Call Vip Off blue intensity
	0,		// Vip lantern control: 1 = ring up and down at vip floor
	0,		// Group Car Call Override Control: 1=Key Switch Direct
	0,		// Exclusion fault 1
	0,		// Exclusion fault 2         
	0,		// Exclusion fault 3
	0,		// Exclusion fault 4        
	0,		// Exclusion fault 5
	0,		// Exclusion fault 6        
	0,		// Emergency Brake Pick voltage
	0,		// Emergency Brake hold voltage
	1,		// Emergency Brake Pick Rate
	1,		// Emergency Brake Drop Rate
	0,		// Emergency Brake Ac line to line voltage

	0,		// Brake Opto Trigger delay
	0,		// Can Baud Rate, 0=115.2K, 1=57.6K
	0,		// Car call arrival, 1 = activate lant/gong without onward call
	0,		// Code Blue second riser car select
	0,		// Code blue over IR car
	0,		// IR Car Code Blue penalty time
	0,		// INSEC - in security Output invert
	0,		//  Attendant manual direction enable
	0,		// Encoder Debounce Interval
	0,		// Encoder number of samples
	1,		// Handicap buzzer on CC beep time
	0,		// Service UPS mode
	0,		// Serial port comm diag
	0,		// User port 2 Baud Rate
	0,		// Cpu timing output control
	0,		// Service message 3 display
	0,		// Hall Call assignment secure type
	0,		// UPS baud rate: 0=2400,1=4800,2=9600,3=19200
	0,		// HC Acknowledge Attendant Buzzer
	0,		// Second Code Blue car select
	0,		// Elevator Off Options 2 
	0,		// Code blue Buzzer Control
	0,		// Code Blue Override Independent
	0,		// Code Blue Recall any car
	0,		// Hall Elevator off override independent
	0,		// Car door Reopen on open lock for NYC fire service
	1,		// Power loss brake on time
	1,		// Power loss brake off time
	0,		// Select/Prioratize ATT car to run in emp
	0,		// Encoder direction for Open can encoder
	0,		// Emergency cars finished Recalling Output enable
	0,		// Out of Service Light control
	0,		// Extra door time Location 
	0,		// Out of Service Light control
	1,		// Timer for OSERL no asnwering call
	1,		// Timer for OSERL	car between floors
	1,		// Timer for OSERL Safety String Open
	0,		// Fire service hoistway sensor location
	1,		// Retiring cam drop fail safe delay
	0,		// Velocity difference 
	0,		// Velocity difference fault disable
	0,		// SPB direction fault disable
	0,		// Limit direction fault disable
	0,		// Encoder direction fault disable
	0,		// UL/DL direction fault disable
	1,		// Relevel Start Velocity Hold Time
	0,		// Med door open sequence for re-open: 0=Stop, 1=Constant pressure, 2=momentary to DOL
	0,		// Med Ind override: 0=Immediate, 1=After Delay, 2=No ovarride
	0,		// Code Blue Bypass Disable
	0,		// Extended Door PI Message
	0,		// Car to return first on Emergency Power feeder 2
	0,		// Car to select first to run auto on Emergency Power feeder 2
	0,		// RCM Cam out for freight
	1,		// Lantern preference change delay
	0,		// Slip velocity difference fault trip value
	0,		// DOB overrides DCB on phase 2
	0,		// Denver Fire service ammendment to close the phase 1 doors after recall and reopen from a hall call
	1,		// Denver FS phase1 dwell time
	0,		// Hall call security control 0 = std HC; 1 = std and SR HC ; 2 = SR HC
	0,		// Slip velocity difference disable
	0,		// Leveling fault trip. 0=drop everything, 1= set em brake or gripper
	0,		// Emergency Brake Switch Control 0 = don't start if brake switch does not pick, 1 = ignore brake switch on start
	0,		// unused
	0,		// unused
	0,		// unused	 484
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 489
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 494
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 499
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 504
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 509
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 514
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 519
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 524
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 529
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 534
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 539
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 544
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 549
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 554
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 559
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 564
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 569
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 574
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 579
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 584
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 589
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 594
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 599
};
int16 fvars_max[nmbfvar] ={	   // Note: -1 == cons[nmbcars] ,  -2 == cons[topf], -3 = cons[speed]
	50,		// Max=5.0 Y Delta Time
	100,	// Max=10.0 Fault Time
	100,	// Max=10.0 Reset Time
	1,		// 1 = 2 Gongs Double Stoke
	20,		// Max=2.0 Lantern On Time
	20,		// Max=2.0 Latern Off Time
	20,		// Max=2.0 Floor Passing Chime Time
	32000,	// Max=3200.0 Door Failure Time
	32000,	// Max=3200.0 Nudging Time
	32000,	// Max=3200.0 Preopenning Delay Time
	600,	// Max=60.0 Car Call Door Dwell Time
	600,	// Max=60.0 Hall Call Door Dwell Time
	600,	// Max=60.0 Lobby Call Door Dwell Time
	1200,	// Max=120.0 Handicap Door Dwell Time
	600,	// Max=60.0 Non Interfance Timer
	-2,		// Max=Top Floor Lobby Floor
	-2,		// Max=Top Floor Fire Service Main Return
	-2,		// Max=Top Floor Fire Service Alternate Return
	32000,	// Max=3200.0 Stall Time
	300,	// Max=3.00 Soft Stop Time
	32000,	// Max=3200.0 Generator Run Time
	50,		// Max=5.0 Brake Pick Delay Time
	50,		// Max=5.0 Brake Drop Delay Time
	480,	// Max=480 fpm/ss Soft Start Jerk Rate
	300,	// Max=300  fpm/s Acceleration
	480,	// Max=480 fpm/ss Decel Jerk
	300,	// Max=300  fpm/s Decel Rate
	250,	// Max=25.0 in. Floor Targ Dis
	150,	// Max=15.0 fpm Leveling Speed
	150,	// Max=15.0 fpm Relevel Speed
	150,	// Max=150 fpm Inspect Speed
	2999,	// Max=2999 Year
	12,		// Max=12 Month
	31,		// Max=31 Day
	23,		// Max=23 Hour
	59,		// Max=59 Minute
	480,	// Max=480 fpm/ss Roll Over Jerk
	1,		// Max=1= ON Diagnostic LED
	2999,	// Max=2999 Annual Safty Test Year
	12,		// Max=12 Annual Safty Test Month
	31,		// Max=31 Annual Safty Test Day
	300,	// Max=3.00 sec Pattern Delay
	110,  	// Max=110% Field Weakening
    32000,  // Max=65535 Encoder PPR
	3000,  	// Max=3000 Encoder RPM
	3,		// Max=3 for 19200 baud
	-1,		// Max=8 for number of cars to park
	-2,		// Max=Top Floor Emergency Power Recall Floor
	-1,		// Max=8 Number of Emergency Power Cars
	-1,		// Max=8 Car to return first on Emergency Power
	-1,		// Max=8 Car to select first to run auto on Emergency Power
	6000,	// Max=600.0 Return car Time-out
	1,		// Max=1 DOB opens door during nudging
	1,		// Max=1 Emergency Dispatch Enable
	-1,		// Max=8 Number Cars Requested at lobby
	7,		// Next Up Selection 0=OFF, 1=NCU DO, 2=NCU DC, 4=NCU up peak
	-1,		// Max=8 Code blue car select number
	-1,		// Max=8 IR car select
	2,		// Max = 2 Brake Lift Switch, 0=disable, 1=enable, 2=set gripper on fault
	50,		// Max = 50 Load Weighing anti-nuisance count (0=disabled)
	3,		// Max = 3, Fire Switch location: 0 = front, 1=main rear, 2=alt rear, 3=main/alt rear 
	60,		// Max = 60 ETA min time
	60,		// Max = 60 ETA for coincident car call
	-1,		// Max = 8, Video position for car 1
	-1,		// Max = 8, Video position for car 2
	-1,		// Max = 8, Video position for car 3
	-1,		// Max = 8, Video position for car 4
	-1,		// Max = 8, Video position for car 5
	-1,		// Max = 8, Video position for car 6
	10,		// Max = 10, No passenger run count
	1,		// Max = 1, Independent overrides Security when set
	50,		// Max = 5.0, Brake pick delay time on relevel
	1,		// Max = 1, Brake cool on relevel 0 = std brake cool, 1 = brake cool immediately (produce partial brake lift)
	32000,	// Max = 3200.0, Up peak trigger time
	100,	// Max = 100, Up Peak trigger count
	40,		// Max = 40, Up Peak car call count
	32000,	// Max = 3200.0, Up Peak Duration time
	32000,	// Max = 3200.0, Down Peak trigger time
	100,	// Max = 100, Down Peak trigger count
	32000,	// Max = 3200.0, Down Peak Duration time
	1200,	// Max = 120.0, Parking delay time
	2,		// Max = 1, Hall call cross assignment, 0 = 0FF, 1 = xasgn, 2 = xcanc
	500,	// Max = 500, Hall Call cross assignment ETA
	-2,		// Max = 29, Medical Emergency Floor
	1,		// Max = 1, Medical Emergency Switch location 0 = front, 1= rear
	1,		// Max = 1, Fire service Motor room sensor return floor: 0=main 1 = alt
	1,		// Max = 1, Fire service hoistway sensor return floor: 0=main 1 = alt 
	2,		// Max = 1, Phase 1 fire recall reset: 0 = after recall, 1=immediate, +2=FS only reset from OFF
	225,	// Max = 225, Accel and decel limit at final stop
	300,	// Max=3.00 sec Pattern Delay Relevel
	1,		// Max = 1, Delay start until drive on
	7372, 	// Max = 7372, Brake Opto Trigger delay
	1,		// Max = 1, 1 - Brake lift switch normally closed, 0 - Brake lift switch normally open
	7,		// Max = 7, 1 - ISER on when out of service, 0 - ISER on when in service, +2= IN USE LIGHT
	-1,		// Max = 8, maximum number of cars in group. Ability to change a car other than 1 or 2 to become the master
	32000,	// Max = 36000, 0 - do not time out, if set to non-zero then time-out video display.
	1,		// Max = 1, 1 - turn on DC output while trying to run on inspection, 0 - do not turn on DC output while trying to run on inspection
	-2,		// Max = 29, number of floors for parking floor 1
	-2,		// Max = 29, number of floors for parking floor 2
	-2,		// Max = 29, number of floors for parking floor 3
	-2,		// Max = 29, number of floors for parking floor 4
	-2,		// Max = 29, number of floors for parking floor 5
	-2,		// Max = 29, number of floors for parking width
	1000,  	// Max = 100.0, Balanced load percent
	10000,	// Max = 100.00, Drive starting Torque Multiplier
	100,	// Max = 100, Load bypass percent  0% = disabled
	100,	// Max = 100, Load antinuisance percent  0% = disabled
	100,	// Max = 100, Load dispatch percent  0% = disabled
	125,	// Max = 125, Load overload percent  0% = disabled
	15,		// Max = 0xf, IR control flag
	400,	// Max = 400, Brake pick voltage	 110
	60,		// Max = 6.0 sec, Brake pick duration time
	400,	// Max = 400, Brake hold voltage
	400,	// Max = 400, Brake Relevel Voltage
	300,	// Max = 300, Brake Ac line to line voltage
	5000, 	// Max = 500.0, Brake resistance
	9000,	// Max = 900.0 Attendant buzzer delay time
	1,		// Max = 1, Hall Fire Aux. Switch
	4,		// Max = 4, Fire service override or phase 1 in effect, FSO,FSL
	7,		// Max = 1, COP/Remote CC Select 0=both,1=Seperate,+2=COP->Remote,+4=Remote->COP Ack Light
	15,		// Max = 1.5, Door open or close delay time
	15,		// Max = 15, Security Recall: 1=recall to lobby, +2=cycle front door, +4=cycle rear door
	1,		// Max = 1, DOB overrides Security when 1.
	9000, 	// Max = 900.0 Manual Door Buzzer Delay
	-2,		// Max = Top Floor, Security Floor
	70,		// Max = 7.0, retiring cam pick delay timer
	600,	// Max = 60.0, short door time
	-1,		// Max = 8, second IR select
	15,		// Max = 7, Stop at lobby
	1,		// Max = 1, Invert Cab light fan
	1,		// Max = 1, Invert Temperature Low switch (tpl)
	1,		// Max = 1, Invert Low Pressure Switch
	1,		// Max = 1, Invert Low Oil Switch
	1,		// Max = 1, Nudging with no onward call
	3,		// Max = 3, Fire option flag
	1,		// Max = 1, Attendant Car Call
	32000,	// Max = 3200.0, Code blue door open time
	1,		// Max = 1, Request Ind car for code blue
	1,		// Max = 1, Flash light on code blue
	1,		// Max = 1, Hospital Service door close on car call
	200,	// Max = 20, Gripper reset time
	1,		// Max = 1, Independent door close on car call
	5000,	// Max = 50.00 Torque offset
	7,		// Max = 7, Gripper test from safety processor board speed and overspeed.
	7,		// Max = 4, Single automatic pushbutton control
	1,		// Max = 1, Door Open when DOL signal not active
	0,		// Max = 0, Previously: fvdisglt - Disable Gate and Lock Test for New York City
	150,	// Max=15.0 fpm Relevel start Speed
	360,	// Max=360  fpm/s Emergency Decel Rate
	1,		// Max = 1, Disable DCB cancel door time
	7,		// Max = 7, Return to lobby option, +1 = cycle door, +2 = cancel car calls, +4 = cycle door on reversal
	-1,		// Max = 7, Video position for car 7
	-1,		// Max = 8, Video position for car 8
	3,		// Max = 3, Parking type 0 = busy floor park, 1 = divide hoistway, 2 = fixed park
	-2,		// Max = 29, number of floors for parking floor 6
	-2,		// Max = 29, number of floors for parking floor 7
	2,		// Max = 2, Non-Simultaneous Doors = 1 (front first), 2 = rear first
	3,		// Max = 3, Pre-open doors = 1, 0 = no preopen, +2 = no predo shortfl..
	125,	// Max = 125 Over speed precent
	7,		// Max = 7, Position pulse count update, +1=enable, +2 use dz int, +4=constant velocity
	10000,	// Max = 10000, Position pulse delay error
	1,		// Max = 1, Gripper buzzer, 1 = enable	 
	20,		// Max = 20, Relevel delay time
	3,		// Max = 1, Fire OPtion 2, +1= ph2 recall open door first, +2 blink disable ph2
	1,		// Max = 1, Close gate on swing door with no preference
	10,		// Max = 10, Leveling fault count
	10000,	// Max=100.00, Torque amount for down direction
	100,	// Max = 1.00, Ramp torque time during pattern delay
	32000,	// Max=3200.0 Electric Eye time-out Time
	1,		// Max = 1, Cars out of service hall call cancel, 1 = enable
	7,		// Max = 7, Nudging Ctl 1=Disable Nudging Output, +2=reopen door on ee or se, +4 = buz blocked door
	600,	// Max = 60.0, Fire phase1 door time-out (ind and att).
	3,		// Max = 3, No hall call button door reopen with onward call
	10,		// Max = 10, Drive ready reset count
	600,	// Max = 60.0, Return to Lobby Door Dwell Time
	3,		// Max = 3, Next Up Lobby Lantern control 1=Turn off hall lantern, 2=turn off cab lantern
	1,		// Max = 1, Next Up Preference Control 0=Keep until DCL, 1 = after ncu time
	3,		// Max = 3, Second Riser Control, 1 = SR Cars Std HC no assign, 2 = Or SR with std riser
	1,		// Max = 1, Second Riser Lantern Control, 1=Cab Lant on SR
	60,		// Max = 60, Attendant ETA preference time

	1,		// Max = 1, Handicap buzzer disabled at non valid floor	 
	32000,	// Max = 3200.0, Vip door open time
	3,		// Max = 3, Vip Operation Flags +1=Cancel HC if no cars, +2=Cancel car calls 1st
	-1,		// Max = Number of cars in group, Number of VIP cars
	3,		// Max = 3, Emergency Power Op LED function
	2,		// Max = 2, Emergency Power Park LED Function
	7,		// Max = 7, Elevator Off Options: +1=Recall, +2=Keep Door Open, +4=Turn off CLF
	4,		// Max = 4, Drive baud rate: 0=19200, 1=38400, 2=57600, 3=115200, 4=9600
	2,		// Max = 2, Drive update rate: 0 = 10 msec, 1 = 15 msec, 2 = 20 msec 
	-2,		// Max = top fl, Alternate Lobby Floor
	-2,		// Max = top fl, Alternate Parking Floor
	1,		// Max = 1, Lobby Request Control 1=NCU
	100,	// Max = 100, Handicap Car Capacity
	32000,	// Max=3200.0, Freight door close time-out
	255,	// Max = 255, Handicap Car wait time
#if (Hollister) == 1
	1600,	// Max = 160.0, Short floor distance in inches  ** Special for 1000 fpm car
#else
	720,	// Max = 72.0, Short floor distance in inches
#endif
	3,		// Max = 3, Retiring Cam Control: +1=Hold retiring cam if door pilot at the floor, +2=advance auto door
	3,		// Max = 3, Fire alternate recall after fs turned off
	32000,	// Max = 3200.0, Auto learn hoistway stall time
	200,	// Max = 2.00, Position Pulse Count Error
	300,	// Max = 30.0, time the attendant buzzer will be off before it buzzes again
	300,	// Max = 30.0, time the attendant buzzer will be on before it buzzes again
	20,		// Max = 2.0, Brake pick voltage rate time
	20,		// Max = 2.0, Brake relevel voltage rate time
	400,	// Max = 400, Brake Pick Start Voltage
	400,	// Max = 400, Brake relevel Start Voltage
	300,	// Max = 30.0, Short floor down slowdown time
	300,	// Max = 30.0, Mid Short floor down slowdown time
	300,	// Max = 30.0, Short floor up slowdown time
	300,	// Max = 30.0, Mid Short floor up slowdown time
	-2,		// Max = Top Floor, Hall Switch Elevator Off return floor
	30,		// Max = 30, Service message 1 display
	30,		// Max = 30, Service message 2 display
	1,		// Max = 1, Governor Gripper Trip Control
	480,	// Max = 480, fpm/ss Short Floor Soft Start Jerk Rate
	300,	// Max = 300,  fpm/s Short Floor Acceleration
	480,	// Max = 480, fpm/ss Short Floor Decel Jerk
	480,	// Max = 480, fpm/ss Short Floor Roll Over Jerk
	300,	// Max = 300,  fpm/s Short Floor Decel Rate
	250,	// Max = 25.0, in. Short Floor Targ Dis
	7,		// Max = 7, Short floor control
	2,		// Max = 2, Security Recall Control 2: 0=out of group on first recall, 1=OoG all recalls, 2=no out of group recalls
	32000,	// Max = 3200.0 Emergency Power Recall Delay time
	240, 	// Max = 240 Group car call security override time
	3600,	// Max = 360.0 Emergency brake drop delay
	100,	// Max = 10.0 Emergency brake pick time
	1000,	// Max = 100.0, Hall Call output on brightness for led
	1000,	// Max = 100.0, Hall Call output off brightness for led
	-2,		// Max = top floor, Access top floor
	-2,		// Max = top floor, Access bottom floor
	1,		// Max = 1, Stop on position pulse
	32000,	// Max = 3200.0, Sabbath Svc restart time
	300,	// Max = 30.0, Power Door open relay on Time
	1,		// Max = 1, Display fault automatically on LCD when fault occurs
	9999,	// Max = 9999, highest password
	32000,	// Max = 3200.0 Password time-out time
	1,		// Max = 1, Behind car call cancel
	2400,	// Max = 240.0, Door open advance door enable non-simultaneous doors
	-1,		// Max = 8, Group service number of parking cars
	1,		// Max = 1, Binary preset update when position does not match
	1,		// Max = 1, Short floor hsf with no hsv high speed valve
	1,		// Max = 1, Up peak control: +1=Heavy Up
	-1,		// Max = 8, Up peak pool: Cars taken out
	1,		// Max = 1, Down peak control: +1=Heavy Down
	-1,		// Max = 8, Down peak pool: Cars taken out
	-1,		// Max = 8, Cross Assignment Cars from old group
	5,		// Max = 5, Modbus protocol, 0-5=N1,N2,E1,E1,O1,O2 (Always 8 data bits, parity, stop bits)
	1,		// Max = 1, Fire alternate recall after fs turned off
	480,	// Max = 480, Inspection Decel Stop Rate
	1,		// Max = 1, Emergency Power Recovery Dir
	200,	// Max = 200, Brake drop voltage 
	50,		// Max = 5.0, Brake drop voltage rate time
	1,		// Max = 1, Brake Drop timing during Leveling flag
	100,	// Max = 100, Recovery Velocity fpm
	300, 	// Max = 300, Emergency Deceleration to Leveling Rate
	100,	// Max = 100, Emergency Power Recovery Velocity
	300,	// Max = 300, Cycle Run time in hours
	1000,	// Max = 100.0, Hall Call Up On red intensity
	1000,	// Max = 100.0, Hall Call Up Off red intensity
	1000,	// Max = 100.0, Hall Call Up On green intensity
	1000,	// Max = 100.0, Hall Call Up Off green intensity
	1000,	// Max = 100.0, Hall Call Up On blue intensity
	1000,	// Max = 100.0, Hall Call Up Off blue intensity
	16,		// Max = 16, Door Open Light control in CCS board
	15,		// Max = 15, Hall Call Button Up On Color
	15,		// Max = 15, Hall Call Button Up Off Color
	15,		// Max = 15, Hall Call Button Security Color
	7,		// Max = 7,	Hall Call Button Security Light 1 = invert security, +2=flash security , +4 Master Sec Enable
	1000,  	// Max = 100.0, Hall Call Security brightness
	1000,  	// Max = 100.0, Hall Call Security red intensity
	1000,  	// Max = 100.0, Hall Call Security green intensity
	1000,  	// Max = 100.0, Hall Call Security blue intensity
	1,		// Max = 1, Fire service hoistway sensor 2 return floor: 0=main 1 = alt 
	2000,	// Max = 2.000, Drive Speed Multiplier
	1,		// Max = 1, Advanced pre-torque
	15,		// Max = 15, Car Call Button On Color
	15,		// Max = 15, Car Call Button Off Color
	1000,	// Max = 100.0, Car Call output on brightness for led	(higher number is brighter)
	1000,	// Max = 100.0, Car Call output off brightness	for led	(higher number is brighter)
	1000,	// Max = 100.0, Car Call On red intensity
	1000,	// Max = 100.0, Car Call Off red intensity
	1000,	// Max = 100.0, Car Call On green intensity
	1000,	// Max = 100.0, Car Call Off green intensity
	1000,	// Max = 100.0, Car Call On blue intensity
	1000,	// Max = 100.0, Car Call Off blue intensity
	3,		// Max = 1, Car Call Button Light Control: 1 = flash security, 2=Alternate Att Flash Sequence
	15,		// Max = 15, Car Call Button Security Color
	1000,	// Max = 100.0, Car Call Security brightness
	1000,	// Max = 100.0, Car Call Security red intensity
	1000,	// Max = 100.0, Car Call Security green intensity
	1000,	// Max = 100.0, Car Call Security blue intensity
	7,		// Max = 7, Sabbath Enable control variable,  1=allow momentary ir to override sabbath, 2 = Lobby Dwell timer, 4= Lobby off
	6000,	// Max = 600, Low Line Voltage (RMS value)
	6000,	// Max = 600, Low Door Voltage (RMS value)
	-3,		// Max = Top Speed, Emergency Power top speed
	480,	// Max = 480, fpm/ss Emergency Power Soft Start Jerk Rate
	300,	// Max = 300,  fpm/s Emergency Power Acceleration
	480,	// Max = 480, fpm/ss Emergency Power Decel Jerk
	480,	// Max = 480, fpm/ss Emergency Power Roll Over Jerk
	300,	// Max = 300,  fpm/s Emergency Power Decel Rate
	250,	// Max = 25.0, in. Emergency Power Floor Targ Dis
	-3,		// Max = Top Speed, Car Top Speed
	1,		// Max = 1, Inspection Velocity from ISER output
	600,	// Max = 60.0, Emergency Power Recover to floor time
	1,		// Max = 1, Fire Light control during EP
	3,		// Max = 3, Emergency Power Manual Select Enable
	1,		// Max = 1, Fire Light control with car out of service (low pressure, eaq, stall)
	600,	// Max = 600, Sabbath Door Dwell Time
	100,	// Max = 100, Sabbath Door Buzzer timer prior to doors closing
	1010,	// Max = 101.0, Low Battery Capacity Level
	7,		// Max = 7, Sabbath disable control variable, +1=PI, +2=Lanterns, +4=arrow
	1,		// Max = 1, Electric Eye cancel door time
	1,		// Max = 1, Emergency power car at recall floor with door open, 0=override immediately, 1=override after time-delay
	1,		// Max = 1, Emergency power car not at recall floor with door open, 0=override immediately, 1= override after time-delay
	1,		// Max = 1, Assign parking floor to car with door open
	150,	// Max = 15.0 seconds, Hall Lantern delay
	3,		// Max = 3, Sabbath Enable control 2 variable,  1=Lobby On, 2 = Cab Lanterns as Direction Lanterns
	2,		// Max = 7, Cab Lantern Control 1 = on door open, 2 = on dpm limit
	32000,	// Max = 3200.0, Max Door Hold time from ED input 0 = disabled
	1,		// Max = 1, Access run door close
	15,		// Max = 15, Car Call Button Attendant Up Color
	1000,	// Max = 100.0, Car Call Attendant Up brightness
	1000,	// Max = 100.0, Car Call Attendant Up red intensity
	1000,	// Max = 100.0, Car Call Attendant Up green intensity
	1000,	// Max = 100.0, Car Call Attendant Up blue intensity
	15,		// Max = 15, Car Call Button Attendant Dn Color
	1000,	// Max = 100.0, Car Call Attendant Dn brightness
	1000,	// Max = 100.0, Car Call Attendant Dn red intensity
	1000,	// Max = 100.0, Car Call Attendant Dn green intensity
	1000,	// Max = 100.0, Car Call Attendant Dn blue intensity
	15,		// Max = 15, Fire light Color
	1000,	// Max = 100.0, Fire light brightness
	1000,	// Max = 100.0, Fire light red intensity
	1000,	// Max = 100.0, Fire light green intensity
	1000,	// Max = 100.0, Fire light blue intensity
	15,		// Max = 15, Medical light Color
	1000,	// Max = 100.0, Medical light brightness
	1000,	// Max = 100.0, Medical light red intensity
	1000,	// Max = 100.0, Medical light green intensity
	1000,	// Max = 100.0, Medical light blue intensity
	15,		// Max = 15, Emergency light Color
	1000,	// Max = 100.0, Emergency light brightness
	1000,	// Max = 100.0, Emergency light red intensity
	1000,	// Max = 100.0, Emergency light green intensity
	1000,	// Max = 100.0, Emergency light blue intensity
	15,		// Max = 15,  light Color
	1000,	// Max = 100.0, OTS light brightness
	1000,	// Max = 100.0, OTS light red intensity
	1000,	// Max = 100.0, OTS light green intensity
	1000,	// Max = 100.0, OTS light blue intensity
	63,		// Max = 63, Backlight Output lights Bit0: Fire, Bit1: Medical, Bit2: Emergency, Bit3: OTS, Bit4: Att Up/Dn Light, Bit5: Non-CC
	7,		// Max = 7, Can Sync Count in 250 msec increments
	15,		// Max = 15,  Hall Call Dn On color
	1000,	// Max = 100.0, Hall Call Dn On brightness
	1000,	// Max = 100.0, Hall Call Dn On red intensity
	1000,	// Max = 100.0, Hall Call Dn On green intensity
	1000,	// Max = 100.0, Hall Call Dn On blue intensity
	15,		// Max = 15,  Hall Call Dn Off color
	1000,	// Max = 100.0, Hall Call Dn Off brightness
	1000,	// Max = 100.0, Hall Call Dn Off red intensity

	1000,	// Max = 100.0, Hall Call Dn Off green intensity
	1000,	// Max = 100.0, Hall Call Dn Off blue intensity
	15,		// Max = 15,  Hall Call CB On color
	1000,	// Max = 100.0, Hall Call CB On brightness
	1000,	// Max = 100.0, Hall Call CB On red intensity
	1000,	// Max = 100.0, Hall Call CB On green intensity
	1000,	// Max = 100.0, Hall Call CB On blue intensity
	15,		// Max = 15,  Hall Call Vip On color
	1000,	// Max = 100.0, Hall Call Vip On brightness
	1000,	// Max = 100.0, Hall Call Vip On red intensity
	1000,	// Max = 100.0, Hall Call Vip On green intensity
	1000,	// Max = 100.0, Hall Call Vip On blue intensity
	15,		// Max = 15,  Hall Call IR Up On color
	1000,	// Max = 100.0, Hall Call IR Up On brightness
	1000,	// Max = 100.0, Hall Call IR Up On red intensity
	1000,	// Max = 100.0, Hall Call IR Up On green intensity
	1000,	// Max = 100.0, Hall Call IR Up On blue intensity
	15,		// Max = 15,  Hall Call IR Up On color
	1000,	// Max = 100.0, Hall Call IR Up Off brightness
	1000,	// Max = 100.0, Hall Call IR Up Off red intensity
	1000,	// Max = 100.0, Hall Call IR Up Off green intensity
	1000,	// Max = 100.0, Hall Call IR Up Off blue intensity
	15,		// Max = 15,  Hall Call IR Dn On color
	1000,	// Max = 100.0, Hall Call IR Dn On brightness
	1000,	// Max = 100.0, Hall Call IR Dn On red intensity
	1000,	// Max = 100.0, Hall Call IR Dn On green intensity
	1000,	// Max = 100.0, Hall Call IR Dn On blue intensity
	15,		// Max = 15,  Hall Call IR Dn On color
	1000,	// Max = 100.0, Hall Call IR Dn Off brightness
	1000,	// Max = 100.0, Hall Call IR Dn Off red intensity
	1000,	// Max = 100.0, Hall Call IR Dn Off green intensity
	1000,	// Max = 100.0, Hall Call IR Dn Off blue intensity
	1000,	// Max = 100.0, Hall Call output Up on brightness for led
	1000,	// Max = 100.0, Hall Call output Up off brightness for led
	2,		// Max = 2, Code Blue Location: 0=CB on CB, 1 = CB on HCB, 2 = CB on IR,
	2,		// Max = 2, Vip Location 0 = vip on vip, 1 = Vip on HCB, 2 = Vip on IR
	1,		// Max = 1,	IR light color control: 0=IR Color, 1=HC Color until IR activated
	15,		// Max = 15,  Hall Call CB Off color
	1000,	// Max = 100.0, Hall Call CB Off brightness
	1000,	// Max = 100.0, Hall Call CB Off red intensity
	1000,	// Max = 100.0, Hall Call CB Off green intensity
	1000,	// Max = 100.0, Hall Call CB Off blue intensity
	15,		// Max = 15,  Hall Call Vip Off color
	1000,	// Max = 100.0, Hall Call Vip Off brightness
	1000,	// Max = 100.0, Hall Call Vip Off red intensity
	1000,	// Max = 100.0, Hall Call Vip Off green intensity
	1000,	// Max = 100.0, Hall Call Vip Off blue intensity
	3,		// Max = 3, Vip lantern control: 1 = ring up and down at vip floor
	1,		// Max = 1, Group Car Call Override Control: 1=Key Switch Direct
	max_nmbflts,	// Max = max_nmbflts, Exclusion fault 1
	max_nmbflts,	// Max = max_nmbflts, Exclusion fault 2
	max_nmbflts,	// Max = max_nmbflts, Exclusion fault 3
	max_nmbflts,	// Max = max_nmbflts, Exclusion fault 4
	max_nmbflts,	// Max = max_nmbflts, Exclusion fault 5
	max_nmbflts,	// Max = max_nmbflts, Exclusion fault 6
	400,  	// Max = 400, Emergency Brake Pick voltage
	400,  	// Max = 400, Emergency Brake hold voltage
	20,		// Max = 2.0, Emergency Brake Pick Rate time
	15,		// Max = 1.5, Emergency Brake Drop Rate
	300,	// Max = 300, Emergency Brake Ac line to line voltage

	7372, 	// Max = 7372, Brake Opto Trigger delay
	1,		// Max = 1, Can Baud Rate, 0=115.2K, 1=57.6K
	1,		// Max = 1, Car call arrival, 1 = activate lant/gong without onward call
	-1,		// Max=8 Code blue second riser car number
	1,		// Max=1, Code blue over IR car
	60,		// Max=60, IR Car Code Blue penalty time
	1,		// Max = 1 INSEC - in security Output invert unused
	4,		// Max = 4, Attendant manual direction enable
	5,		// Max = 5, Encoder Debounce Interval
	10,		// Max = 10, Encoder number of samples
	20,		// Max = 2 sec Handicap buzzer on CC beep time
	1,		// Max = 1, Service UPS mode
	15,		// Max = 15, Serial port comm diag
	3,		// Max = 3, User port 2 Baud Rate
	0x7FFF,	// Max = 0xFFFF, Cpu timing output control
	30,		// Max = 30, Service message 3 display
	15,		// Max = 15, Hall Call assignment secure type
	3,		// Max = 3, UPS baud rate: 0=2400,1=4800,2=9600,3=19200
	1,		// Max = 1, HC Acknowledge Attendant Buzzer
	-1,		// Max=8 Second Code blue car select number
   	3,		// Max = 3, Elevator Off Options 2
	1,		// Max = 1, Code blue Buzzer Control
	1,		// Max = 1,	Code Blue Override Independent
	1,		// Max = 1, Code Blue Recall any car
	1,		// Max = 1, Hall Elevator off override independent
	1,		// Max = 1, Car door Reopen on open lock for NYC fire service
	50,		// Max = 5.0, Power loss brake on time
	50,		// Max = 5.0, Power loss brake off time
	1,		// Max = 1,   Select/Prioratize ATT car to run in emp
	1,		// Max = 1, Encoder direction for Open can encoder
	1,		// Max = 1, Emergency cars finished Recalling Output enable
	7,		// Max = 7, Out of Service Light control
	-2,		// Max = Top Floor, Extra door time Location
	1,		// Max = 1 ,Out of Service Light control
	9000,	// Max = 600, Timer for OSERL no asnwering call
	9000,	// Max = 600, Timer for OSERL	car between floors
	9000,	// Max = 600, Timer for OSERL Safety String Open 
	1,		// Max = 1 Fire service hoistway sensor location
	55,		// Max = 50, Retiring cam drop fail safe delay 
	300,	// Max = 300, Velocity difference 
	1,		// Max = 1, Velocity difference fault disable
	1,		// Max = 1, SPB direction fault disable
	1,		// Max = 1, Limit direction fault disable
	1,		// Max = 1, Encoder direction fault disable
	1,		// Max = 1, UL/DL direction fault disable
	20,		// Max = 2.0, Relevel Start Velocity Hold Time
	2,		// Max = 2, Med door open sequence for re-open: 0=Stop, 1=Constant pressure, 2=momentary to DOL
	2,		// Max = 2, Med Ind override: 0=Immediate, 1=After Delay, 2=No ovarride
	1,		// Max = 1, Code Blue Bypass Disable
	1,		// Max = 1, Extended Door PI Message
	-1,		// Max = 8, Car to return first on Emergency Power	feeder 2
	-1,		// Max = 8, Car to select first to run auto on Emergency Power	feeder 2
	1,		// Max = 1, RCM Cam out for freight
	30,		// Max = 3.0, Lantern preference change delay
	300,	// Max = 300, Slip velocity difference fault trip value
	1,		// Max = 1, DOB overrides DCB on phase 2
	1,		// Max = 1, Denver Fire service ammendment to close the phase 1 doors after recall and reopen from a hall call
	900,	// Max = 90.0, Denver FS phase1 dwell time
	2,		// Max = 2, Hall call security control 0 = std HC; 1 = std and SR HC ; 2 = SR HC
	1,		// Max = 1, Slip velocity difference disable
	1,		// Max = 1, Leveling fault trip. 0=drop everything, 1= set em brake or gripper
	1,		// Max = 1, Emergency Brake Switch Control 0 = don't start if brake switch does not pick, 1 = ignore brake switch on start
	0,		// unused
	0,		// unused
	0,		// unused	 484
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 489
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 494
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 499
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 504
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 509
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 514
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 519
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 524
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 529
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 534
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 539
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 544
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 549
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 554
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 559
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 564
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 569
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 574
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 579
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 584
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 589
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 594
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 599

};
int16 fvars_min[nmbfvar] ={		// Note: -1 = cons[carnmb], -2 = cons[bottomf]
	0,		//  "Min=0  Y Delta Time
	0,		//  "Min=0  Fault Time
	0,		//  "Min=0  Reset Time
	0,		//  "Min=0  Double Stoke
	0,		//  "Min=0  Lantern On Time
	0,		//  "Min=0  Latern Off Time
	2,		//  "Min=.2 Floor Passing Chime Time
	100,	//  "Min=10.0 Door Failure Time
	200,	//  "Min=20.0  Nudging Time
	0, 		//  "Min=0 Preopenning Delay Time
	10,		//  "Min=1.0 Car Call Door Dwell Time
	10,		//  "Min=1.0 Hall Call Door Dwell Time
	10,		//  "Min=1.0 Lobby Call Door Dwell Time
	10,		//  "Min=1.0 Handicap Door Dwell Time
	10,		//  "Min=1.0 Non Interfance Timer
	-2,		//  "Min=Bottom Floor Lobby Floor
	-2,		//  "Min=Bottom Floor Fire Service Main Return
	-2,		//  "Min=Bottom Floor Fire Service Alternate Return
	300,	//  "Min=30.0 Stall Time
	2,		//  "Min=0.2 Soft Stop Time
	300,	//  "Min=30.0 Generator Run Time
	0,		//  "Min=0 Brake Pick Delay Time
	0,		//  "Min=0 Brake Drop Delay Time
	50,		//  "Min=50 Soft Start Jerk Rate
	50,		//  "Min=50 Acceleration
	50,		//  "Min=50 Decel Jerk
	50,		//  "Min=50 Decel Rate
	12,		//  "Min=1.2 Floor Targ Dis
	10,		//  "Min=1.0 Leveling Speed
	10,		//  "Min=1.0 Relevel Speed
	0,		//  "Min=0 Inspect Speed
	2000,	//  "Min=2000 Year
	1,		//  "Min=1 Month
	31,		//  "Min=1 Day
	0,		//  "Min=0 Hour
	0,		//  "Min=0 Minute
	50,		//  "Min=50 Roll Over Jerk
	0,		//  "Min=0 EE memory Size 0 = 32K, 1 = 8K (previously - diagnostic led's 0 to disable 1 to enable)
	2000,	//  "Min=2000 Annual Safty Test Year
	1,		//  "Min=1 Annual Safty Test Month
	1,		//  "Min=1 Annual Safty Test Day
	0,		//  "Min=0 Pattern Delay
	60, 	//	"Min=60% Field Weakening
    256,  	// Min=256 Encoder PPR
	1,  	// Min=1 Encoder RPM
	0, 		// Min=0 for 2400
	0,		// Min=0 for no parking
	-2,		// Min=Bottom Floor Emergency Power Recall Floor
	1,		// Min=1 Number of Emergency Power Cars
	0,		// Min=0 Car to return first on Emergency Power
	0,		// Min=0 Car to select first to run auto on Emergency Power
	10,		// Min=1 Retur car time-out 
	0,		// Min=0 DOB does not open door during nudging
	0,		// Min=0 Emergency Dispatch Not Enable
	0,		// Min=0 Number Cars Requested at lobby
	0,		// Min=0 Next Up Selection 0=OFF, 1=NCU DO, 2=NCU DC, 4=NCU up peak
	0,		// Min=0 Code blue car select, 0 = auto select
	0,		// Min=0 IR car select, 0 = no ir car
	0,		// Min = 0 Brake Lift Switch, 0=disable, 1=enable, 2=set gripper on fault
	0,		// Min = 0 Load Weighing anti-nuisance count (0=disabled)
	0,		// Min = 0, Fire Switch location: 0 = front, 1=main rear, 2=alt rear, 3=main/alt rear 
	0,		// Min = 0, ETA min time
	0,		// Min = 0, ETA for coincident car call
	1,		// Min = 1, Video position for car 1
	1,		// Min = 1, Video position for car 2
	1,		// Min = 1, Video position for car 3
	1,		// Min = 1, Video position for car 4
	1,		// Min = 1, Video position for car 5
	1,		// Min = 1, Video position for car 6
	0,		// Min = 0, No passenger run count
	0,		// Min = 0, Independent overrides Security when set
	0,		// Min = 0, Brake pick delay time on relevel
	0,		// Min = 0, Brake cool on relevel 0 = std brake cool, 1 = brake cool immediately (produce partial brake lift)
	0,		// Min = 0, Up peak trigger time
	1,		// Min = 1, Up Peak trigger count
	1,		// Min = 1, Up Peak car call count
	0,		// Min = 0, Up Peak Duration time
	0,		// Min = 0, Down Peak trigger time
	1,		// Min = 1, Down Peak trigger count
	0,		// Min = 0, Down Peak Duration time
	0,		// Min = 0, Parking Delay time
	0,		// Min = 0, Hall call cross assignment, 0 = 0FF, 1 = ON
	0,		// Min = 0, Hall Call cross assignment ETA
	-2,		// Min = 1, Medical Emergency Floor
	0,		// Min = 0, Medical Emergency Switch location 0 = front, 1= rear
	0,		// Min = 0, Fire service Motor room sensor return floor: 0=main 1 = alt
	0,		// Min = 0, Fire service hoistway sensor return floor: 0=main 1 = alt 
	0,		// Min = 0, Phase 1 fire recall reset: 0 = after recall, 1=immediate, +2=FS only reset from OFF
	5,		// Min = 5, Accel and decel limit at final stop
	0,		// Min=0 Pattern Delay Relevel
	0,		// Min = 0, Delay start until drive on
	0,		// Min = 0, Brake Opto Trigger delay
	0,		// Min = 0, 0 - Brake lift switch normally open, 1 - Brake lift switch normally closed
	0,		// Min = 0, 0 - In-service light on when car is in service, 1 - In-service light on when car is out of service
	0,		// Min = 0, Ability to change a car other than 1 or 2 to become the master
	0,		// Min = 0, if set to zero then do not time out, if set to non-zero then time-out video display
	0,		// Min = 0, if set to zero then do not turn on DC output while trying to run on inspection
	0,		// Min = 0, number of floors for parking floor 1
	0,		// Min = 0, number of floors for parking floor 2
	0,		// Min = 0, number of floors for parking floor 3	 
	0,		// Min = 0, number of floors for parking floor 4
	0,		// Min = 0, number of floors for parking floor 5
	0,		// Min = 0, number of floors for parking width
	0,		// Min = 0, Balanced load percent
	0,		// Min = 0, Drive starting Torque Multiplier
	0,		// Min = 0, Load bypass percent  0% = disabled
	0,		// Min = 0, Load antinuisance percent  0% = disabled
	0,		// Min = 0, Load dispatch percent  0% = disabled
	0,		// Min = 0, Load overload percent  0% = disabled
	0,		// Min = 0, IR control flag
	20,		// Min = 20, Brake pick voltage	 110
	1,		// Min = 0, Brake pick duration time
	20,		// Min = 20, Brake hold voltage
	10,		// Min = 10, Brake Relevel Voltage
	80,		// Min = 80, Brake Ac line to line voltage
	1,		// Min = .01, Brake resistance
	0,		// Min = 0, Attendant buzzer delay time
	0,		// Min = 0, Hall Fire Aux. Switch
	0,		// Min = 0, Fire service override or phase 1 in effect
	0,		// Min = 0, COP/Remote CC Select 0=both,1=Seperate,+2=COP->Remote,+4=Remote->COP Ack Light
	0,		// Min = 0, Door open or close delay time
	0,		// Min = 0, Security Recall: 1=recall to lobby, +2=cycle front door, +4=cycle rear door
	0,		// Min = 0, DOB overrides Security when 1.
	0,		// Min = 0, Manual Door Buzzer Delay
	0,		// Min = 0, Security Floor	(allow to be zero to secure all floors
	0,		// Min = 0, retiring cam pick delay timer
	0,		// Min = 0, short door time
	0,		// Min = 0, Second IR car select
	0,		// Min = 0, Stop at lobby
	0,		// Min = 0, Invert Cab light fan
	0,		// Min = 0, Invert Temperature Low switch (tpl)
	0,		// Min = 0, Invert Low Pressure Switch
	0,		// Min = 0, Invert Low Oil Switch
	0,		// Min = 0, Nudging with no onward call
	0,		// Min = 0, Fire Option flag
	0,		// Min = 0, Attendant Car Call
	10,		// Min = 1.0, Code blue door open time
	0,		// Min = 0, Request Ind car for code blue
	0,		// Min = 0, Flash light on code blue
	0,		// Min = 0, Hospital Service door close on car call
	0,		// Min = 0, Gripper reset time
	0,		// Min = 0, Independent door close on car call
	0,		// Min = 0.00 Torque offset
	0,		// Min = 0, Gripper test from safety processor board speed and overspeed.
	0,		// Min = 0, Single automatic pushbutton control
	0,		// Min = 0, Door Open when DOL signal not active
	0,		// Min = 0, Previously: fvdisglt - Disable Gate and Lock Test for New York City
	0,		// Min = 0.0 Relevel Start Speed
	80,		// Min = 80 Emergency Decel Rate
	0,		// Min = 0, Disable DCB cancel door time
	0,		// Min = 0, Return to lobby option, +1 = cycle door, +2 = cancel car calls, +4 = cycle door on reversal
	1,		// Min = 1, Video position for car 7
	1,		// Min = 1, Video position for car 8
	0,		// Min = 0, Parking type 0 = busy floor park, 1 = divide hoistway, 2 = fixed park
	0,		// Min = 29, number of floors for parking floor 4
	0,		// Min = 29, number of floors for parking floor 5
	0,		// Min = 0, Non-Simultaneous Doors = 1 (front first), 2 = rear first
	0,		// Min = 0, Pre-open doors = 1, 0 = no preopen, +2 = no predo shortfl.
	80,		// Min = 80, Over speed precent
	0,		// Min = 0, Position pulse count update, +1 = enable, +2 use dz int
	1,		// Min = 1, Position pulse delay error
	0,		// Min = 0, Gripper buzzer, 1 = enable	 
	0,		// Min = 0, Relevel delay time
	0,		// Min = 0, Fire OPtion 2, +1= ph2 recall open door first, +2 blink disable ph2
	0,		// Min = 0, Close gate on swing door with no preference
	3,		// Min = 3, Leveling fault count
	0,		// Min = 0, Torque amount for down direction
	0,		// Min = 0, Ramp torque time during pattern delay
	0,		// Min=0.0,  Electric Eye time-out Time
	0,		// Min = 0, Cars out of service hall call cancel, 1 = enable
	0,		// Min = 0, Nudging Ctl 1=Disable Nudging Output, +2=reopen door on ee or se, +4 = buz blocked door
	100,	// Min = 10.0, Fire phase1 door time-out (ind and att).
	0,		// Min = 0, No hall call button door reopen with onward call
	1,		// Min = 1, Drive ready reset count
	10,		// Min = 1.0, Return to Lobby Door Dwell Time
	0,		// Min = 0, Next Up Lobby Lantern control 1=Turn off hall lantern, 2=turn off cab lantern
	0,		// Min = 0, Next Up Preference Control 0=Keep until DCL, 1 = after ncu time
	0,		// Min = 0, Second Riser Control, 1 = SR Cars Std HC no assign, 2 = Or SR with std riser
	0,		// Min = 0, Second Riser Lantern Control, 1=Cab Lant on SR
	0,		// Min = 0, Attendant ETA preference time

	0,		// Min = 0, Handicap buzzer disabled at non valid floor	 
	10,		// Min = 1.0, Vip door open time
	0,		// Min = 0, Vip Operation Flags +1=Cancel HC if no cars, +2=Cancel car calls 1st
	0,		// Min = 0, Number of VIP cars
	0,		// Min = 0, Emergency Power Op LED function
	0,		// Min = 0, Emergency Power Park LED Function
	0,		// Min = 0, Elevator Off Options: +1=Recall, +2=Keep Door Open, +4=Turn off CLF
	0,		// Min = 0, Drive baud rate: 0=19200, 1=38400, 2=57600, 3=115200, 4=9600
	0,		// Min = 0, Drive update rate: 0 = 10 msec, 1 = 15 msec, 2 = 20 msec 
	1,		// Min = 1, Alternate Lobby Floor
	1,		// Min = 1, Alternate Parking Floor
	0,		// Min = 0, Lobby Request Control 1=NCU
	0,		// Min = 0, Handicap Car Capacity
	10,		// Min = 1.0, Freight door close time-out
	0,		// Min = 0, Handicap Car wait time
	100,	// Min = 10.0, Short floor distance in inches
	0,		// Min = 0, Retiring Cam Control: +1=Hold retiring cam if door pilot at the floor, +2=advance auto door
	0,		// Min = 0, Recall from fire alternate floor
	10,		// Min = 0, Auto learn hoistway stall time
	0,		// Min = 0, Position Pulse Count Error
	0,		// Min = 0, Attendant buzzer if set to zero buzzer will be continously on
	10,		// Min = 1.0, Attendant buzzer time it stays on
	0,		// Min = 0, Brake pick voltage rate time
	0,		// Min = 0, Brake relevel voltage rate time
	0,		// Min = 0, Brake Pick Start Voltage
	0,		// Min = 0, Brake relevel Start Voltage
	0,		// Min = 0, Short floor down slowdown time
	0,		// Min = 0, Mid Short floor down slowdown time
	0,		// Min = 0, Short floor up slowdown time
	0,		// Min = 0, Mid Short floor up slowdown time
	0,		// Min = 0, Hall Switch Elevator Off return floor
	0,		// Min = 0, Service message 1 display
	0,		// Min = 0, Service message 2 display
	0,		// Min = 0, Governor Gripper Trip Control
	50,		// Min = 50, Short Floor Soft Start Jerk Rate
	50,		// Min = 50, Short Floor Acceleration
	50,		// Min = 50, Short Floor Roll Over Jerk
	50,		// Min = 50, Short Floor Decel Jerk
	50,		// Min = 50, Short Floor Decel Rate
	12,		// Min = 1.2, Short Floor Targ Dis
	0,		// Min = 0, Short floor control
	0,		// Min = 0, Security Recall Control 2: 0=out of group on first recall, 1=OoG all recalls, 2=no out of group recalls
	0,		// Min = 0.0, Emergency Power Recall Delay time
	1,		// Min = 1, Group car call security override time
	0,		// Min = 0.0, Emergency brake drop delay
	0,		// Min = 0.0, Emergency brake pick time
	0,		// Min = 0, Hall Call output on brightness for led
	0,		// Min = 0, Hall Call output off brightness for led
	-2,		// Min = bottom floor, Access top floor
	-2,		// Min = bottom floor, Access bottom floor
	0,		// Min = 0, Stop on position pulse
	0,		// Min = 0, Sabbath Svc restart time
	0,		// Min = 0, Power Door open relay on Time
	0,		// Min = 0, Does not Display fault automatically on LCD when fault occurs
	0,		// Min =0,  minimum password
	0,		// Min = 0, Password time-out time
	0,		// Min = 0, Behind car call cancel
	0,		// Min = 0, Door open advance door enable non-simultaneous doors
	0,		// Min = 0, Group service number of parking cars
	0,		// Min = 0, Binary preset update when position does not match
	0,		// Min = 0, Short floor hsf with no hsv high speed valve
	0,		// Min = 0, Up peak control: +1=Heavy Up
	0,		// Min = 0, Up peak pool: Cars taken out
	0,		// Min = 0, Down peak control: +1=Heavy Down
	0,		// Min = 0, Down peak pool: Cars taken out
	0,		// Min = 0, Cross Assignment Cars from old group
	0,		// Min = 0, Modbus protocol, 0-5=N1,N2,E1,E1,O1,O2 (Always 8 data bits, parity, stop bits)
	0,		// Min = 0, Fire alternate recall after fs turned off
	50,		// Min = 50, Inspection Decel Stop Rate
	0,		// Min = 0, Emergency Power Recovery Dir
	0,		// Min = 0, Brake drop voltage 
	0,		// Min = 0.0, Brake drop voltage rate time
	0,		// Min = 0, Brake Drop timing during Leveling flag
	25,		// Min = 25, Recovery Velocity fpm
	50,		// Min = 50, Emergency Deceleration to Leveling Rate
	10,		// Min = 10, Emergency Power Recovery Velocity
	0,		// Min = 0, Cycle Run time in hours 0=Off
	0,		// Min = 0, Hall Call Up On red intensity
	0,		// Min = 0, Hall Call Up Off red intensity
	0,		// Min = 0, Hall Call Up On green intensity
	0,		// Min = 0, Hall Call Up Off green intensity
	0,		// Min = 0, Hall Call Up On blue intensity
	0,		// Min = 0, Hall Call Up Off blue intensity
	0,		// Min = 0, Door Open Light control in CCS board
	0,		// Min = 0, Hall Call Button Up On Color
	0,		// Min = 0, Hall Call Button Up Off Color
	0,		// Min = 0, Hall Call Button Security Color
	0,		// Min = 0, Hall Call Button Security Light 1 = invert security, +2=flash security, +4=Master Sec Enable
	0,		// Min = 0, Hall Call Security brightness
	0,		// Min = 0, Hall Call Security red intensity
	0,		// Min = 0, Hall Call Security green intensity
	0,		// Min = 0, Hall Call Security blue intensity
	0,		// Min = 0, Fire service hoistway sensor 2 return floor: 0=main 1 = alt 
	250,	// Min = 0.250, Drive Speed Multiplier
	0,		// Min = 0, Advanced pre-torque
	0,		// Min = 0, Car Call Button On Color
	0,		// Min = 0, Car Call Button Off Color
	0,		// Min = 0, Car Call output on brightness for led	(higher number is brighter)
	0,		// Min = 0, Car Call output off brightness	for led	(higher number is brighter)
	0,		// Min = 0, Car Call On red intensity
	0,		// Min = 0, Car Call Off red intensity
	0,		// Min = 0, Car Call On green intensity
	0,		// Min = 0, Car Call Off green intensity
	0,		// Min = 0, Car Call On blue intensity
	0,		// Min = 0, Car Call Off blue intensity
	0,		// Min = 0, Car Call Button Light Control: 1 = flash security, 2=Alternate Att Flash Sequence
	0,		// Min = 0, Car Call Button Security Color
	0,		// Min = 0, Car Call Security brightness
	0,		// Min = 0, Car Call Security red intensity
	0,		// Min = 0, Car Call Security green intensity
	0,		// Min = 0, Car Call Security blue intensity
	0,		// Min = 0, Sabbath Enable control variable,  1=allow momentary ir to override sabbath, 2 = Lobby Dwell timer, 4= Lobby off
	0,		// Min = 0, Low Line Voltage (RMS value)
	0,		// Min = 0, Low Door Voltage (RMS value)
	10,		// Min = 10, Emergency Power Top Speed
	50,		// Min = 50, Emergency Power Soft Start Jerk Rate
	50,		// Min = 50, Emergency Power Acceleration
	50,		// Min = 50, Emergency Power Roll Over Jerk
	50,		// Min = 50, Emergency Power Decel Jerk
	50,		// Min = 50, Emergency Power Decel Rate
	12,		// Min = 1.2, Emergency Power Floor Targ Dis
	25,		// Min = 25, Car Top Speed
	0,		// Min = 0, Inspection Velocity from ISER output
	10,		// Min = 1.0, Emergency Power Recover to floor time
	0,		// Min = 0, Fire Light control during EP
	0,		// Min = 0, Emergency Power Manual Select Enable
	0,		// Min = 0, Fire Light control with car out of service (low pressure, eaq, stall)
	10,		// Min =10, Sabbath Door Dwell Time
	10,		// Min = 10, Sabbath Door Buzzer timer prior to doors closing
	0,		// Min = 000.0, Low Battery Capacity Level
	0,		// Min = 0, Sabbath disable control variable, +1=PI, +2=Lanterns, +4=arrow
	0,		// Min = 0, Electric Eye cancel door time
	0,		// Min = 0, Emergency power car at recall floor with door open, 0=override immediately, 1=override after time-delay
	0,		// Min = 0, Emergency power car not at recall floor with door open, 0=override immediately, 1= override after time-delay
	0,		// Min = 0, Assign parking floor to car with door open
	0,		// Min = 0, Hall lantern delay
	0,		// Min = 0, Sabbath Enable control 2 variable,  1=Lobby On, 2 = Cab Lanterns as Direction Lanterns
	0,		// Min = 0, Cab Lantern Control 1 = on door open, 2 = on dpm limit
	0,		// Min = 0, Max Door Hold time from ED input 0 = disabled
	0,		// Min = 0, Access run door close 
	0,		// Min = 0, Car Call Button Attendant Up Color
	0,		// Min = 0, Car Call Attendant Up brightness
	0,		// Min = 0, Car Call Attendant Up red intensity
	0,		// Min = 0, Car Call Attendant Up green intensity
	0,		// Min = 0, Car Call Attendant Up blue intensity
	0,		// Min = 0, Car Call Button Attendant Dn Color
	0,		// Min = 0, Car Call Attendant Dn brightness
	0,		// Min = 0, Car Call Attendant Dn red intensity
	0,		// Min = 0, Car Call Attendant Dn green intensity
	0,		// Min = 0, Car Call Attendant Dn blue intensity
	0,		// Min = 0, Fire light Color
	0,		// Min = 0, Fire light brightness
	0,		// Min = 0, Fire light red intensity
	0,		// Min = 0, Fire light green intensity
	0,		// Min = 0, Fire light blue intensity
	0,		// Min = 0, Medical light Color
	0,		// Min = 0, Medical light brightness
	0,		// Min = 0, Medical light red intensity
	0,		// Min = 0, Medical light green intensity
	0,		// Min = 0, Medical light blue intensity
	0,		// Min = 0, Emergency light Color
	0,		// Min = 0, Emergency light brightness
	0,		// Min = 0, Emergency light red intensity
	0,		// Min = 0, Emergency light green intensity
	0,		// Min = 0, Emergency light blue intensity
	0,		// Min = 0, OTS light Color
	0,		// Min = 0, OTS light brightness
	0,		// Min = 0, OTS light red intensity
	0,		// Min = 0, OTS light green intensity
	0,		// Min = 0, OTS light blue intensity
	0,		// Min = 0, Backlight Output lights Bit0: Fire, Bit1: Medical, Bit2: Emergency, Bit3: OTS, Bit4: Att Up/Dn Light
	0,		// Min = 0, Can Sync Count in 250 msec increments, 0 = no sync counts
	0,		// Min = 0, Hall Call Dn On color
	0,		// Min = 0, Hall Call Dn On brightness
	0,		// Min = 0, Hall Call Dn On red intensity
	0,		// Min = 0, Hall Call Dn On green intensity
	0,		// Min = 0, Hall Call Dn On blue intensity
	0,		// Min = 0, Hall Call Dn Off color
	0,		// Min = 0, Hall Call Dn Off brightness
	0,		// Min = 0, Hall Call Dn Off red intensity

	0,		// Min = 0, Hall Call Dn Off green intensity
	0,		// Min = 0, Hall Call Dn Off blue intensity
	0,		// Min = 0, Hall Call CB On color
	0,		// Min = 0, Hall Call CB On brightness
	0,		// Min = 0, Hall Call CB On red intensity
	0,		// Min = 0, Hall Call CB On green intensity
	0,		// Min = 0, Hall Call CB On blue intensity
	0,		// Min = 0, Hall Call Vip On color
	0,		// Min = 0, Hall Call Vip On brightness
	0,		// Min = 0, Hall Call Vip On red intensity
	0,		// Min = 0, Hall Call Vip On green intensity
	0,		// Min = 0, Hall Call Vip On blue intensity
	0,		// Min = 0, Hall Call IR Up On color
	0,		// Min = 0, Hall Call IR Up On brightness
	0,		// Min = 0, Hall Call IR Up On red intensity
	0,		// Min = 0, Hall Call IR Up On green intensity
	0,		// Min = 0, Hall Call IR Up On blue intensity
	0,		// Min = 0, Hall Call IR Up Off color
	0,		// Min = 0, Hall Call IR Up Off brightness
	0,		// Min = 0, Hall Call IR Up Off red intensity
	0,		// Min = 0, Hall Call IR Up Off green intensity
	0,		// Min = 0, Hall Call IR Up Off blue intensity
	0,		// Min = 0, Hall Call IR Dn On color
	0,		// Min = 0, Hall Call IR Dn On brightness
	0,		// Min = 0, Hall Call IR Dn On red intensity
	0,		// Min = 0, Hall Call IR Dn On green intensity
	0,		// Min = 0, Hall Call IR Dn On blue intensity
	0,		// Min = 0, Hall Call IR Dn Off color
	0,		// Min = 0, Hall Call IR Dn Off brightness
	0,		// Min = 0, Hall Call IR Dn Off red intensity
	0,		// Min = 0, Hall Call IR Dn Off green intensity
	0,		// Min = 0, Hall Call IR Dn Off blue intensity
	0,		// Min = 0, Hall Call output Up on brightness for led
	0,		// Min = 0, Hall Call output Up off brightness for led
	0,		// Min = 0, Code Blue Location: 0=CB on CB, 1 = CB on HCB, 2 = CB on IR,
	0,		// Min = 0, Vip Location 0 = vip on vip, 1 = Vip on HCB, 2 = Vip on IR
	0,		// Min = 0, IR light color control: 0=IR Color, 1=HC Color until IR activated
	0,		// Min = 0, Hall Call CB Off color
	0,		// Min = 0, Hall Call CB Off brightness
	0,		// Min = 0, Hall Call CB Off red intensity
	0,		// Min = 0, Hall Call CB Off green intensity
	0,		// Min = 0, Hall Call CB Off blue intensity
	0,		// Min = 0, Hall Call Vip Off color
	0,		// Min = 0, Hall Call Vip Off brightness
	0,		// Min = 0, Hall Call Vip Off red intensity
	0,		// Min = 0, Hall Call Vip Off green intensity
	0,		// Min = 0, Hall Call Vip Off blue intensity
	0,		// Max = 0, Vip lantern control: 1 = ring up and down at vip floor
	0,		// Max = 0, Group Car Call Override Control: 1=Key Switch Direct
	0,		// Min = 0, Exclusion fault 1
	0,		// Min = 0, Exclusion fault 2
	0,		// Min = 0, Exclusion fault 3
	0,		// Min = 0, Exclusion fault 4 
	0,		// Min = 0, Exclusion fault 5
	0,		// Min = 0, Exclusion fault 6 
	0,		// Min = 20, Emergency Brake Pick voltage
	0,		// Min = 20, Emergency Brake hold voltage
	0,		// Min = 0.0, Emergency Brake Pick Rate
	0,		// Min = 0.0, Emergency Brake Drop Rate
	80,		// Min = 80, Emergency Brake Ac line to line voltage

	0,		// Min = 0, Brake Opto Trigger delay
	0,		// Min = 0, Can Baud Rate, 0=115.2K, 1=57.6K
	0,		// Min = 0, Car call arrival, 1 = activate lant/gong without onward call
	0,		// Min = 0, Code blue second riser car select, 0 = auto select
	0,		// Min = 0, Code blue over IR car
	0,		// Min = 0, IR Car Code Blue penalty time
	0,		// Min = 0 INSEC - in security Output invert
	0,		// Min = 0, Attendant manual direction enable
	1,		// Min = 1, Encoder Debounce Interval
	2,		// Min = 2, Encoder number of samples
	1,		// Min = 0.1 Handicap buzzer on CC beep time
	0,		// Min = 0, Service UPS mode
	0,		// Min = 0, Serial port comm diag
	0,		// Min = 0, User port 2 Baud Rate
	0,		// Min = 0, Cpu timing output control
	0,		// Min = 0, Service message 3 display
	0,		// Min = 0, Hall Call assignment secure type
	0,		// Min = 0, UPS baud rate: 0=2400,1=4800,2=9600,3=19200
	0,		// Min = 0, HC Acknowledge Attendant Buzzer
	0,		// Min = 0, Second Code blue car select, 0 = auto select
	0,		// Min = 0, Elevator Off Options 2
	0,		// Min = 0, Code blue Buzzer Control
	0,		// Min = 0, Code Blue Override Independent
	0,		// Min = 0, Code Blue Recall any car
	0,		// Min = 0, Hall Elevator off override independent
	0,		// Min = 0, Car door Reopen on open lock for NYC fire service
	0,		// Min = 0.0, Power loss brake on time
	0,		// Min = 0.0, Power loss brake off time
	0,		// Min = 0, Select/Prioratize ATT car to run in emp
	0,		// Min = 0, Encoder direction for Open can encoder
	0,		// Min = 0, Emergency cars finished Recalling Output enable
	0,		// Min = 0, Out of Service Light control
	-2,		// Min = Bot Floor Floor, Extra door time Location
	1,		// Min = 1 ,Out of Service Light control
	0,		// Min = 600, Timer for OSERL no asnwering call
	0,  	// Min = 600, Timer for OSERL	car between floors
	0, 		// Min = 600, Timer for OSERL Safety String Open 
	0,		// Min = 0, Fire service hoistway sensor location
	5,		// Min = 5, Retiring cam drop fail safe delay
	50,		// Min = 50, Velocity difference 
	0,		// Min = 0, Velocity difference fault disable
	0,		// Min = 0, SPB direction fault disable
	0,		// Min = 0, Limit direction fault disable
	0,		// Min = 0, Encoder direction fault disable
	0,		// Min = 0, UL/DL direction fault disable
	0,		// Min = 0, Relevel Start Velocity Hold Time
	0,		// Min = 0, Med door open sequence for re-open: 0=Stop, 1=Constant pressure, 2=momentary to DOL
	0,		// Min = 0, Med Ind override: 0=Immediate, 1=After Delay, 2=No ovarride
	0,		// Min = 0, Code Blue Bypass Disable
	0,		// Min = 0, Extended Door PI Message
	0,		// Min = 0, Car to return first on Emergency Power feeder 2
	0,		// Min = 0, Car to select first to run auto on Emergency Power feeder 2
	0,		// Min = 0, RCM Cam out for freight
	0,		// Min = 0, Lantern preference change delay
	0,		// Min = 0, Slip velocity difference fault trip value
	0,		// Min = 0, DOB overrides DCB on phase 2
	0,		// Min = 0, Denver Fire service ammendment to close the phase 1 doors after recall and reopen from a hall call
	10,		// Min = 1.0, Denver FS phase1 dwell time
	0,		// Min = 0, Hall call security control 0 = std HC; 1 = std and SR HC ; 2 = SR HC
	0,		// Min = 0, Slip velocity difference disable
	0,		// Min = 0, Leveling fault trip. 0=drop everything, 1= set em brake or gripper
	0,		// Min = 0, Emergency Brake Switch Control 0 = don't start if brake switch does not pick, 1 = ignore brake switch on start
	0,		// unused
	0,		// unused
	0,		// unused	 484
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 489
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 494
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 499
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 504
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 509
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 514
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 519
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 524
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 529
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 534
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 539
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 544
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 549
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 554
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 559
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 564
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 569
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 574
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 579
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 584
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 589
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 594
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 599
};
int16 fvars_default[nmbfvar] = {
	15,		// default y delta time of 1.5 sec
	20,		// default fault time of 2 sec
	50,     // default reset time of 5 sec
	1,      // default double stroking lanterns enabled
	7,      // default stay on time for dbl lanterns .7 sec
	2,      // default turn off time for dbl lanterns .2 sec
	5,      // default floor passing beep time of .5 sec
	250,    // default door protection time 25 sec
	600,    // default nudge time 30 sec
	5,      // default preopening delay .5 sec
	20,     // default car call door time 2 sec
	40,     // default hall call door time 5 sec
	50,     // default lobby door time 7 sec
	250,    // default handicap extra door time 25 sec
	20,     // default non interferance time 2 sec
	1,      // default lobby floor
	1,      // default fire service main eggress
	2,      // default fire service alternate eggress
	600,    // default stall time 60 sec
	10,     // default soft stop time 1 sec
	3600,   // default generator run time 360 sec
	0,      // default break delay on start 0 sec
	1,      // default break delay on stop .2 sec
	125,    // default acceleration jerk rate 75ft/min s^2
	92,     // default acceleration rate 92ft/min s
	125,    // default deceleration jerk rate 75ft/min s^2
	92,     // default deceleration rate 92ft/min s
	120,    // default mode 7 distance 12 inch
	50,     // default leveling speed 5 fpm
	60,     // default releveling speed 6 fpm
	40,     // default inspection speed 40 fpm
	0,      // default year
	0,      // default month
	0,      // default day
	0,      // default hour
	0,      // default minute
	125,    // default acceleration rounding jerk rate
	0,      // default EE memory Size 0 = 32K, 1 = 8K (previously - diagnostic led's 0 to disable 1 to enable)
	0,      // default service protection time year
	0,      // default service protection time month
	0,      // default service protection time day
	0,      // default speed pattern delay
	110,	// default Field Weakening percent of velocity start
	2048,	// default Encoder PPR
	1050,	// default Encoder RPM
	0,		// default (baud rate) past from pwrup routine
	1,		// default park one car
	1,		// default Emergency Power Recall Floor
	1,		// default Number of Cars to Run on Emergency Power
	1,		// default First car to return on Emergency Power
	1,		// default First car to select to run automatic on Emergency Power
	600,	// default Return Car time-out 60 second default
	0,		// default DOB does not open door during nudging
	0,		// default Emergency Dispatch Not Enable
	0,		// default Number Cars Requested at lobby
	0,		// default Next Up Selection 0=OFF, 1=NCU DO, 2=NCU DC, 4=NCU up peak
	0,		// default Code blue car select, 0 = auto select
	0,		// default IR car select, 0 = no ir car
	1,		// default Brake Lift Switch, 0=disable, 1=enable, 2=set gripper on fault
	0,		// default Load Weighing anti-nuisance count  0=disabled
	0,		// default Fire Switch location: 0 = front, 1=main rear, 2=alt rear, 3=main/alt rear 
	6,		// default ETA min time
	15,		// default ETA for coincident car call
	1,		// default Video position for car 1
	2,		// default Video position for car 2
	3,		// default Video position for car 3
	4,		// default Video position for car 4
	5,		// default Video position for car 5
	6,		// default Video position for car 6
	0,		// default No passenger run count
	0,		// default Independent overrides Security when set
	0,		// default Brake pick delay time on relevel
	0,		// default Brake cool on relevel 0 = std brake cool, 1 = brake cool immediately (produce partial brake lift)
	600,	// default Up peak trigger time 60 sec
	3,		// default Up Peak trigger count
	3,		// default Up Peak car call count
	1800,	// default Up Peak Duration time 3 min
	600,	// default Down Peak trigger time 60 sec
	12,		// default Down Peak trigger count
	1800,	// default Down Peak Duration time 3 min
	80,		// default Parking delay time 4 seconds
	0,		// default Hall call cross assignment, 0 = 0FF, 1 = ON
	60,		// default Hall Call cross assignment ETA
	1,		// default Medical Emergency Floor
	0,		// default Medical Emergency Switch location 0 = front, 1= rear
	0,		// default Fire service Motor room sensor return floor: 0=main 1 = alt
	0,		// default Fire service hoistway sensor return floor: 0=main 1 = alt 
	0,		// default Phase 1 fire recall reset: 0 = after recall, 1=immediate, +2=FS only reset from OFF
	50,		// default Accel and decel limit at final stop
	0,      // default speed pattern delay relevel
	0,		// default Delay start until drive on
	
	5500,   // default Brake Opto Trigger delay
	0,		// default Invert logic of brake lift switch
	0,		// default Invert in-service light output
	0,		// default Ability to change a car other than 1 or 2 to become the master
	0,		// default if set to zero then do not time out, if set to non-zero then time-out video display
	0,		// default Turn on DC output if trying to run on inspection
	0,		// default Parking floor 1
	0,		// default Parking floor 2
	0,		// default Parking floor 3
	0,		// default Parking floor 4
	0,		// default Parking floor 5
	0,		// default Parking width
	400,	// default Balanced load percent 40.0%
	0,		// default Drive starting Torque Multiplier
	60,		// default Load bypass percent  0% = disabled
	20,		// default Load antinuisance percent  0% = disabled
	40,		// default Load dispatch percent  0% = disabled
	110,	// default Load overload percent  0% = disabled
	0,		// default IR control flag
	230,	// default Brake pick voltage	 110
	30,		// default Brake pick duration time
	160,	// default Brake hold voltage
	230,	// default Brake Relevel Voltage
	240,	// default Brake Ac line to line voltage
	2830,	// default Brake resistance
	600,  	// default Attendant buzzer delay time
	0,		// default Hall Fire Aux. Switch
	0,		// default Fire service override or phase 1 in effect
	0,		// default Remote Car Call/COP car call select, 0=Both, 1=seperate
	0,		// default Door open or close delay time
	0,		// default Security Recall: 1=recall to lobby, +2=cycle front door, +4=cycle rear door	
	0,		// default DOB overrides Security when 1.
	0,		// default Manual Door Buzzer Delay
	1,		// default Security floor
	0,		// default retiring cam pick delay timer
	10,		// default short door time
	0,		// default Second IR car select
	0,		// default Stop at lobby
	1,		// default Invert cab light fan
	0,		// default Invert Temperature Low switch (tpl)
	0,		// default Invert Low Pressure Switch
	0,		// default Invert Low Oil Switch
	0,		// default Nudging with no onward call
	0,		// default Fire Option flag
	0,		// default Attendant Car Call
	600,	// default Code blue door open time
	0,		// default Request Ind car for code blue
	0,		// default Flash light on code blue
	0,		// default Hospital Service door close on car call
	40,		// default Gripper reset time
	0,		// default Independent door close on car call
	0,		// default Torque offset
	7,		// default Gripper test from safety processor board speed and overspeed.
	0,		// default Single automatic pushbutton control
	0,		// default Door Open when DOL signal not active
	0,		// default Previously: fvdisglt - Disable Gate and Lock Test for New York City
	0,		// default Relevel start speed 0fpm
	180,	// default Emergency Decel Rate	(3 fps^2)
	0,		// default Disable DCB cancel door time
	0,		// default Return to lobby option, +1 = cycle door, +2 = cancel car calls, +4 = cycle door on reversal
	7,		// default Video position for car 7
	8,		// default Video position for car 8
	0,		// default Parking type 0 = busy floor park, 1 = divide hoistway, 2 = fixed park
	0,		// default Parking floor 6
	0,		// default Parking floor 7
	0,		// default Non-Simultaneous Doors = 1 (front first), 2 = rear first
	0,		// default Pre-open doors = 1, 0 = no preopen, +2 = no predo shortfl.
	110,	// default Over speed precent
	0,		// default Position pulse count update, +1 = enable, +2 use dz int
	5000,	// default Position pulse delay error
	0,		// default Gripper buzzer, 1 = enable	 
	10,		// default Relevel delay time
	1,		// default Fire OPtion 2, +1= ph2 recall open door first, +2 blink disable ph2
	0,		// default Close gate on swing door with no preference
	3,		// default Leveling fault count
	0,		// default Torque amount for down direction
	0,		// default Ramp torque time during pattern delay
	400,     //default  default electric eye time-out time 30 sec
	0,		// default Cars out of service no hall call cancel, 1 = enable
	0,		// default Nudging Ctl 1=Disable Nudging Output, +2=reopen door on ee or se, +4 = buz blocked door
	200,	// default Fire phase1 door time-out (ind and att).
	0,		// default No hall call button door reopen with onward call
	5,		// default Drive ready reset count
	80,		// default Return to Lobby Door Dwell Time
	0,		// default Next Up Lobby Lantern control 1=Turn off hall lantern, 2=turn off cab lantern
	0,		// default Next Up Preference Control 0=Keep until DCL, 1 = after ncu time
	0,		// default Second Riser Control, 1 = SR Cars Std HC no assign, 2 = Or SR with std riser
	0,		// default Second Riser Lantern Control, 1=Cab Lant on SR
	0,		// default Attendant ETA preference time
	
	0,		// default Handicap buzzer disabled at non valid floor	 
	200,	// default Vip door open time
	0,		// default Vip Operation Flags +1=Cancel HC if no cars, +2=Cancel car calls 1st
	1,		// default Number of VIP cars
	0,		// default Emergency Power Op LED function
	0,		// default Emergency Power Park LED Function
	0,		// default Elevator Off Options: +1=Recall, +2=Keep Door Open, +4=Turn off CLF
	0,		// default Drive baud rate: 0=19200, 1=38400, 2=57600, 3=115200, 4=9600
	0,		// default Drive update rate: 0 = 10 msec, 1 = 15 msec, 2 = 20 msec 
	1,		// default Alternate Lobby Floor
	1,		// default Alternate Parking Floor
	0,		// default Lobby Request Control 1=NCU
	40,		// default Handicap Car Capacity above 40%
	10,     // default Freight door close time-out
	0,		// default Handicap Car wait time
	300,	// default Short floor distance in inches
	0,		// default Retiring Cam Control: +1=Hold retiring cam if door pilot at the floor, +2=advance auto door
	0,		// default Recall from fire alternate floor
	300,	// default Auto learn hoistway stall time
	100,	// default Position Pulse Count Error
	0,		// default Attendant buzzer timer min=0 max=30.0,0=alwayson[on by fvattbzon off by fvattbzoff]
	50,		// default Attendant buzzer timer min=0 max=30.0,0=alwayson[on by fvattbzon off by fvattbzoff]
	0,		// default Brake pick voltage rate time
	0,		// default Brake relevel voltage rate time
	0,		// default Brake Pick Start Voltage
	0,		// default Brake relevel Start Voltage
	0,		// default Short floor down slowdown time
	0,		// default Mid Short floor down slowdown time
	0,		// default Short floor up slowdown time
	0,		// default Mid Short floor up slowdown time
	0,		// default Hall Switch Elevator Off return floor
	0,		// default Service message 1 display
	0,		// default Service message 2 display
	0,		// default Governor Gripper Trip Control
	125,    // default default short floor acceleration jerk rate 125ft/min s^2
	92,     // default default short floor acceleration rate 92ft/min s
	125,    // default default short floor acceleration rounding jerk rate
	125,    // default default short floor deceleration jerk rate 124 ft/min s^2
	92,     // default default short floor deceleration rate 92ft/min s
	80,     // default default mode 7 short floor distance 8 inch
	0,		// default Short floor control
	0,		// default Security Recall Control 2: 0=out of group on first recall, 1=OoG all recalls, 2=no out of group recalls
	150,	// default Emergency Power Recall Delay time
	60,		// default Group car call security override time
	0,		// default Emergency brake drop delay
	30,		// default Emergency brake pick time
   1000,	// default Hall Call output on brightness for led
	200,	// default Hall Call output off brightness for led
	2,		// default Access top floor
	1,		// default Access bottom floor
	0,		// default Stop on position pulse
	80,		// default Sabbath Svc restart time
	20,		// default Power Door open relay on Time
	0,		// default Does not Display fault automatically on LCD when fault occurs
	0,		// default Password
	3000, 	// default Password time-out time  5 minutes
	0,		// default Behind car call cancel
	0,		// default Door open advance door enable non-simultaneous doors
	0,		// default Group service number of parking cars
	0,		// default Binary preset update when position does not match
	0,		// default Short floor hsf with no hsv high speed valve
	0,		// default Up peak control: +1=Heavy Up
	1,		// default Up peak pool: Cars taken out
	0,		// default Down peak control: +1=Heavy Down
	0,		// default Down peak pool: Cars taken out
	0,		// default Cross Assignment Cars from old group
	0,		// default Modbus protocol, 0-5=N1,N2,E1,E1,O1,O2 (Always 8 data bits, parity, stop bits)
	0,		// default Fire alternate recall after fs turned off
	300,	// default Inspection Decel Stop Rate
	0,		// default Emergency Power Recovery Direction
	0,		// default Brake drop voltage 
	0,		// default Brake drop voltage rate time
	0,		// default Brake Drop timing during Leveling flag
	25,		// default Recovery Velocity fpm
	100,	// default Emergency Deceleration to Leveling Rate
	25,		// default Emergency Power Recovery Velocity
	0,		// default Cycle Run time in hours
	625,	// default Hall Call Up On red intensity
	625,	// default Hall Call Up Off red intensity
    1000,	// default Hall Call Up On green intensity
	1000,	// default Hall Call Up Off green intensity
	500,	// default Hall Call Up On blue intensity
	500,	// default Hall Call UP Off blue intensity
	0,		// default Door Open Light control in CCS board
	15,		// default Hall Call Button Up On Color
	15,		// default Hall Call Button Up Off Color
	15,		// default Hall Call Button Security Color
	0,		// default Hall Call Button Security Light 1 = invert security, +2=flash security, +4=Master Sec Enable
	1000,	// default Hall Call Security brightness
	1000,	// default Hall Call Security red intensity
	0,		// default Hall Call Security green intensity
	1000,	// default Hall Call Security blue intensity
	0,		// default Fire service hoistway sensor 2 return floor: 0=main 1 = alt 
	1000,	// default Drive Speed Multiplier
	0,		// default Advanced pre-torque
	15,		// default Car Call Button On Color
	15,		// default Car Call Button Off Color
	1000,	// default Car Call output on brightness for led	(higher number is brighter)
	200, 	// default Car Call output off brightness	for led	(higher number is brighter)
	625, 	// default Car Call On red intensity
	625, 	// default Car Call Off red intensity
	1000,	// default Car Call On green intensity
	1000,	// default Car Call Off green intensity
	500, 	// default Car Call On blue intensity
	500, 	// default Car Call Off blue intensity
	0,		// default Car Call Button Light Control: 1 = flash security, 2=Alternate Att Flash Sequence
	15,		// default Car Call Button Security Color
	1000,	// default Car Call Security brightness
	1000, 	// default Car Call Security red intensity
	0,		// default Car Call Security green intensity
	1000,	// default Car Call Security blue intensity
	0,		// default Sabbath Enable control variable,  1=allow momentary ir to override sabbath, 2 = Lobby Dwell timer, 4= Lobby off
	1980,	// default Low Line Voltage (RMS value)
	1980,	// default Low Door Voltage (RMS value)
	100, 	// default default Emergency Power Top Speed
	125,    // default default Emergency Power acceleration jerk rate 125ft/min s^2
	92,     // default Emergency Power acceleration rate 92ft/min s
	125,    // default Emergency Power acceleration rounding jerk rate
	125,    // default Emergency Power deceleration jerk rate 124 ft/min s^2
	92,     // default Emergency Power deceleration rate 92ft/min s
	120,    // default mode 7 Emergency Power distance 12 inch
	0,		// default Car Top Speed	(default will be checked in utils...if zero it will be set to contract speed)
	0,		// default Inspection Velocity from ISER output
	200,	// default Emergency Power Recover to floor time  20.0 seconds
	1,		// default Fire Light control during EP
	1,		// default Emergency Power Manual Select Enable
	0,		// default Fire Light control with car out of service (low pressure, eaq, stall)
	100,	// default Default Sabbath Door Dwell Time 10s
	50,		// default Default Sabbath Door Buzzer timer prior to doors closing 5s
	500,	// default Low Battery Capacity Level
	0,		// default Sabbath disable control variable, +1=PI, +2=Lanterns, +4=arrow
	0,		// default Electric Eye cancel door time
	0,		// default Emergency power car at recall floor with door open, 0=override immediately, 1=override after time-delay
	0,		// default Emergency power car not at recall floor with door open, 0=override immediately, 1= override after time-delay
	0,		// default Assign parking floor to car with door open
	0,		// default Hall lantern delay
	0,		// default Sabbath Enable control 2 variable,  1=Lobby On, 2 = Cab Lanterns as Direction Lanterns
	0,		// default Cab Lantern Control 1 = on door open, 2 = on dpm limit
	0,		// default Max Door Hold time from ED input 0 = disabled
	0,		// default Access run door close
	0,		// default Car Call Button Attendant Up Color
	1000,	// default Car Call Attendant Up brightness
	0,		// default Car Call Attendant Up red intensity
	1000,	// default Car Call Attendant Up green intensity
	0,		// default Car Call Attendant Up blue intensity
	0,		// default Car Call Button Attendant Dn Color
	1000,	// default Car Call Attendant Dn brightness
	1000,	// default Car Call Attendant Dn red intensity
	0,		// default Car Call Attendant Dn green intensity
	0,		// default Car Call Attendant Dn blue intensity
	0,		// default Fire light Color
	1000,	// default Fire light brightness
	625,	// default Fire light red intensity
	1000,	// default Fire light green intensity
	500,	// default Fire light blue intensity
	0,		// default Medical light Color
	1000,	// default Medical light brightness
	0,		// default Medical light red intensity
	0,		// default Medical light green intensity
	1000,	// default Medical light blue intensity
	0,		// default Emergency light Color
	1000,	// default Emergency light brightness
	750,	// default Emergency light red intensity
	1000,	// default Emergency light green intensity
	0,		// default Emergency light blue intensity
	0,		// default OTS light Color
	1000,	// default OTS light brightness
	1000,	// default OTS light red intensity
	400,	// default OTS light green intensity
	0,		// default OTS light blue intensity
	0,		// default Backlight Output lights Bit0: Fire, Bit1: Medical, Bit2: Emergency, Bit3: OTS, Bit4: Att Up/Dn Light
	4,		// default Can Sync Count in 250 msec increments
	15,		// default Hall Call Dn On color
	1000,	// default Hall Call Dn On brightness
	625,	// default Hall Call Dn On red intensity
	1000,	// default Hall Call Dn On green intensity
	500,	// default Hall Call Dn On blue intensity
	15,		// default Hall Call Dn Off color
	200,	// default Hall Call Dn Off brightness
	625,	// default Hall Call Dn Off red intensity
	
	1000,	// default Hall Call Dn Off green intensity
	500,	// default Hall Call Dn Off blue intensity
	0,		// default Hall Call CB On color
	1000,	// default Hall Call CB On brightness
	0,		// default Hall Call CB On red intensity
	0,		// default Hall Call CB On green intensity
	1000,	// default Hall Call CB On blue intensity
	0,		// default Hall Call Vip On color
	1000,	// default Hall Call Vip On brightness
	1000,	// default Hall Call Vip On red intensity
	400,	// default Hall Call Vip On green intensity
	0,		// default Hall Call Vip On blue intensity
	15,		// default Hall Call IR Up On color
	1000,	// default Hall Call IR Up On brightness
	625,	// default Hall Call IR Up On red intensity
	1000,	// default Hall Call IR Up On green intensity
	500,	// default Hall Call IR Up On blue intensity
	15,		// default Hall Call IR Up Off color
	200,	// default Hall Call IR Up Off brightness
	625,	// default Hall Call IR Up Off red intensity
	1000,	// default Hall Call IR Up Off green intensity
	500,	// default Hall Call IR Up Off blue intensity
	15,		// default Hall Call IR Dn On color
	1000,	// default Hall Call IR Dn On brightness
	625,	// default Hall Call IR Dn On red intensity
	1000,	// default Hall Call IR Dn On green intensity
	500,	// default Hall Call IR Dn On blue intensity
	15,		// default Hall Call IR Dn Off color
	200,	// default Hall Call IR Dn Off brightness
	625,	// default Hall Call IR Dn Off red intensity
	1000,	// default Hall Call IR Dn Off green intensity
	500,	// default Hall Call IR Dn Off blue intensity
   1000,	// default Hall Call output Up on brightness for led
	200,	// default Hall Call output Up off brightness for led
	0,		// default Code Blue Location: 0=CB on CB, 1 = CB on HCB, 2 = CB on IR,
	0,		// default Vip Location 0 = vip on vip, 1 = Vip on HCB, 2 = Vip on IR
	0,		// default IR light color control: 0=IR Color, 1=HC Color until IR activated
	0,		// default Hall Call CB Off color
	200,	// default Hall Call CB Off brightness
	0,		// default Hall Call CB Off red intensity
	0,		// default Hall Call CB Off green intensity
	1000,	// default Hall Call CB Off blue intensity
	0,		// default Hall Call Vip Off color
	200,	// default Hall Call Vip Off brightness
	1000,	// default Hall Call Vip Off red intensity
	400,	// default Hall Call Vip Off green intensity
	0,		// default Hall Call Vip Off blue intensity
	0,		// default Vip lantern control: 1 = ring up and down at vip floor
	0,		// default Group Car Call Override Control: 1=Key Switch Direct
	0,		// default Exclusion fault 1
	0,		// default Exclusion fault 2 
	0,		// default Exclusion fault 3
	0,		// default Exclusion fault 4 
	0,		// default Exclusion fault 5
	0,		// default Exclusion fault 6 
	230,	// default Emergency Brake Pick voltage
	160,	// default Emergency Brake hold voltage
	0,		// default Emergency Brake Pick Rate
	0,		// default Emergency Brake Drop Rate
	240,	// default Emergency Brake Ac line to line voltage
	5500,   // default Brake Opto Trigger delay
	0,		// default Can Baud Rate, 0=115.2K, 1=57.6K
	0,		// default Car call arrival, 1 = activate lant/gong without onward call
	0,		// default Code blue second riser car selection, 0 = auto select
	0,		// default Code blue over IR car
	10,		// default IR Car Code Blue penalty time
	0,		// default INSEC - in security Output invert
	0,		// default Attendant manual direction enable
	3,		// default Encoder Debounce Interval
	10,		// default Encoder number of samples
	2,		// default Handicap buzzer on CC beep time
	0,		// default Service UPS mode
	0,		// default Serial port comm diag
	0,		// default User port 2 Baud Rate
	0,		// default Cpu timing output control
	0,		// default Service message 3 display
	0,		// default Hall Call assignment secure type
	2,		// default UPS baud rate: 0=2400,1=4800,2=9600,3=19200
	0,		// default HC Acknowledge Attendant Buzzer
	0,		// default Second Code blue car select, 0 = auto select
	0,		// default Elevator Off Options 2
	0,		// default Code blue Buzzer Control
	0,		// default Code Blue Override Independent
	0,		// default Code Blue Recall any car
	0,		// default Hall Elevator off override independent
	0,		// default Car door Reopen on open lock for NYC fire service
	10,		// default Power loss brake on time
	0,		// default Power loss brake off time
	0,		// default Select/Prioratize ATT car to run in emp
	0,		// default Encoder direction for Open can encoder
	0,		// default Emergency cars finished Recalling Output enable
	0,		// default Out of Service Light control
	1,		// default Floor, Extra door time Location
	0,		// default Out of Service Light control
	6000,	// default Timer for OSERL no asnwering call
	600,	// default Timer for OSERL car between floors
	600,	// default Timer for OSERL Safety String Open 
	50,		// default Fire service hoistway sensor location
	5,		// default Retiring cam drop fail safe delay
	150,	// default Velocity difference 
	0,		// default Velocity difference fault disable	(enabled)
	0,		// default SPB direction fault disable (enabled)
	0,		// default Limit direction fault disable (enabled)
	0,		// default Encoder direction fault disable (enabled)
	0,		// default UL/DL direction fault disable
	0,		// default Relevel Start Velocity Hold Time
	0,		// default Med door open sequence for re-open: 0=Constant pressure, 1=momentary to dol
	0,		// default Med Ind override: 0=Immediate, 1=After Delay, 2=No ovarride
	0,		// Default Code Blue Bypass Disable
	0,		// Default Extended Door PI Message
	2,		// default First car to return on Emergency Power feeder 2
	2,		// default First car to select to run automatic on Emergency Power feeder 2
	0,		// Default RCM Cam out for freight
	0,		// default Lantern preference change delay
	150,	// default Slip velocity difference fault trip value
	0,		// default DOB overrides DCB on phase 2
	0,		// default Denver Fire service ammendment to close the phase 1 doors after recall and reopen from a hall call
	600,	// default Denver FS phase1 dwell time
	0,		// default Hall call security control 0 = std HC; 1 = std and SR HC ; 2 = SR HC
	0,		// default Slip velocity difference disable
	0,		// default Leveling fault trip. 0=drop everything, 1= set em brake or gripper
	0,		// default Emergency Brake Switch Control 0 = don't start if brake switch does not pick, 1 = ignore brake switch on start
	0,		// unused
	0,		// unused
	0,		// unused	 484
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 489
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 494
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 499
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 504
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 509
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 514
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 519
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 524
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 529
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 534
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 539
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 544
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 549
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 554
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 559
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 564
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 569
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 574
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 579
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 584
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 589
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 594
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused
	0,		// unused	 599
};

int16 tout_A, tout_B, tout_C;
int16 DIO1_in;
int16 DIO1_in_dbn;
int16 DIO2_out;

extern const int32 fl_mask[65] =   	// Note: this table starts at floor 0
{0,0x00000001L,0x00000002L,0x00000004L,0x00000008L,0x00000010L,0x00000020L,0x00000040L,0x00000080L,
   0x00000100L,0x00000200L,0x00000400L,0x00000800L,0x00001000L,0x00002000L,0x00004000L,0x00008000L,
   0x00010000L,0x00020000L,0x00040000L,0x00080000L,0x00100000L,0x00200000L,0x00400000L,0x00800000L,
   0x01000000L,0x02000000L,0x04000000L,0x08000000L,0x10000000L,0x20000000L,0x40000000L,0x80000000L,
   0x00000001L,0x00000002L,0x00000004L,0x00000008L,0x00000010L,0x00000020L,0x00000040L,0x00000080L,
   0x00000100L,0x00000200L,0x00000400L,0x00000800L,0x00001000L,0x00002000L,0x00004000L,0x00008000L,
   0x00010000L,0x00020000L,0x00040000L,0x00080000L,0x00100000L,0x00200000L,0x00400000L,0x00800000L,
   0x01000000L,0x02000000L,0x04000000L,0x08000000L,0x10000000L,0x20000000L,0x40000000L,0x80000000L,
   };

void init_control(void);
void control(void);


// Prototypes of all the functions control.cc
void atfloor(void );
int16 car_gate(void);
int16 chk_start(int16 cmd);
int16 chk_lev_start(int16 cmd);
void chkrun(void );
void clrall(void );
void clr_dir_arrow (void);
void clrlant(void );
void cycle_run(void);
void diag(void);
void dirsel(void );
void elevator_off (void);
void jail_break(void);
int16 ep_recall_ok(void);
void epr_dir(void);
void epr_set_power(void);
void dog_ints_off(void);
void dog_ints_on(void);
int16 door_locks(void);
int16 get_valid_fl(int16 pos, int16 dir);
void set_grp_io (void);
void hlants(void );
void hydro_control (void);
void status_control (int16 start_ck);
void output_control (int16 start_ck);
void set_grp_io (void);
void comm_control (void);
void door_control (int16 start_ck);
void light_buzzer_control (int16 start_ck);
void chk_motion_fault (int16 start_ck);
void security_control (int16 start_ck);
void encoder_control (int16 start_ck);
void inctime(int16 start_ck );
int16 ind (void);
void inttim(void);
void inittim(void );
void initial_stop (void);
void init_ram_data(void);
void key_ots(void );
void stall(void );
void low_pressure(void);
int16 main(int16 _argc, char *_argv[] );
int16 man_dcc(void);
int16 man_fdcc(void);
int16 man_rdcc(void);
void motion(void );
int16 needstop(void );
void pisout( int16);
void prt_scr(void);
void record_fault (uint16 code);
extern void rdfvar(void );
void reset(void );
void close_doors_during_reset(int16 force_close);
void set_door_close_during_reset(void);
void reset_jack (void);
void return_to_lobby(void);
int16 safe(void);
void set_safe_fault(void);
int16 access_door_safe(void);
void sstring(void );
int16 safeties (void);
void set_ss_fault (void);
void setfsf(void );
void seteqf(void);
void setempf(void);
void sethugsf(void);
void settugf(void); 
void setmedf(void);
void setcodebf (void);
void sethsvf(void);
void setvipf (void);
void set_ul_dl(void);
void setpref(void );
void set_position(int16 dir);
int16 set_position_from_selector(void);
void preset_selector_position(void);
int16 set_position_from_encoder(void);
void set_dir_arrow (void);
#if (Traction == 1) || (Tract_OL == 1)
void verify_limit_seq (int16 init_flag);
void verify_uldl_seq(int16 init_flag);
#endif

void set_rcm(void);
void set_scnd_position(void);

static union {
		uint8 b[4];			// byte: char 0 - 3
		uint32 dw;			// double word: int
	}uiu;					// unsigned integer union
		
 
void init_control(void)
{
	int16 i;
	
	
	disable_dog();
 	init_rtc(cpu_Z6);
	
  	local_getdate(cpu_Z6);

	if (d.year > 3000)
	{
		d.year = 3000;
		local_setdate(cpu_Z6);
	}

  	day_of_week = calc_dayofweek();

	if ((day_of_week != d.dayofweek) || (d.dayofweek > 6))
		local_setdate(cpu_Z6);	// update day of the week  (calc_dayofweek() is called in local_setdate())
  	day_of_week = d.dayofweek;
  	old_day_of_week = day_of_week;

 	init_sdspi();		// Init hardware for SD Card

  	zero_req_que();
  	zero_status_que();

	keybrd_init();		// initialize keyboard and redirect interrupt
	
  	init_LCD();

	enable_dog();
  	position = 2;
  	petdog();
  	rdcons();     // Initialize all of the constants that define the job
  	position = (cons[topf] - 1);
  	petdog();
  	rdfvar();     // Initialize all of the field adjustable varriables
  	petdog();
  	rdflts(cpu_Z6);     // Initialize the fault log
  	petdog();
  	init_LT_flts_ix(cpu_Z6);
  	petdog();
	test_hardware();	// set error and hardware_init_fault flag
  	petdog();
	if (test_1036_hardware() == 1)
	{
		run_hold_1036 = 1;			// prevent car from running
		statusf2 |= sf_1036;
	}
	petdog();
	init_call_data(cpu_Z6);
  	petdog();
	sys_stat_init(cpu_Z6);
  	petdog();
#if (Traction == 1)
	Init_Encoder();
  	Init_Hoistway(cpu_Z6); // initializing the hoist way digital pulse tables
	Dmd_Velocity = 0;
	
	DAC_Out();
	// reset trace variables for pulse update
	max_error_count = (int32)(Pulses_per_Inch * 1.0);
	for(i=0;i<=fl_size;i++)
		DPP_updf[i] = 0;

  	petdog();
#endif

#if(Security == 1)
  	Security_Init();    // initializing security data
  	petdog();
#endif
  	if(cons[rear] == 0)
  	{
		  for(i=1; i<= cons[topf]; i++)
		  {
			  rcarcb[i] = 0;
			  rdowncb[i] = 0;
			  rupcb[i] = 0;
		  }
  	}
  	petdog();

	if (cons[cc_pb_sec] == 1)
		Init_Code_Check_Table(cpu_Z6);

  	petdog();

	init_ram_data();

  	io_init();

	if (Drive_Type[cons[carnmb]] == 9)
		setoutp(o_MST);

 	init_can_bus();
 	
 	petdog();
 	
 	init_dpyspi();
 	
 	petdog();

	initcom();	// must be after init_can_bus() since the can bus chip provices the clock

  	petdog();

	if ((cons[ids] & 1) != 0)
		init_ids();
 
#if ((Traction == 1) || (Tract_OL == 1))

  	petdog();

	if ((cons[PWL_Brake] == 1) || ((cons[Emp_Recover] == 2) && ((cons[UPS_Type] == 1) || (cons[UPS_Type] == 2))) || (cons[Ser_IGEP] == 1))
		sx_initcom();

#endif

  	petdog();

  	if (cons[carnmb] == 1)
		Car_Select = 0;		// This is the group car so show the group display
  	else
		Car_Select = cons[carnmb];

  	petdog();


		// Video initialization
		
	video_exist = 0;
	disable_dog();

	Init_Video();
	video_exist = 1;

	Init_Debug_Screen(1);

	enable_dog();

  	petdog();

#if (Simulator == 1)
  	sim_init(1);
#endif


  	petdog();

	record_fault(f_pwrup_reset);   // Always set a power up reset on power up

	petdog();
	if(cons[modem] == 1)
	{
		Init_Modem(USR1COM);
		disable_dog();
		delay(500);
		Modem_Quiet_Mode(USR1COM);
		enable_dog();

		Init_Modem(USR2COM);
		disable_dog();
		delay(500);
		Modem_Quiet_Mode(USR2COM);
		enable_dog();

	}

	grp_clrhc();

	motion_fault = 0;
	reset_courion = 1;
	power_up_start_time = (cons[carnmb] - 1) * 20;		// add 2 seconds for each car
	pwr_up_reset = 1;

 	inittim();    // Zero timers - hardware setup in main
}


//*************************************************************************************
//*************************************************************************************
// Main Control Loop
//*************************************************************************************
//*************************************************************************************


void control(void)
{
  	int16 x=0;
  	
  	sendc(USR1COM,'G');
	sendc(USR1COM,'A');
	sendc(USR1COM,'L');
	sendc(USR1COM,'a');
	sendc(USR1COM,'x');
	sendc(USR1COM,'y');
	sendc(USR1COM,' ');
	sendc(USR1COM,'C');
	sendc(USR1COM,'o');
	sendc(USR1COM,'n');
	sendc(USR1COM,'t');
	sendc(USR1COM,'r');
	sendc(USR1COM,'o');
	sendc(USR1COM,'l');
	sendc(USR1COM,'s');
	sendc(USR1COM,CR);
	sendc(USR1COM,LF);
	sendc(USR1COM,'>');
	

	x = 0;
  	while(x == 0)
  	{
		inctime(0);
		
		switch(procf)
		{
			case 0:
				servf = 0;
				procf = 1;
			  	timers[treset] = 0;
		  	case 1:
				servf = 0;
				reset();
				break;
  	    	case 2:
				servf = 0;
				inspection();
				break;
  	    	case 3:
 				motion();
				break;
  	    	case 4:
				motion();
				break;
  	    	case 5:
				motion();
				break;
  	    	case 6:
				motion();
				break;
  	    	case 7:
				motion();
				break;
  	    	case 8:
				motion();
				break;
  	    	case 9:
				motion();
				break;
  	    	case 10:
				motion();
				break;
  	    	case 11:
				motion();
				break;
  	    	case 12:
				servf = 0;
				sstring();
				break;
  	    	case 13:
				servf = 0;
				key_ots();
				break;
  	    	case 14:
				atfloor();
				break;
  	    	case 15:
				atfloor();
				break;
  	    	case 16:
				atfloor();
				break;
  	    	case 17:
				servf = 14;
				stall();
				break;
	  		case 18:
#if ((Traction == 0) && (Tract_OL == 0))
				servf = 0;		// reset hydro jack
				reset_jack();
#else
				procf = 0;
#endif
				break;
			case 19:
#if ((Traction == 0) && (Tract_OL == 0))
				servf = 21;
				low_pressure();
#else
				procf = 0;
#endif
				break;

			case 20:
#if (Traction == 1)
				servf = 0;
				hoistway();
#else
				procf = 0;
#endif
				break;

			case 21:		
#if (Traction == 1)
				epr_dir();	   // emergency power recovery
#else
				procf = 0;
#endif
				break;

  	    	default:
//			  	record_fault(f_reset);
				procf = 0;      // Go to reset
				break;
  	  	}
  	}
}


// *******************************
// This is at a floor procedure
// *******************************
void atfloor()
{
	int16 tmppos=0;
#if (Traction == 1)
int16 i;
#endif

	static int prev_pref;

	prev_pref = dpref;
	timers[tlantchange] = 10;

  	if((rset != 0)  || (servf == 12) || (servf == 13))
	{
		preset_pos = 1;
		servf = 1;
	}
	handicap_buz = 0;
	if (dpref == 0)
		hb_en = 0;
    else if((dpref == 1) && (dirf != 1))
		hb_en = 0;
    else if((dpref == 2) && (dirf != 2))
		hb_en = 0;

	// Clear door close outputs	first time through
	clroutp(o_DC);
	if (cons[rear] != 0)
		clroutp(o_DCR);

	rset = 0;
	up_peak_trigger = 0;
	limit_fault = 0;
  	pfc_sfc_test = 0;
  	in_pfc_sfc_test = 0;
	SPB_can.command &= ~spbc_GR1_test;			// Clear GR1 test
	SPB_can.command &= ~spbc_SFC_test;			// Clear SFC test
	timers[tupfdnfdly] = 0;
	timers[tuldloff] = 0;
	timers[tebrkio] = 0;
	statusf &= ~sf_BPI;
	BKS_Run_Fault = 0;
	pwr_up_reset = 0;
	hold_brake_overspeed = 0;
	delta_off_flag = 0;

#if (Traction == 1)
	leveling = 0;
	level_stop_fault = 0;
	relev_stop_count = 0;
#endif
#if ((Traction == 1) || (Tract_OL == 1))	
	torque = 0;
	get_load(1);		// update load value
#endif

	if (fault_run == 1)
	{
		if (fault_run_cnt > 3)
		{	
			record_fault(f_shutdown);
			shutdown = 1;
		}
	}
	else
		fault_run_cnt = 0;

	if (fvars[fvadvpretrq] == 1)
	{
		if (adv_pre_trq_fault == 0)
			adv_pre_trq_run = 1;
		else
			adv_pre_trq_run = 0;
	}
	else
		adv_pre_trq_run = 0;

	timers[tnit] = 0;
	timers[tdoorrq] = 0;

	timers[tlimit] = 0;
	ut_limit = rdinp(i_UT);
	dt_limit = rdinp(i_DT);
	uts_limit = rdinp(i_UTS);
	dts_limit = rdinp(i_DTS);
	stp_sw = rdinp(i_STP);

	run_time = timers[tmotion];

  	while((procf >= 14) && (procf <= 16))
  	{	
		estop = 0;
	    estops_1_run = 0;

		// Keep the Soft starter motor contactor on except when testing
		if ((Drive_Type[cons[carnmb]] == 9) && (in_pfc_sfc_test == 0))
			setoutp(o_MST);

		// incrementing the timers
    	inctime(0);

		if ((rdinp(i_UT) != ut_limit) || (rdinp(i_DT) != dt_limit) || 
			(rdinp(i_UTS) != uts_limit) || (rdinp(i_DTS) != dts_limit) ||
			(rdinp(i_STP) != stp_sw) || (in_pfc_sfc_test == 1) )
			timers[tlimit] = 0;
		stp_sw = rdinp(i_STP);
		ut_limit = rdinp(i_UT);
		dt_limit = rdinp(i_DT);
		uts_limit = rdinp(i_UTS);
		dts_limit = rdinp(i_DTS);

		
		if((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1) && (reset_nonit == 1))    // dead level
   		{
			reset_nonit = 0;
			timers[tnit] = 0;
		}

#if ((Traction == 0) && (Tract_OL == 0))
		if (cons[Low_Press] == 1)
		{
			if (((rdinp(i_LPS) == 1) && 
				(fvars[fvlps] == 0)) || ((rdinp(i_LPS) == 0) && (fvars[fvlps] == 1)))
			{
				procf = 19;
				return;
			}
		}
		if ((cons[Low_Oil] == 1) && (stallf == 0) &&
			(((rdinp(i_LOS) == 1) && (fvars[fvlos] == 0)) || 
			((rdinp(i_LOS) == 0) && (fvars[fvlos] == 1))))
		{
		 	record_fault(f_lowoil_switch);
			stallf = 1;
		}
#endif

		// Testing to see if saftey string is open
    	if (safeties() == 1)
			timers[tsst] = 0;
    	else if (timers[tsst] > 3)
    	{
			if ((statusf & sf_SS) == 0)
				record_fault(f_sstring);
			statusf |= sf_SS;
      		procf = 12;       // go to saftey string open mode
      		return;
    	}
		else
			statusf &= ~sf_SS;

		// Testing to see if LC fuse is blown
    	if(rdinp(i_LC) == 1)
			timers[tlct] = 0;
    	if((rdinp(i_LC) == 0) && (timers[tlct] > 10))
    	{
			if ((statusf & sf_LC) == 0)
				record_fault(f_LC_fuse);
			statusf |= sf_LC;
			procf = 12;
			return;
    	}
		else
			statusf &= ~sf_LC;

#if((Traction == 1) || (Tract_OL == 1))

		// Testing to see if Ready from Drive Unit is open
		if((rdinp(i_READY) == 0) && (rdinp(i_GTS) == 1))
    	{
			if (timers[tdrvrdy] > 2)
			{
				if ((statusf & sf_READY) == 0)
					record_fault(f_drive_rdy);
				statusf |= sf_READY;
	      		procf = 12;       // go to saftey string open mode
	      		return;
			}
    	}
		else
		{
			statusf &= ~sf_READY;
			timers[tdrvrdy] = 0;
		}
#endif

		// Testing to see if on inspection
    	if ((chk_ins() == 1) && (safeties() == 1))
    	{
			if (timers[tinst] > 2)
			{
      			procf = 2;        // go to inspection mode
      			return;
			}
    	}
		else
			timers[tinst] = 0;

		// Testing to see if at a floor
    	if((rdinp(i_UL) == 0) && (rdinp(i_DL) == 0))
    	{
			if (timers[tuldloff] > 5)
			{			// off for more than 500 msec
				if (rdinp(i_DZ) == 1)
				{
					if (UL_DL_OFF_Fault == 0)
						record_fault(f_ul_dl_off);

				    UL_DL_OFF_Fault = 1;	
				}
				else
	      		{
					statusf |= sf_ULDLDZ;
					record_fault(f_ul_dl_dz_off);
	      			procf = 0;        // reset elevator no door zone
	   	  			return;
				}
			}
    	}
		else
		{
			timers[tuldloff] = 0;
			statusf &= ~sf_ULDLDZ;
		}

		// Check to see if the last run recorded an up or down level limit fault 
		if ((UL_ON_Fault == 1) || (DL_ON_Fault == 1) || (UL_DL_OFF_Fault == 1))
		{
			if (ignore_uldl_fault == 0)
			{
			 	if ((statusf & sf_ULDL) == 0)

			 	{
			 		if (UL_ON_Fault == 1)
			 			record_fault(f_ul_on);
			 		if (DL_ON_Fault == 1)
			 			record_fault(f_dl_on);

			 	}
				statusf |= sf_ULDL;
			}
			else
			{
				ignore_uldl_fault = 0;
				UL_ON_Fault = 0;
				DL_ON_Fault = 0;
				UL_DL_OFF_Fault = 0;
			}
		}
		else
			statusf &= ~sf_ULDL;

	  	if (((rdinp(i_DZ) == 0) || (rdinp(i_DZA) == 0)) && (relevel == 0) && (rdinp(i_LC) == 1))
	  	{													 
			if((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))    // dead level
			{
				if (rdinp(i_DZ) == 0)
				{
					if (DZ_OFF_Fault == 0)
						record_fault(f_dz_off);
					DZ_OFF_Fault = 1;
				}
				if (rdinp(i_DZA) == 0)
				{
					if (((cons[sel_type] == 2) && (sel_can_error == 0) && (can_dev[c_can_SEL - c_can_START].online == 1)) ||
						((cons[sel_type] != 2) && (toc_can_error == 0) && (can_dev[c_can_TOC - c_can_START].online == 1)))
					{
						if (DZA_OFF_Fault == 0)
							record_fault(f_dza_off);
						DZA_OFF_Fault = 1;
					}
				}
			}
		}

		if (DZA_OFF_Fault == 1)
		{
				   // Don't latch the error if it were from a can comm error
			if (((cons[sel_type] != 2) && (toc_can_error == 1)) || ((cons[sel_type] == 2) && (sel_can_error == 1)) ||
				((rdinp(i_DZA) == 1) && (rdinp(i_UL) == 1) && (rdinp(i_DL) == 1)))
				DZA_OFF_Fault = 0;
		}

		if (DZ_OFF_Fault == 1)
		{
			if ((rdinp(i_DZ) == 1) && (rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))
				DZ_OFF_Fault = 0;		// don't latch fault if input comes back on
		}

		// Check to see if the last run recorded a door zone fault 
		if ((DZ_ON_Fault == 1) || (DZA_ON_Fault == 1) || (DZ_OFF_Fault == 1) || (DZA_OFF_Fault == 1))
		{
			if ((statusf & sf_DZ) == 0)
			{
				if (DZ_ON_Fault == 1)
					record_fault(f_dz_on);
				if (DZA_ON_Fault == 1)
					record_fault(f_dza_on);
			}
			statusf |= sf_DZ;
		}
		else
			statusf &= ~sf_DZ;

	 
		// Make sure elevator not lost
    	if ((cons[BinPiIn] == 1) || (cons[sel_type] != 0))      // binary position inputs floor confirm
    	{
      		if((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))    // dead level
      		{
#if (Traction == 0)

				if ((timers[tsoftstp] > 20) && (preset == 0) && (relevel == 0))
#else
				if ((timers[tsoftstp] > 20) && (preset == 0) && (relevel == 0) && (leveling == 0))
#endif
				{
#if (Traction == 1)
					if (cons[sel_type] == 3)
					{
						if (set_position_from_encoder() == 1)
						{
							preset = 1;
				    		DPP_Count = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
				    		old_dpp = DPP_Count;
#if (Simulator == 1)
							sim_DPP_Count = DPP_Count;
#endif
							preset_encoder_count(DPP_Count);
							if (reset_enc_base_count == 1)
							{
								reset_enc_base_count = 0;
								init_encoder_count(DPP_Count);
							}
						}
						else					
						{
							record_fault(f_encoder_preset);
				      		procf = 0;        // reset elevator lost
							rset = 3;						
						}
					}
					else if ((cons[sel_type] == 1) || (cons[sel_type] == 2))
					{
						if (set_position_from_selector() == 1)
						{
							preset = 1;
							preset_selector_position();
						}
						else					
						{
							record_fault(f_sel_preset);
				      		procf = 0;        // reset elevator lost
							rset = 3;						
						}
					}
					else
#endif
					{
						preset = 1;
						tmppos = 0;
						if(rdinp(i_BP1) == 1)
			  				tmppos = (tmppos + 1);
						if(rdinp(i_BP2) == 1)
						  	tmppos = (tmppos + 2);
						if((cons[topf] > 3) && (rdinp(i_BP4) == 1))
			  				tmppos = (tmppos + 4);
						if((cons[topf] > 7) && (rdinp(i_BP8) == 1))
			  				tmppos = (tmppos + 8);
						if((cons[topf] > 15) && (rdinp(i_BP16) == 1))
			  				tmppos = (tmppos + 16);
#if (Tract_HR == 1)
						if((cons[topf] > 31) && (rdinp(i_BP32) == 1))
			  				tmppos = (tmppos + 32);
#endif
				      	if(tmppos != position)    // The binary input does not match position
				      	{
							if ((preset_pos == 1) && (tmppos > 0) && (tmppos <= cons[topf]))
								position = tmppos;
							else
							{
								statusf |= sf_BPI;
		//						procf = 0;      // go to reset procedure - deleted to leave position at current floor
								record_fault(f_binary);
								if (fvars[fvpresetupd] == 1)
									position = tmppos;
								return;
							}
				      	}
						else
							statusf &= ~sf_BPI;
					}
//			 	  	rset = 0;
					preset_pos = 0;
				}
      		}
    	}

		if ((((cons[BinPiIn] == 0) && (cons[sel_type] == 0)) || (preset == 1)) && ((cons[equake] == 0) || (eqf == 0)) && (gripper_fault == 0))
		{	// Check for valid after the position has been preset	(don't want to move the car on earthquake)
	    	if(((dt_limit == 1) && (timers[tlimit] > 5) && (ut_limit == 1) && (stp_sw == 1)) &&	(Buffer_Test == 0) &&
	       		((position == cons[bottomf]) || (position == cons[topf])))
	    	{   //position is at top or bottom but elevator in the middle
				statusf |= sf_POS;
				record_fault(f_pos_error);
	      		if(position == cons[topf])
		  			position = (cons[topf] - 1);
	      		if(position == cons[bottomf])
		  			position = (cons[bottomf] + 1);
#if (Traction == 0)
				if (cons[Car_Sw] == 0)
				{
		      		procf = 0;        // reset elevator lost
		      		rset = 3;
				}
#else
	      		procf = 0;        // reset elevator lost
	      		rset = 3;
#endif
	      		return;
	    	}
			else
				statusf &= ~sf_POS;

	    	if ( (dt_limit == 0) && (timers[tlimit] > 5) && (stp_sw == 1) && 
	    		 ( ((position != cons[bottomf]) && (cons[shortfl] != cons[bottomf]))  ||
	    		   ((position > (cons[bottomf]+1)) && (cons[shortfl] == cons[bottomf])) ) )
	    	{   // elevator at bottom but position does not match
				statusf |= sf_POS;
				record_fault(f_pos_error);
#if (Traction == 0)
				if (cons[Car_Sw] == 0)
		      		procf = 0;        // reset elevator lost
	      		position = cons[bottomf];
#else
	      		procf = 0;        // reset elevator lost
	      		position = cons[bottomf];
#endif
	      		return;
	    	}
			else
				statusf &= ~sf_POS;

	    	if ( (ut_limit == 0) && (timers[tlimit] > 5) && (stp_sw == 1) &&
	    		 ( ((position != cons[topf]) && ((cons[shortfl] == 0) || (cons[shortfl] != (cons[topf]-1))))  ||
	    		   ((position < (cons[topf]-1)) && (cons[shortfl] == (cons[topf]-1))) ) )
	    	{   // elevator at top but position does not match
				statusf |= sf_POS;
				record_fault(f_pos_error);
#if (Traction == 0)
				if (cons[Car_Sw] == 0)
	      			procf = 0;        // reset elevator lost
      			position = cons[topf];
#else
	      		procf = 0;        // reset elevator lost
	      		position = cons[topf];
#endif
	      		return;
	    	}
			else
				statusf &= ~sf_POS;

			if (rdinp(i_DZ) == 1)
			{
				if ((position == cons[topf]) && (timers[tlimit] > 5) && (stp_sw == 1))
				{
					if ((ut_limit == 0) && (uts_limit == 1))
					{
						if (limit_fault == 0)
							record_fault(f_UTS_flt);
						limit_fault = 1;
					}
					if ((ut_limit == 1) && (uts_limit == 0))
					{
						if (limit_fault == 0)
							record_fault(f_UT_flt);
						limit_fault = 1;
					}
				}
				if ((position == cons[bottomf]) && (timers[tlimit] > 5) && (stp_sw == 1))
				{
					if ((dt_limit == 0) && (dts_limit == 1))
					{
						if (limit_fault == 0)
							record_fault(f_DTS_flt);
						limit_fault = 1;
					}
					if ((dt_limit == 1) && (dts_limit == 0))
					{
						if (limit_fault == 0)
							record_fault(f_DT_flt);
						limit_fault = 1;
					}
				}
			}
			else limit_fault = 0;
		}
		else limit_fault = 0;


		if (limit_fault == 1)
			statusf |= sf_TLimit;
		else
			statusf &= ~sf_TLimit;					
		
#if((Traction == 1) || (Tract_OL == 1))
	
		// Check the counterweight switch position

		if (cons[equake] == 1)
		{
	    	if ((dt_limit == 0)&&(above_cwt == 1) && (timers[tlimit] > 5) && (stp_sw == 1))
			{
				above_cwt = 0;
				record_fault(f_cws_dt);
			}

			if ((ut_limit == 0)&&(above_cwt == 0) && (timers[tlimit] > 5) && (stp_sw == 1))
			{
				above_cwt = 1;
				record_fault(f_cws_ut);
			}
		}
#endif

#if (Tract_OL == 0) 
		// Turning off high speed outputs
    	clroutp(o_UPF);       // clear up fast output
   		clroutp(o_DF);          // clear down fast output
#endif

		if ((io_fault == 0) && (rdoutp(o_RUN) == 0)) 
		{		   // No i/o fault AND not commanding a run
			if ((rdinp(i_UF) == 0) && (rdinp(i_DF) == 0))
				timers[tupfdnfdly] = 0;

			if ((rdinp(i_UF) == 1) && (rdoutp(o_UPF) == 0) && (timers[tupfdnfdly] > 5)) 
			{	  // Debounce for 500 msec
				record_fault(f_upf_on);
				io_fault = 1;
				timers[tupfdnfdly] = 0;
			}

			if ((rdinp(i_DF) == 1) && (rdoutp(o_DF) == 0) && (timers[tupfdnfdly] > 5))
			{
				record_fault(f_df_on);
				io_fault = 1;
				timers[tupfdnfdly] = 0;
			} 
		}
		else
			timers[tupfdnfdly] = 0;

		// Checking to see if dead floor level
		// ************************************************
		// DEAD LEVEL
		// ************************************************

#if (Traction == 1)

		set_ul_dl();		// sets up_level and dn_level

		if ((dn_level == 1) && (up_level == 1))				// dead floor level
#else
		if((rdinp(i_DL) == 1) && (rdinp(i_UL) == 1))   // dead floor level
#endif
		{
			if (rdoutp(o_MCC) == 0)		// MCC turned off
			{
				leveling_fault_cnt = 0;			// reset the fault count when car stops with a good relevel
				timers[trelev] = 0;
#if (Traction == 1)
				relev_stop_count = 0;
				leveling = 0;
				lev_latch = 0;
#endif
			}

#if((Traction == 1) || (Tract_OL == 1))
			if ((leveling_fault_cnt > fvars[fvlevfltcnt]) && (firef == 0) && (doorf == 0) && ((rdoorf == 0) || (cons[rear] == 0)))
			{
				if (leveling_fault == 0)
					record_fault(f_leveling_fault);
				leveling_fault = 1;
			}
#endif

			if (relevel == 1)
			{
				timers[tgen] = 0;
				timers[tebkdrop] = 0;
				timers[tsoftstp] = 0;
				timers[tnit] = 0;
			}
			relevel = 0;              // not releveling
			relevel_req = 0;
			rset_run_cnt = 0;
			delta_off_flag = 0;
			lev_startf = 0;

#if((Traction == 1) || (Tract_OL == 1))
			timers[tmotion] = 0;
			timers[tvpat] = 0;
			timers[tpatdly] = 0;
  #if(Traction == 1)
			Velocity = 0;
			Dmd_Velocity = 0;
			Vel_Step = 0;

			timers[trelevstdir] = 0;			
			
			if ((cons[sercom] & 8) == 0)
				DAC_Out();
  #endif
  #if(Tract_OL == 1)
	    	clroutp(o_UPF);       // clear up fast output
	    	clroutp(o_DF);          // clear down fast output
  #endif

  #if ((Traction == 1) || (Tract_OL == 1))	
			if ((timers[tsoftstp] >= 20) && (timers[tsoftstp] <= 25) && (doorf == 0) && (rdoorf == 0))
				get_load(1);	 // update the load weigher eventhough we did not open the door
  #endif

			drop_brake(c_drop_brake_timed);
			if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1) && (in_pfc_sfc_test == 0))
			{
			    setoutp(o_LE);        // set the leveling enable output
				setoutp(o_LE1);
			}
		    if(timers[tsoftstp] <= fvars[fvsst])  // soft stop needed
		    {
				timers[tmotion] = 0;      // not in motion clear motion timer
				if(dirf == 1)
				{
					setoutp(o_UP);      // set up output
					clroutp(o_DNR);   // clear down output
				}
				else
				{
					setoutp(o_DNR);   // set down output
					clroutp(o_UP);      // clear up output
				}
				stop_seq = 1;
				setoutp(o_MCC);
				setoutp(o_MCA);
				setoutp(o_RUN);   // set run output
				setoutp(o_RUNA);
	        }
	        else
	        {
				dirf = 0;
				don_delay = 0;
				if (stop_seq == 1)
					stop_seq = 2;
				if (in_pfc_sfc_test == 0)
				{
					clroutp(o_UP);      // clear up output
					clroutp(o_DNR);   // clear down output
				}
				if (leveling_fault != 0)
				{				// can set a gripper fault here
					if ((fvars[fvlevflt] & 0x01) != 0)
					{		// set the gripper since the brake failed
						gripper_test = 20;		// don't run the gripper test accidentally
						clroutp(o_GR1R);
						clroutp(o_GR2R);
						clroutp(o_LE);
						clroutp(o_LE1);
						gripper_fault = 1;
						SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
						if (cons[EM_BRK] != 0)
							record_fault(f_EMBK_levflt);
						else
							record_fault(f_grip_levflt);
					}
					clroutp(o_RUN);   // clear run output
					clroutp(o_RUNA);
				}
			    if(timers[tsoftstp] >= (fvars[fvsst] + 10))  // delay the drop of MCC and mc
				{
					if (stop_seq == 2)
						stop_seq = 0;
					if (rdoutp(o_MCC) == 1)		// MCC on (first time in)
						keb_run_verify_seq = 0;
					clroutp(o_RUN);   // clear run output
					clroutp(o_RUNA);
					clroutp(o_MCC);
					clroutp(o_MCA);
				}

	        }
#else		 
			// Hydro only
		    setoutp(o_LE);        // set the leveling enable output
			setoutp(o_LE1);
			if (in_pfc_sfc_test == 0)
			{
				clroutp(o_DNR);   // clear down output
				clroutp(o_UP);      // clear up output
			}
			clroutp(o_RUN);   // clear run output
			clroutp(o_RUNA);

	        // Checking to see if a soft stop is needed
			if((timers[tsoftstp] <= fvars[fvsst]) && ((cons[Micro_Relev] == 0) || (micro_relevel == 0)))  // soft stop needed
			{
				timers[tmotion] = 0;      // not in motion clear motion timer
				if(dirf == 1)
				{
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
				    	setoutp(o_MST);
				    setoutp(o_MCC);
					setoutp(o_MCA);
				}
			}
			else      // No soft stop
			{
				dirf = 0;

				// viscoustiy control run the motor
				if( (servf != 0) && (dpref == 0) && (dcalls == 0) &&
					(((rdinp(i_TPL) == 1) && (fvars[fvtpl] == 0)) || 
				 	((rdinp(i_TPL) == 0) && (fvars[fvtpl] == 1))) && 
					(rdoorf == 0) && (doorf == 0) && (position == lobby_fl) &&
					(((pfc_sfc_test > 10) && (in_pfc_sfc_test == 0)) || (cons[SFC_2004_IO] == 0)) )
				{
					if(timers[tmotion] > 100)
						timers[tmotion] = 100;
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
					{
					  	if(timers[tmotion] > fvars[fvydel])
					       	setoutp(o_MST);
					  	else
					       	clroutp(o_MST);
					}
				  	setoutp(o_MCC);
					setoutp(o_MCA);
				  	Viscosity = timers[tmotion];
			    }
			    else
			    {
				  	if (((rdinp(i_TPL) == 0) && (fvars[fvtpl] == 0)) || 
				  		((rdinp(i_TPL) == 1) && (fvars[fvtpl] == 1)))
				  	{
						if(Viscosity == 0)
						{
					    	timers[tmotion] = 0;      // not in motion clear motion timer
						}
						else
						{
					    	if((timers[tmotion] - Viscosity) > 25)
								Viscosity = 0;
						}
				  	}
				  	else
				  	{
						if((timers[tmotion] - Viscosity) > 25)
						{
							timers[tmotion] = 0;
							Viscosity = 0;
						}
				  	}
				  	clroutp(o_MCC);
					clroutp(o_MCA);
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
					  	clroutp(o_MST);
				}
	      	}
		    if (cons[Micro_Relev] == 1) 
			{
				if (timers[tsoftstp] >= 3)
				{
					clroutp(o_UPML);
					clroutp(o_DNML);
				}
			}
#endif
	    }
	// Elevator is not level needs to relevel
	    else
	    {
	    
#if (Traction == 1)

			if (Drive_Type[cons[carnmb]] == 12)
			{
				if (keb_run_verify_seq == 0)
					keb_run_verify_seq = 1;

				verify_run_mode();
			}
#endif
	    
	    	// can't relevel until P is on showing that the contactor string has dropped
#if ((Traction == 1) || (Tract_OL == 1))
	      	if(  ((rdinp(i_P) == 0) && (rdoutp(o_RUN) == 0))  || 	// error if p is off when run is off
	    	// can't relevel if the stop switch is pulled on a traction
		  	((rdinp(i_STP) == 0) && (Drive_Type[cons[carnmb]] != 1)  && (Drive_Type[cons[carnmb]] != 9)) ||
#else
	    	// can't relevel if the stop switch is pulled on a traction
		  	if( ((rdinp(i_STP) == 0) && (Drive_Type[cons[carnmb]] != 1) && (Drive_Type[cons[carnmb]] != 9)) ||
//			(rdinp(i_UFI) == 1) || (rdinp(i_DF) == 1) ||
#endif
	    	// can't relevel down if the stop switch is pulled on a hydro
		  	((rdinp(i_STP) == 0) && ((Drive_Type[cons[carnmb]] == 1) || (Drive_Type[cons[carnmb]] == 9)) && (rdinp(i_UL) == 0)) ||
			(io_fault != 0) ||			// can't relevel with an io fault
	    	// can't relevel too long
		  	(stallf != 0) ||
			// wait for relevel timer to expire
			(timers[trelev] < fvars[fvrlvtim]) ||	 // wait 2 seconds
	    	// can't relevel up if on the up directional stop
		  	((rdinp(i_UL) == 1) && (rdinp(i_UN) == 0) && (rdinp(i_DZ) == 0)) ||
	    	// can't relevel down if on the down directional stop
		  	((rdinp(i_DL) == 1) && (rdinp(i_DN) == 0) && (rdinp(i_DZ) == 0)) ||
			// ul or dl has failed
			(UL_DL_OFF_Fault == 1) ||
	    	// can't relevel until soft stop has occured
#if ((Traction == 0) && (Tract_OL == 0))
		  	(timers[tsoftstp] <= (fvars[fvsst] + 15)) ||
 #else
			(leveling_fault != 0)  ||		   // car moved out of the level zone when the drive was turned off
			((cons[Emp_Recover] == 2) && (drv_has_power == 0)) ||	  // wait for drive to have power before releveling
#endif
#if (Traction == 1)
			((Drive_Type[cons[carnmb]] == 12) && (keb_run_verify_seq != 3)) || 
#endif
			((rdinp(i_DZ) == 0) && ((door_locks() == 0) || (car_gate() == 0))) ||
		  	((empf != no_ep) && (empf != ep_recall) && (empf != ep_select)) )
	      	{

			  	timers[tmotion] = 0;
				timers[tpatdly] = 0;
				relevel = 0;
				relevel_req = 1;
				lev_startf = 0;
				
#if((Traction == 0)	&& (Tract_OL == 0))

			  	if ((rdinp(i_STP) == 0) && (rdinp(i_UL) == 0)) // zero the relevel timer to give the safety processor time to reset
					timers[trelev] = 0;

				if((timers[tsoftstp] > fvars[fvsst]) || (dirf == 2) || ((cons[Micro_Relev] == 1) && (micro_relevel == 1)))
				{
					clroutp(o_MCC);      // Clear motor starter output
					clroutp(o_MCA);
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
						clroutp(o_MST); // Turn off motor starter timer output
				}
#endif
#if((Traction == 1) || (Tract_OL == 1))

				if (rdinp(i_STP) == 0)			// zero the relevel timer to give the safety processor time to reset
					timers[trelev] = 0;

				if ((cons[Emp_Recover] == 2) && (drv_has_power == 0))
				{					// drive cannot move the car
					clroutp(o_UP);      // clear up output
					clroutp(o_DNR);   // clear down output
					don_delay = 0;
					clroutp(o_RUN);   // clear run output
					clroutp(o_RUNA);
					clroutp(o_MCC);      // Clear motor starter output
					clroutp(o_MCA);
				}
				else if ((timers[tsoftstp] <= fvars[fvsst]) && (leveling_fault != 0))  // soft stop needed
				{
				    timers[tmotion] = 0;      // not in motion clear motion timer
				    if(dirf == 1)
				    {
						setoutp(o_UP);      // set up output
						clroutp(o_DNR);   // clear down output
				    }
				    else
				    {
						setoutp(o_DNR);   // set down output
						clroutp(o_UP);      // clear up output
				    }
					setoutp(o_RUN);   // set run output
					setoutp(o_RUNA);
				}
				else
				{
						
					clroutp(o_UP);      // clear up output
					clroutp(o_DNR);   // clear down output
					don_delay = 0;
					if (leveling_fault != 0)
					{
						clroutp(o_RUN);   // clear run output
						clroutp(o_RUNA);
					}
					if (timers[tsoftstp] >= (fvars[fvsst] + 10))  // delay the drop of MCC and mc
					{
						clroutp(o_RUN);   // clear run output
						clroutp(o_RUNA);
						clroutp(o_MCC);      // Clear motor starter output
						clroutp(o_MCA);
						if (rdoutp(o_MCC) == 1)		// MCC on (first time in)
							keb_run_verify_seq = 0;
					}
				}
				drop_brake(c_drop_brake_reset);
				if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1) && (in_pfc_sfc_test == 0))
				{
					setoutp(o_LE);
					setoutp(o_LE1);
				}
				timers[tvpat] = 0;
#if(Traction == 1)
				Velocity = 0;
				Dmd_Velocity = 0;
				Vel_Step = 0;
				timers[trelevstdir] = 0;
#endif
#else
			    if (cons[Micro_Relev] == 1)
				{
					clroutp(o_UPML);
					clroutp(o_DNML);
				}
		    	setoutp(o_LE);        // set the leveling enable output
				setoutp(o_LE1);
				clroutp(o_UP);      // Clear up output
				clroutp(o_DNR);   // Clear down output
				clroutp(o_RUN);   // Clear run output
				clroutp(o_RUNA);
#endif
			}
		    else
		    {

#if((Traction == 1) || (Tract_OL == 1))
				if ((relevel == 0) && (stop_seq == 2))
					leveling_fault_cnt++;

				timers[tsoftstp] = 0;	   // will cause hydro to not relevel
#endif

#if (Traction == 1)
				if (level_stop_fault == 1)
				{
					relev_stop_count ++;
					if (relev_stop_count < 2)
					{
						leveling = 0;
						lev_latch = 0;
						level_stop_fault = 0;
					}
				}
#endif

				relevel = 1;
				relevel_req = 0;
				timers[tnit] = 0;

				if (stallf == 0)
				{
					if (timers[tmotion] >= fvars[fvstall])
					{
						record_fault(f_stall_fault);
						stallf = 1;
					}
				}

#if(Tract_OL == 1)
		    	clroutp(o_UPF);       // Set Leveling speed UPF:B1,DF:B0 = 0,1
		    	setoutp(o_DF);          
#endif
		      	// relevel up
#if (Traction == 1)
				if ((dn_level == 0) && (up_level == 1) && (in_pfc_sfc_test == 0))
#else
				if ((rdinp(i_DL) == 0) && (rdinp(i_UL) == 1) && (in_pfc_sfc_test == 0))
#endif
				{
			  		dirf = 1;

#if((Traction == 1)	|| (Tract_OL == 1))


					if (lev_startf == 0)
					{
						
						if (chk_lev_start(dirf) == 1)
							lev_startf = 1;
						else
							lev_startf = 0;
					}
					else
					{
	
						if ((Drive_Type[cons[carnmb]] != 5) && (Drive_Type[cons[carnmb]] != 8) && (Drive_Type[cons[carnmb]] != 10) && (cons[EM_BRK] != 6)) 
						{
						 	setoutp(o_UP);    // Turn on up output
							if(rdinp(i_DEL) == 0)
							{
								if ((timers[tmotion] >= 100) && (delta_off_flag == 0))			// 3 Seconsds to get DEL
								{
									record_fault(f_delta_off);
									delta_off_flag = 1;
								}
							}
						}
						else
						{
					 		setoutp(o_UP);    // Turn on up output
							timers[tff] = 0;
							Field_Force = 1;
							setoutp(o_FF);
						}

				 		setoutp(o_RUN); // Turn on the run output
						setoutp(o_RUNA);
					  	setoutp(o_MCC);    // Turn on motor starter output
						setoutp(o_MCA);

				 		clroutp(o_DNR); // Turn off down output
						if (fvars[fvdon] != 0)
						{
							if ((rdinp(i_DON) == 0) && (timers[tpatdly] < 400))
							{
								don_delay = timers[tpatdly];
								if (don_delay == 0)
									don_delay = 1;
							}
						}
						else
							don_delay = 0;

						pick_brake(c_pick_brake_relevel);

  #if (Traction == 1)
						if (timers[tpatdly] < (fvars[fvpatrel] + don_delay + 1))
						{
							set_pre_torque();		// Must be called to set the pre_torque sequence
							torque = 0;				// Zero the pre-torque value on a relevel
							Velocity = 0;
							Vel_Step = 0;
						}
						else
						{
							torque = 0;
							don_delay = 0;

							if (Vel_Relev_St != 0)
							{
								if (timers[trelevstdir] > fvars[fvrelevsttim])
									Velocity = Vel_Relevel;
								else	// not in the up direction long enough
									Velocity = Vel_Relev_St;
							}
							else
							{

					 			for(i=1; i<=timers[tvpat]; i++)
					 			{
									if (Vel_Step < Vel_Step_Const)
						  	  	  		Vel_Step += Vel_Step_Inc;

					     			if(Velocity < Vel_Relevel)
										Velocity += Vel_Step;
									else 
										Velocity = Vel_Relevel;
					 			}

								if (Velocity > Vel_Relevel)
										Velocity = Vel_Relevel;
							}
						}
						timers[tvpat] = 0;
						Dmd_Velocity = Velocity;
						if ((cons[sercom] & 8) == 0)
					 		DAC_Out();
  #endif
					}
#else
					if (lev_startf == 0)
					{
						
						if (chk_lev_start(dirf) == 1)
							lev_startf = 1;
						else
							lev_startf = 0;
					}
					else
					{
						if ((cons[Micro_Relev] == 0) || (rdinp(i_DZ) == 0) || (rdoutp(o_UP) == 1))
						{
							if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
							{		
					  			if(timers[tmotion] > fvars[fvydel])
					     			setoutp(o_MST);
						  		else
						     		clroutp(o_MST);
							}
					  		setoutp(o_MCC);    // Turn on motor starter output
							setoutp(o_MCA);
													// Turn on up output when DEL is on
							if(rdinp(i_DEL) == 0)
								clroutp(o_UP);
							else
								setoutp(o_UP);

							if (cons[Micro_Relev] == 1)
								clroutp(o_UPML);
							micro_relevel = 0;
						}
						else
						{
							micro_relevel = 1;
							setoutp(o_UPML);
						}

				  		setoutp(o_RUN); // Turn on the run output
						setoutp(o_RUNA);
				  		clroutp(o_DNR); // Turn off down output
					}
#endif
				}

		      	// relevel down
#if (Traction == 1)
				if ((up_level == 0) && (dn_level == 1) && (in_pfc_sfc_test == 0))
#else
				if ((rdinp(i_UL) == 0) && (rdinp(i_DL) == 1) && (in_pfc_sfc_test == 0))
#endif
				{
			  		dirf = 2;
#if((Traction == 1) || (Tract_OL == 1))

					if (lev_startf == 0)
					{
						
						if (chk_lev_start(dirf) == 1)
							lev_startf = 1;
						else
							lev_startf = 0;
					}
					else
					{
	
				 		clroutp(o_UP);    // Turn off up output
				 		setoutp(o_RUN); // Turn on the run output
						setoutp(o_RUNA);
					  	setoutp(o_MCC);    // Turn on motor starter output
						setoutp(o_MCA);

						if ((Drive_Type[cons[carnmb]] != 5) && (Drive_Type[cons[carnmb]] != 8) && (Drive_Type[cons[carnmb]] != 10)  && (cons[EM_BRK] != 6)) 
						{
					 		setoutp(o_DNR); // Turn on down output
							if(rdinp(i_DEL) == 0)
							{
								if ((timers[tmotion] >= 100) && (delta_off_flag == 0))			// 3 Seconsds to get DEL
								{
									record_fault(f_delta_off);
									delta_off_flag = 1;
								}
							}
						}
						else
						{
					 		setoutp(o_DNR); // Turn on down output
							timers[tff] = 0;
							Field_Force = 1;
							setoutp(o_FF);
						}

						if (fvars[fvdon] != 0)
						{
							if ((rdinp(i_DON) == 0) && (timers[tpatdly] < 400))
							{
								don_delay = timers[tpatdly];
								if (don_delay == 0)
									don_delay = 1;
							}
						}
						else
							don_delay = 0;

						pick_brake(c_pick_brake_relevel);

  #if (Traction == 1)
						if (timers[tpatdly] < (fvars[fvpatrel] + don_delay + 1))
						{
							set_pre_torque();	   	// Must be called to set the pre_torque sequence
							torque = 0;				// Zero the pre-torque value on a relevel
							Velocity = 0;
							Vel_Step = 0;
						}
						else
						{
							torque = 0;
							don_delay = 0;

							if (Vel_Relev_St != 0)
							{
								if (timers[trelevstdir] > fvars[fvrelevsttim])
									Velocity = Vel_Relevel;
								else	// not in the down direction long enough
									Velocity = Vel_Relev_St;
							}
							else
							{

						 		for(i=1; i<=timers[tvpat]; i++)
						 		{
									if (Vel_Step < Vel_Step_Const)
						  	  	  		Vel_Step += Vel_Step_Inc;

					     			if(Velocity < Vel_Relevel)
										Velocity += Vel_Step;
									else 
										Velocity = Vel_Relevel;
						 		}

								if (Velocity > Vel_Relevel) 
										Velocity = Vel_Relevel;
							}
						}
						timers[tvpat] = 0;
						Dmd_Velocity = Velocity;
						if ((cons[sercom] & 8) == 0)
					 		DAC_Out();
  #endif
					}
#else			
			 // Hydro only
					if (lev_startf == 0)
					{
						
						if (chk_lev_start(dirf) == 1)
							lev_startf = 1;
						else
							lev_startf = 0;
					}
					else
					{
						if ((cons[Micro_Relev] == 0) || (rdinp(i_DZ) == 0) || (rdoutp(o_DNR) == 1))
						{
					  		clroutp(o_MCC);    // Turn off motor starter output
							clroutp(o_MCA);
					  		setoutp(o_DNR); // Turn on down output
							if (cons[Micro_Relev] == 1)
								clroutp(o_DNML);
							micro_relevel = 0;
						}
						else
						{
							micro_relevel = 1;
							setoutp(o_DNML);
						}
				  		setoutp(o_RUN); // Turn on the run output
						setoutp(o_RUNA);
				  		clroutp(o_UP);    // Turn off up output
						if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
					  		clroutp(o_MST); // Turn off motor starter timer output
					}
#endif
				}
			}
		}
	    if (((firef == 0) || (firef >= 4) || (rfiref >= 4)) && ((medf == 0) || (medf >= 3)))
	    {
			if ((in_pfc_sfc_test == 0) && (ids_return_typ == 0))
			{
		      	clroutp(o_FST);  // turn off the fire service stopswitch bypass
	    	  	clroutp(o_FSTP);  // turn off the fire service stopswitch bypass
	      		FS_DOB_DIS = 0;
		    }
	    }
	    else
			clr_dir_arrow();
	    
#if (Traction == 1)
	    if ( ((rdoutp(o_UP) == 1) || (rdoutp(o_DNR) == 1)) && ((relevel == 1) || (rdinp(i_DON) == 0)) && (enc_vel_fpm > 100) )
	    {		// Intended leveling but car is out of control
			if ((fvars[fvlevflt] & 0x01) != 0)
			{		// set the gripper since the brake failed
				gripper_test = 20;		// don't run the gripper test accidentally
				clroutp(o_GR1R);
				clroutp(o_GR2R);
				clroutp(o_LE);
				clroutp(o_LE1);
				gripper_fault = 1;
				SPB_can.command |= spbc_set_umotion;			// set unintended motion fault

				if  (rdinp(i_DON) == 0)
			  		record_fault(f_don_off);
				
				if (cons[EM_BRK] != 0)
					record_fault(f_EMBK_levflt);
				else
					record_fault(f_grip_levflt);
			}
	    }
#endif
	    pisout(position);
	    if (chkdoor()== 1)
	    {		// gripper test cannot be run
			if (in_pfc_sfc_test != 0)
			{
				clroutp(o_UP);
				clroutp(o_DNR);
				clroutp(o_FST);
				clroutp(o_FSTP);
				in_pfc_sfc_test = 0;
				pfc_sfc_test = 0;
				SPB_can.command &= ~spbc_GR1_test;			// Clear GR1 test
				SPB_can.command &= ~spbc_SFC_test;			// Clear SFC test
			}
#if((Traction == 1) || (Tract_OL == 1))
	    	if (gripper_test < 10)
	    	{	  // cancel gripper test
				setoutp(o_GR1R);
				setoutp(o_GR2R);
				gripper_test = 10;
				if (cons[EM_BRK] == 3)
				{
					setoutp(o_UTM);
					setoutp(o_EBA1);			// pick the emergency brake main contactors
					setoutp(o_EBA2);
					clroutp(o_EBB1);			// Drop the test contactors
					clroutp(o_EBB2);
					timers[tebkdrop] = 0;
	    		}	
				if (cons[EM_BRK] == 5)
					setoutp(o_UTM);
	    	}
#endif
	    }

		if((manual_door == 2) && (dpref != 0))
		{
		    if(rdinp(i_DOL) == 1)
			    timers[tdwel] = 0;
		    if((timers[tdwel] > doort) && (rdinp(i_DOL) == 0))
			    dirsel();
		}
		if((manual_rdoor == 2) && (dpref != 0) && (cons[rear] != 0))
		{
		    if (rdinp(i_DOLR) == 1) 
			    timers[trdwel] = 0;			 
		    if((timers[trdwel] > rdoort) && (rdinp(i_DOLR) == 0))
			    dirsel();
		}

	    if(dpref == 0)
	    {
	      	dirsel();
	      	if (((fvars[fvviplant] == 0) || (cons[VipSvc] == 0) || (vipf != 3)) && (fvars[fvarrivallant] == 0))			
	      		clrlant();
	      	timers[tlant] = 0;			
	      	timers[trlant] = 0;
			if (fvars[fvarrivallant] == 1)
				hlants();
	    }
	    else
	    {
	      	if((doorf != 0) || (rdoorf != 0) || ((cons[frghtd] != 0) && (rdinp(i_DOL) == 0))
	      		|| ((cons[rear] !=0) && (cons[frghtd] != 0) && 
	      			(rdinp(i_DOLR) == 0)) )
			{
#if (Traction == 1)
				Max_Lant_Time = 0;
#endif
				if ((prev_pref != dpref) && (dpref != 0))
					timers[tlantchange] = 0;
				prev_pref = dpref;

				if (timers[tlantchange] >= fvars[fvlantprefdly])
					hlants();
				else
			    	clrlant();
				set_dir_arrow();
			}			
	    }

		if (cons[hugs] != 0)
			sethugsf();

		if (cons[Cycle_Run] == 1)
			cycle_run();

	    doors();
	    
	    if(cons[rear] != 0)
			rdoors();
	    else
	    {
			rdoorf = 0;
			rfiref = 0;
	    }

	    chkrun();

#if((Traction == 1) || (Tract_OL == 1))
		if (((manual_door == 1) || (manual_rdoor == 1)) && ((procf >= 14) && (procf <= 16)) ) 
			get_load(1);		// force load weigher update
		else
			get_load(0);		// get load weigher data when door in dwell mode
		setup_load_weigher();		// setup load weigher (routine looks at lw_sequp_seq)
#endif
  	}
}

                       

// ****************************************************
// Status of the car gate (0=gate open, 1=gates closed)
// ****************************************************

int16 car_gate(void)
{
	if ( (rdinp(i_GS) == 1) && (rdinp(i_GS_1) == 1) &&
		((cons[rear] == 0)	|| ((rdinp(i_RGS) == 1) && (rdinp(i_RGS_1) == 1))) )
		return 1;
	else
		return 0;
}

// *******************************************************
// This is check to see if there is a need to run or move
// *******************************************************
void chkrun()
{
  	if(cons[rear] == 0)
		rdoorf = 0;

	statusf &= ~(sf_BRKS | sf_P | sf_DCL);	   // Clear here if subroutine return occurs before condition can be cleared
			
			
	if (run_hold_1036 == 1) 
	{
		statusf2 |= sf_1036;
		return;
	}
	else
		statusf2 &= ~sf_1036;
	
#if(Traction == 1)
  	if(Hoistway_Learned != 1)
	{
		if ((statusf2 & sf_LearnHW) == 0)
			record_fault(f_hw_learn);
		statusf2 |= sf_LearnHW;
     	return;
	}
	else
		statusf2 &= ~sf_LearnHW;

	if ((SEL_Count_Valid == 0) && ((cons[sel_type] == 1) || (cons[sel_type] == 2)))
		return;
	

	if ((limit_dir_fault == 1) || (spb_dir_fault == 1) || (vel_decel_diff_fault == 1) || 
		(spb_vel_diff_fault == 1) || (uldl_dir_fault == 1))	 // Had a feedback control error fault
		return;	   // Must be placed on inspection to clear
	

	if ((DBR_Temp_Fault == 1) && (leveling_fault == 0))
		return;

	if ((toc_can_error == 1) || (spb_can_error == 1) || 
		(((statusf & sf_P) != 0) && (Drive_Type[cons[carnmb]] == 9)) ||
		((brk_can_error == 1) && ((cons[brake] == 2) || (cons[brake] == 3))) || 
		((ebrk_can_error == 1) && ((cons[brake] == 2) || (cons[brake] == 3)) && ((cons[EM_BRK] == 6) || (cons[Aux_Brake] == 1) || (cons[EM_BRK] == 7))) || 
		(hardware_init_fault == 1) || (door_motor_ovl == 1) || 
		((sel_can_error == 1) && (cons[sel_type] == 2)) || 
		(((can_enc_com_err == 1) || (can_enc_init == 0) || (EncCan_Upd == 1)) && (cons[sel_type] == 3)) || 
		((drive_online == 0) && ((cons[sercom] & 8) != 0)))
		return;						// No automatic run without the TOP of car board

	// Full Field Control

	if(Field_Force == 0)
	    timers[tff] = 0;
  	if(( (((doorf ==0) && (rdoorf == 0)) || (doorf > 2) || (rdoorf > 2)) && (dcalls != 0)) || 
  				(timers[tsoftstp] <= fvars[fvsst]) || (relevel == 1))
  	{			 // Doors closing and have an onward call
		if(timers[tff] < 600)
		{
			Field_Force = 1;
			setoutp(o_FF);
		}
		else
		{
			clroutp(o_FF);
		}
  	}
  	else
	{    
	    if(timers[tsoftstp] >= fvars[fvsst])
		{
	        clroutp(o_FF);
			Field_Force =0;
		}
	}

//	clroutp(o_FW);

#endif

	if ((fvars[fvlwa] != 0) && (firef == 0) && (rfiref == 0))
	{
#if ((Traction == 1) || (Tract_OL == 1))
		if ((nmb_carcalls > fvars[fvlwa]) && (((cons[loadw] == 1) && (rdinp(i_LWA) == 0) && (lw_disable == 0)) ||
											 ((cons[loadw] == 2) && (load_an == 1)) ))
#else
		if ((nmb_carcalls > fvars[fvlwa]) && (cons[loadw] == 1) && (rdinp(i_LWA) == 0))
#endif
		{
			clrcc(0);
		}
	}
	
	if ((fvars[fvrunct] != 0) && (firef == 0) && (rfiref == 0) && (servf == 1))
	{
		if (run_no_pass_cnt >= fvars[fvrunct])
		{
			run_no_pass_cnt = 0;
			clrcc(0);
		}
	}
	else
		run_no_pass_cnt = 0;
			

	if((safe() == 1) || (dpref == 0) || (rdinp(i_DCL) == 1) || (rdoutp(o_DC) == 0) ||
      	(((rdinp(i_DCLR) == 1) || (rdoutp(o_DCR) == 0)) && (cons[rear] != 0)) )
	{
		safe_fault_latch = 0;
		timers[tsafe] = 0;
	}
	if (in_pfc_sfc_test == 1)		// cannot run until after SFC is tested
		return;

#if ((Traction == 1) || (Tract_OL == 1))
	if ((fvars[fvbkliftsw] != 0) && (firef == 0) && (rfiref == 0))
	{
		
		if ( ((rdinp(i_BRKS) == 0) && (fvars[fvbls] == 0))
			|| ((rdinp(i_BRKS) != 0) && (fvars[fvbls] != 0)) 	
			|| ((cons[Aux_Brake] == 1) && (rdinp(i_XBKS1) == 0) && (fvars[fvbls] == 0)) 
			|| ((cons[Aux_Brake] == 1) && (rdinp(i_XBKS1) != 0) && (fvars[fvbls] != 0))
			 ) 
		{
				if ((timers[tsoftstp] > (fvars[fvsst] - 2)) && 
				   	(relevel == 0) && /*(relevel_req == 0) && */ 	
				   	(rdinp(i_LC) == 1) && (timers[tbkdrop] >= 1)  )	   
					BRK_Drop_Test = 1;
		}
		else
		{
			timers[tbkdrop] = 0;
			BRK_Drop_Test = 0;
		}

		if ((BRK_Drop_Test == 1) || (BRK_Pick_Test == 1))
		{		 // Cannot run unless the brake switch drops out
			if (BRK_Fault == 0)
			{
				if (BRK_Pick_Test == 1)
					record_fault(f_brk_pick);
				else
					record_fault(f_brk_drop);
			}
			BRK_Fault = 1;
			statusf |= sf_BRKS;		// no BRake lift switch input fault
			if (cons[ansi] >= 2000)
			{
				if ((fvars[fvbkliftsw] == 2) && (BRK_Drop_Test == 1) && (gripper_fault == 0))
				{		// set the gripper since the brake failed
					gripper_test = 20;		// don't run the gripper test accidentally
					clroutp(o_GR1R);
					clroutp(o_GR2R);
					clroutp(o_LE);
					clroutp(o_LE1);
					gripper_fault = 1;
					SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
					if (cons[EM_BRK] != 0)
						record_fault(f_EMBK_set);
					else
						record_fault(f_grip_set);
				}
			}
	      	return;
	  	}
		else
			BRK_Fault = 0;
	}
	else		
		BRK_Fault = 0;

	if ( (cons[ansi] >= 2000) && (gripper_test < 10) && (firef == 0) && (rfiref == 0)) 	// Gripper is not tested in fire service
		return;

	if ((cons[Emp_Recover] == 2) && (drv_has_power != 1))		// automatic run on normal drive power
		return;
#endif

  	if ((timers[tnit] < fvars[fvnit]) || (timers[tnit] < (fvars[fvsst] + 15)))       // wait for non interance and soft stop time
    	return;

	if (((manual_door == 1) &&
			((ccmsk[cons[carnmb]][position] != 0) || 
				(ucmsk[cons[carnmb]][position] != 0) || 
				(dcmsk[cons[carnmb]][position] != 0))) || 
		((cons[rear] != 0) && (manual_rdoor == 1) && 
			((rccmsk[cons[carnmb]][position] != 0) || 
				(rucmsk[cons[carnmb]][position] != 0) || 
				(rdcmsk[cons[carnmb]][position] != 0))) )
	{
		if ((prev_dpref != dpref) && (cons[frghtd] != 0) && ((doorf != 0) || ((rdoorf != 0) && (cons[rear] != 0))))
			timers[tnit] = 0;
		prev_dpref = dpref;
		if((fvars[fvattmandir] & 0x04)!=0)
		{
			if((cons[att] == 1) && (servf == 4)) // on attendant
			{
			   	if(allow_run == 0)			
				{
					if((safe() == 1) && (onward_cc != 0))
					{
						allow_run = 1;
						return;

					}
					else
					{
						allow_run = 0;
						timers[tnit] = 0;
						return;
					}
				}
			}
		}
		else if ((fvars[fvattmandir] & 0x01)!=0)
		{
			if((cons[att] == 1) && (servf == 4)) // on attendant
			{
				if(allow_run == 0)
				{
					if(safe() == 1)
					{
						if((fvars[fvattmandir] & 0x02) == 0)
						{
							if(rdinp(i_ATTUP) == 1)
								allow_run = 1;
							else if(rdinp(i_ATTDN) == 1)
								allow_run = 1;
						}
						return;
					}
					else
					{
						allow_run = 0;
						timers[tnit] = 0;
						return;
					}
				}

			}
			else if(cons[att] == 1)
			{
				if((fvars[fvattmandir] & 0x02) != 0)
				{
					if((allow_run == 0))
					{
						if(safe() == 1)
						{
							if(rdinp(i_ATTUP) == 1)
								allow_run = 1;
							return;
						}
						else
						{
							allow_run = 0;
							timers[tnit] = 0;
							return;
						}
					}
					
				}
			}
		}	
		
		if ((cons[Car_Sw] & 1) != 0)
		{
			if((car_gate() == 0))
			{
				if((rdinp(i_ATTUP) == 1) || (rdinp(i_ATTDN) == 1))
				{
					okto_run = 0;
					timers[tnit] = 0;
					return;
				}
				else
				{
					okto_run = 1;					
				}
				
			}
			else if (okto_run == 0)
			{
				if((rdinp(i_ATTUP) == 0) && (rdinp(i_ATTDN) == 0))
				{
					okto_run = 1;
				}
				else	// WAIT for operate to release the handle
				{
					timers[tnit] = 0;
					return;	
				}
			}
			
		}			
				

		if (timers[tnit] < fvars[fvhcdt])	// wait for door time a manual door floor
			return;
		dirsel();
	}

	if(timers[tlocalgetdate] > 100)
	{
		local_getdate(cpu_Z6);
		timers[tlocalgetdate] = 0;
	}

  	day_of_week = d.dayofweek;
  	if(day_of_week != old_day_of_week)
  	{
		timers[tgroup_hcc]  = 0;
		timers[ccct] = 0;
		if(cons[nmbcars] > 1)
			Up_Date_Calls(cpu_Z6);
		local_getdate(cpu_Z6);
		if ((day_of_week != d.dayofweek) || (d.dayofweek > 6))
			local_setdate(cpu_Z6);	// update day of the week  (calc_dayofweek() is called in local_setdate())
	  	day_of_week = d.dayofweek;
		old_day_of_week = day_of_week;
		rhjackf = 1;		// enable reset hydro jack mode
#if ((Traction == 1) || (Tract_OL == 1))
		if (cons[loadw] == 2)
			lw_cal_seq = 1;		// check if time to calibrate load weigher
#endif
  	}

	if (cons[saf_test] == 1)
	{		 // Check for annual safety test
	  	if(d.year > (unsigned)fvars[fvspt_year])
		{
			statusf |= sf_ASTST;
		 	return;
		}

	  	if((d.year == (unsigned)fvars[fvspt_year]) && (d.month > fvars[fvspt_mon]))
		{
			statusf |= sf_ASTST;
		 	return;
		}

	  	if((d.year == (unsigned)fvars[fvspt_year]) && (d.month == fvars[fvspt_mon]) &&
	     	(d.day > fvars[fvspt_day]))
		{
			statusf |= sf_ASTST;
		 	return;
		}
	}

	statusf &= ~sf_ASTST;

	if (((fdoor_req == 0) && ((rdoor_req == 0) || (cons[rear] == 0))) || 
		((doorf != 0) || (rdoorf != 0)))
		timers[tdoorrq] = 0;

	if (((fdoor_req != 0) || ((cons[rear] != 0) && (rdoor_req != 0))) && (timers[tdoorrq] < 50) && (firef == 0) && (rfiref == 0))
  		return;		// waiting for non-simultaneous door to switch operation

  	if ((doorf == 1) || (doorf == 2) || (rdoorf == 1) || (rdoorf == 2))
    	return;

    if ((firef != 0) || (rfiref != 0) || (servf != 1) || (manual_door == 1) || (manual_rdoor == 1) || (cons[frghtd] != 0)) 
		adv_pre_trq_run = 0;

#if (Traction == 1)
  	if (((adv_pre_trq_run == 0) || (fvars[fvadvpretrq] == 0)) && ((doorf == 3) || (doorf == 4) || (rdoorf == 3) || (rdoorf == 4)))
    	return;
#else
  	if ((doorf == 3) || (doorf == 4) || (rdoorf == 3) || (rdoorf == 4))
    	return;
#endif

#if (Traction == 1)
	if ((adv_pre_trq_run == 1) && (fvars[fvadvpretrq] != 0))
	{
		if(rdinp(i_DPM) == 0)
			return;
		if ((cons[rear] != 0) && (rdinp(i_RPM) == 0))
			return; 

	}
#endif

	prev_dpref = dpref;

  	dirsel();

	rset_error_cnt = 0;		// made it out of reset
	
	if ((adv_pre_trq_run == 1) && (prev_dpref != dpref))
		return;

  	if( (dpref == 2) && (downcb[position] == 1) && (doorf == 0) && ((nudgst & 0x02) == 0) && 
  									((nohcreopen == 0) || (onward_calls == 0) || (do_seq == 0)) )
    	return;
  	if( (dpref == 1) && (upcb[position] == 1) && (ncu_door_seq != 3) && (doorf == 0) && ((nudgst & 0x01) == 0) &&
  									((nohcreopen == 0) || (onward_calls == 0) || (do_seq == 0)) )
    	return;
  	if( (dpref == 1) && (lby_req[cons[carnmb]] == position) && (ncu_door_seq != 3) && (doorf == 0) && ((nudgst & 0x01) == 0) &&
  									((nohcreopen == 0) || (onward_calls == 0) || (do_seq == 0)))
    	return;
  	if(cons[rear] != 0)
  	{
	  	if( (dpref == 2) && (rdowncb[position] == 1) && (rdoorf == 0) && ((rnudgst & 0x02) == 0) &&
	  								((nohcreopen == 0) || (onward_calls == 0) || (rdo_seq == 0)) )
	    	return;
	  	if( (dpref == 1) && (rupcb[position] == 1) && (rdoorf == 0) && ((rnudgst & 0x01) == 0) &&
	  								((nohcreopen == 0) || (onward_calls == 0) || (rdo_seq == 0)) )
	    	return;
  	}

  	if(Viscosity != 0)
		return;

	if (((relevel == 1) || (relevel_req == 1)) && (stallf == 0))
		return;					// wait until relevel finishes before the run starts

  	if(dcalls == 0)                       // no calls
    	return;

	if (eqf != 0)
		return;					// do not allow an automatic run on earthquake

#if (Traction == 1)
	if ((adv_pre_trq_run == 0) || (fvars[fvadvpretrq] == 0))
  	{
#endif
	  	if (rdinp(i_DCL) == 1)         // wait until doors are closed
	  	{
	    	if ((doorf == 0) && (cons[frghtd] == 0) && ((cons[pbdoor] & 2) == 0))
	      	{
	      		setoutp(o_DC);
	 			timers[tdodly] = 0;
			}
			statusf |= sf_DCL;		// waiting for DCL
	    	return;
	  	}

	  	if ((rdinp(i_DCLR) == 1) && (cons[rear] != 0))
	  	{
	    	if((rdoorf == 0) && (cons[frghtd] == 0))		// wait until doors are closed
	      	{
	      		setoutp(o_DCR);
	 			timers[trdodly] = 0;
			}
			statusf |= sf_DCL;	// waiting for RDCL
	    	return;
	  	}

	  	if (safe() == 0)
	  	{
	  		if ((cons[frghtd] == 0) && ((manual_door == 0) || (manual_door == 2)))  // wait until safe
		  	{
		    	timers[tdc] = 0;
		    	timers[tdo] = 0;
		    	timers[tdwel] = 0;
		    	setoutp(o_DC);
	 			timers[tdodly] = 0;
		    	if((timers[tsafe] >= 30) && (firef == 0) && (rdinp(i_DZ) == 1))
		    	{
					record_fault(f_car_safe_start);
					set_safe_fault();
					clroutp(o_DC);
					if(ccmsk[cons[carnmb]][position] == 1)
					{
						doorf = 1;
		  	  		  	if ((manual_door == 0) || (manual_door == 2))   
					  		safe_closetry++;			// protection timer did not time out lets count the close tries
					}
		    	}
			}
	  		if ((cons[frghtd] == 0) && ((manual_rdoor == 0) || (manual_rdoor == 2)))  // wait until safe
		  	{
		    	timers[trdc] = 0;
		    	timers[trdo] = 0;
		    	timers[trdwel] = 0;
		    	setoutp(o_DCR);
	 			timers[trdodly] = 0;
		    	if((timers[tsafe] >= 30) && (firef == 0) && (rdinp(i_DZ) == 1))
		    	{
					record_fault(f_car_safe_start);
					set_safe_fault();
					clroutp(o_DCR);
					if(rccmsk[cons[carnmb]][position] == 1)
					{
						rdoorf = 1;
			  	    	if ((manual_rdoor == 0) || (manual_rdoor == 2))
							safe_rclosetry++;  // protection timer did not time out lets count the close tries
					}
		    	}
			}
			statusf |= sf_SAFE;
	    	return;
	  	}
#if (Traction == 1)
	}
#endif

	statusf &= ~sf_SAFE;

#if (Traction == 1)

	if (Drive_Type[cons[carnmb]] == 12)
	{
		if (keb_run_verify_seq == 0)
			keb_run_verify_seq = 1;

		verify_run_mode();

		if (keb_run_verify_seq != 3)
			return;
	}
#endif


	door_buz = 0;
	freight_fdoor_alarm = 0;
	freight_rdoor_alarm = 0;
	timers[tdoorbz] = 0;

  	if( (rdinp(i_UP) == 0) && (rdinp(i_DNR) == 0) )
  	{
//		timers[tgroup_hcc]  = 0;
		timers[ccct] = 0;
#if(Traction == 1)
		Velocity = 0;
		Dmd_Velocity = 0;
		if ((cons[sercom] & 8) == 0)
			DAC_Out();
#endif
  	}
  	timers[tgen] = 0;
	timers[tebkdrop] = 0;
	timers[tsoftstp] = 0;
  	timers[tmotion] = 0;
	timers[tpatdly] = 0;
  	hsf = 1;
  	start_floor = position;
  	no_fault = 1;
#if(Traction == 1)
  	timers[tdppflt] = 0;
  	Lev_Mode=0;
  	if(rdinp(i_DT) == 1)
		DT_Open[0] = 0;
  	else
		DT_Open[0] = 1;
  	if(rdinp(i_DT1) == 1)
		DT_Open[1] = 0;
  	else
		DT_Open[1] = 1;
  	if(rdinp(i_DT2) == 1)
		DT_Open[2] = 0;
  	else
		DT_Open[2] = 1;
  	if(rdinp(i_DT3) == 1)
		DT_Open[3] = 0;
  	else
		DT_Open[3] = 1;
  	if(rdinp(i_DT4) == 1)
		DT_Open[4] = 0;
  	else
		DT_Open[4] = 1;
  	if(rdinp(i_DT5) == 1)
		DT_Open[5] = 0;
  	else
		DT_Open[5] = 1;
  	if(rdinp(i_DT6) == 1)
		DT_Open[6] = 0;
  	else
		DT_Open[6] = 1;
  	if(rdinp(i_DTS) == 1)
		DTS_Open = 0;
  	else
		DTS_Open = 1;
  	if(rdinp(i_UT) == 1)
		UT_Open[0] = 0;
  	else
		UT_Open[0] = 1;
  	if(rdinp(i_UT1) == 1)
		UT_Open[1] = 0;
  	else
		UT_Open[1] = 1;
  	if(rdinp(i_UT2) == 1)
		UT_Open[2] = 0;
  	else
		UT_Open[2] = 1;
  	if(rdinp(i_UT3) == 1)
		UT_Open[3] = 0;
  	else
		UT_Open[3] = 1;
  	if(rdinp(i_UT4) == 1)
		UT_Open[4] = 0;
  	else
		UT_Open[4] = 1;
  	if(rdinp(i_UT5) == 1)
		UT_Open[5] = 0;
  	else
		UT_Open[5] = 1;
  	if(rdinp(i_UT6) == 1)
		UT_Open[6] = 0;
  	else
		UT_Open[6] = 1;
  	if(rdinp(i_UTS) == 1)
		UTS_Open = 0;
  	else
		UTS_Open = 1;
#endif

#if (Traction == 1) || (Tract_OL == 1)
	verify_limit_seq(1);		// parameter == 1 for initialization
	verify_uldl_seq(1);		// parameter == 1 for initialization
#endif


  	if((dpref == 1) && ((dcalls == 1) || (dcalls == 3)))  // going up
  	{
		if ((cons[shortfl] != 0) && (cons[vshort_tfl] != 0) && (position == cons[shortfl]))
		{			 // At the lower short floor
			if ((carcb[cons[vshort_tfl]] == 1) || (upcb[cons[vshort_tfl]] == 1) || (downcb[cons[vshort_tfl]] == 1) ||
				(rcarcb[cons[vshort_tfl]] == 1) || (rupcb[cons[vshort_tfl]] == 1) || (rdowncb[cons[vshort_tfl]] == 1) ||
				 (stops[0] == cons[vshort_tfl]))
			{	// Need to run to the upper short floor
				if ((fvars[fvshrtflctl] & 0x01) == 0)
				{		 // Very Short floor relevel
					position++;
					front_slowdown = 0;
					rear_slowdown = 0;
					needstop();				// Set the slowdown flags to open the door
					initial_stop();			// clear timers and record flight times
					reset_nonit = 1;
					clr_door_vars();
					relevel_req = 1;
					preset = 0;
					if (cons[StagRear] == 0)
						setoutp(o_DTR);
					else if (cons[exDHwL] == 0)
						setoutp(o_SFST);
					return;
				}
				else   // Very short floor run
				{
					ignore_uldl_fault = 1;
					UL_ON_Fault = 0;
					DL_ON_Fault = 0;
					DZ_ON_Fault = 0;
					DZA_ON_Fault = 0;
					if (cons[StagRear] == 0)
						setoutp(o_DTR);
					else if (cons[exDHwL] == 0)
						setoutp(o_SFST);
				}
			}
		}
#if(Traction == 1)
    	Velocity = 0;
		Dmd_Velocity = 0;
    	timers[tvpat] = 0;
		if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
			stops[0] = cons[topf];

    	if(stops[0] > position)
			DPP_Target = DPP_Floor_Pos[stops[0]] + DPP_Fl_Offset[stops[0]];
    	else
			DPP_Target = DPP_Floor_Pos[(position + 1)] + DPP_Fl_Offset[position + 1];
    	DPP_Count = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
    	old_dpp = DPP_Count;
#if (Simulator == 1)
		sim_DPP_Count = DPP_Count;
#endif
		preset_encoder_count(DPP_Count);

		if ((cons[EP_Profile] == 1) && (empf != no_ep))
			Vel_Max_Set = Ep_Top_Speed;
		else
			Vel_Max_Set = Top_Speed;

		if (Vel_Max_Set > Vel_Max)
			Vel_Max_Set = Vel_Max;

    	Vel_Step = 0;
    	nstopf = 0;
#endif

		short_fl_run = 0;
		no_high_speed = 0;
		pass_fl = 0;
		if (position < cons[topf])
		{
#if(Traction == 1)
			if (((DPP_Floor_Pos[position + 1] - DPP_Floor_Pos[position]) / Pulses_per_Inch) < (long)(fvars[fvshortdis]/10.0))
#else
			if ((cons[shortfl] == position) || (cons[shortflmid] == position))
#endif
			{		// Next to a short floor 
#if (Traction == 0)
				short_fl_run = 1;	 // Need to run to the upper short floor
#endif
				if ((carcb[position+1] == 1) || (upcb[position+1] == 1) || (downcb[position+1] == 1) ||
					(rcarcb[position+1] == 1) || (rupcb[position+1] == 1) || (rdowncb[position+1] == 1) ||
					(stops[0] == (position+1)))
				{
#if (Traction == 0)
					if (((fvars[fvshort_usdt] == 0) && (cons[shortfl] == position)) || 
						((fvars[fvshortm_usdt] == 0) && (cons[shortflmid] == position)))
					{
						position++;			// no slowdown magnets between short floors
						front_slowdown = 0;
						rear_slowdown = 0;
						needstop();				// Set the slowdown flags to open the door
						hsf = 0;
					}		 // check in else part so slowdown timer is non-zero
					else if ((fvars[fvsfnohsv] == 1) && ((cons[shortfl] == position) || (cons[shortflmid] == position)))
						no_high_speed = 1;
#else
					short_fl_run = 1;	 // Need to run to the upper short floor
#endif
				}
			}
		}

		timers[tshortfl] = 0;

    	dirf = 1;

		if (chk_start(1) == 1)
		{
	#if ((Traction == 1) || (Tract_OL == 1))
			if (fvars[fvbkliftsw] != 0)
				BRK_Pick_Test = 1;
	#endif
			front_slowdown = 0;
			rear_slowdown = 0;
			adv_pre_trq_fault = 0;
			dtmrf = 0;
	    	DZ_ON_Fault = 1;
			DZA_ON_Fault = 1;
			UL_ON_Fault = 1;
			DL_ON_Fault = 1;
			BKS_Run_Fault = 0;
			timers[tbksrun] = 0;
			clroutp(o_LE);        // set the leveling enable output
			clroutp(o_LE1);
			if ((servf == 1) && (procf != 3))
			{
				if (pass_det == 1)
					run_no_pass_cnt = 0;
				else
					run_no_pass_cnt++;
			}
			pass_det = 0;
    		procf = 3;          // go into motion
			timers[tpatdly] = 0;
			timers[tadvptrq] = 0;
			timers[tsafe] = 0;
			safe_fault_latch = 0;

			gripper_test = 15;
			io_fault_cnt = 0;
			don_delay = 0;
			clr_door_vars();
#if(Traction == 1)
			actual_pos = position;
			dz_latch = 2;
			level_stop_fault = 0;
			relev_stop_count = 0;
#endif
		}
		else
		{
			clroutp(o_UP);
			clroutp(o_DNR);
			clroutp(o_UPF);
			clroutp(o_DF);
			clroutp(o_RUN);
			clroutp(o_RUNA);
			clroutp(o_MCC);
			clroutp(o_MCA);
	#if ((Traction == 1) || (Tract_OL == 1))
			drop_brake(c_drop_brake_reset);
	#endif
			if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
				clroutp(o_MST);
			timers[tpatdly] = 0;
			timers[tmotion] = 0;
			timers[tsoftstp] = (int16)(fvars[fvsst] + 15);
		}
    	return;
  	}
  	if((dpref == 2) && (dcalls > 1))      // going down
  	{
		if ((cons[shortfl] != 0) && (cons[vshort_tfl] != 0) && (position == cons[vshort_tfl]))
		{			 // At the upper short floor
			if ((carcb[cons[shortfl]] == 1) || (upcb[cons[shortfl]] == 1) || (downcb[cons[shortfl]] == 1) ||
				(rcarcb[cons[shortfl]] == 1) || (rupcb[cons[shortfl]] == 1) || (rdowncb[cons[shortfl]] == 1) || 
				(stops[0] == cons[shortfl]))
			{	// Need to run to the lower short floor
				if ((fvars[fvshrtflctl] & 0x01) == 0)
				{		 // Very Short floor relevel
					position--;
					front_slowdown = 0;
					rear_slowdown = 0;
					needstop();				// Set the slowdown flags to open the door
					initial_stop();			// clear timers and record flight times
					reset_nonit = 1;
					clr_door_vars();
					relevel_req = 1;
					preset = 0;
					if (cons[StagRear] == 0)
						clroutp(o_DTR);
					else if (cons[exDHwL] == 0)
						clroutp(o_SFST);
					return;
				}
				else   // Very short floor run
				{
					ignore_uldl_fault = 1;
					UL_ON_Fault = 0;
					DL_ON_Fault = 0;
					DZ_ON_Fault = 0;
					DZA_ON_Fault = 0;
					if (cons[StagRear] == 0)
						clroutp(o_DTR);
					else if (cons[exDHwL] == 0)
						clroutp(o_SFST);
				}
			}
		}
#if(Traction == 1)
    	Velocity = 0;
		Dmd_Velocity = 0;
    	timers[tvpat] = 0;
		if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
			stops[0] = cons[bottomf];

    	if((stops[0] < position) && (stops[0] > 0))
			DPP_Target = DPP_Floor_Pos[stops[0]] + DPP_Fl_Offset[stops[0]];
    	else
			DPP_Target = DPP_Floor_Pos[(position - 1)] + DPP_Fl_Offset[position - 1];
    	DPP_Count = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
    	old_dpp = DPP_Count;
#if (Simulator == 1)
		sim_DPP_Count = DPP_Count;
#endif
		preset_encoder_count(DPP_Count);
		if ((cons[EP_Profile] == 1) && (empf != no_ep))
			Vel_Max_Set = Ep_Top_Speed;
		else
			Vel_Max_Set = Top_Speed;

		if (Vel_Max_Set > Vel_Max)
			Vel_Max_Set = Vel_Max;

    	Vel_Step = 0;
    	nstopf = 0;
#endif


		short_fl_run = 0;
		no_high_speed = 0;
		pass_fl = 0;
		if (position > 1)
		{
#if (Traction == 1)
			if (((DPP_Floor_Pos[position] - DPP_Floor_Pos[position - 1]) / Pulses_per_Inch) < (long)(fvars[fvshortdis]/10.0)) 
#else
			if (((cons[shortfl]+1) == position) || ((cons[shortflmid]+1) == position))
#endif
			{
#if (Traction == 0)
				short_fl_run = 1;	 // Need to run to the lower short floor
#endif
				if ((carcb[position-1] == 1) || (upcb[position-1] == 1) || (downcb[position-1] == 1) ||
					(rcarcb[position-1] == 1) || (rupcb[position-1] == 1) || (rdowncb[position-1] == 1) ||
					(stops[0] == (position-1)))
				{
#if (Traction == 0)
					if (((fvars[fvshort_dsdt] == 0) && ((cons[shortfl]+1) == position)) || 
						((fvars[fvshortm_dsdt] == 0) && ((cons[shortflmid]+1) == position)))
					{
						position--;			// no slowdown magnets between short floors
						front_slowdown = 0;
						rear_slowdown = 0;
						needstop();				// Set the slowdown flags to open the door
						hsf = 0;
					}		 // check in else part so slowdown timer is non-zero
					else if ((fvars[fvsfnohsv] == 1) && (((cons[shortfl]+1) == position) || ((cons[shortflmid]+1) == position)))
						no_high_speed = 1;
#else
					short_fl_run = 1;	 // Need to run to the lower short floor
#endif
				}
			}
		}

		timers[tshortfl] = 0;

    	dirf = 2;
			
		if (chk_start(2) == 1)
		{
	#if ((Traction == 1) || (Tract_OL == 1))
			if (fvars[fvbkliftsw] != 0)
				BRK_Pick_Test = 1;
	#endif
			front_slowdown = 0;
			rear_slowdown = 0;
			adv_pre_trq_fault = 0;
			dtmrf = 0;
	    	DZ_ON_Fault = 1;
			DZA_ON_Fault = 1;
			UL_ON_Fault = 1;
			DL_ON_Fault = 1;
			BKS_Run_Fault = 0;
			timers[tbksrun] = 0;
			clroutp(o_LE);        // set the leveling enable output
			clroutp(o_LE1);
			if ((servf == 1) && (procf != 3))
			{
				if (pass_det == 1)
					run_no_pass_cnt = 0;
				else
					run_no_pass_cnt++;
			}
			pass_det = 0;
    		procf = 3;          // go into motion
			timers[tsafe] = 0;
			safe_fault_latch = 0;

			timers[tpatdly] = 0;
			timers[tadvptrq] = 0;
			gripper_test = 15;
			io_fault_cnt = 0;
			don_delay = 0;
			clr_door_vars();
#if(Traction == 1)
			actual_pos = position;
			dz_latch = 2;
			level_stop_fault = 0;
			relev_stop_count = 0;
#endif
		}
		else
		{
			clroutp(o_UP);
			clroutp(o_DNR);
			clroutp(o_UPF);
			clroutp(o_DF);
			clroutp(o_RUN);
			clroutp(o_RUNA);
			clroutp(o_MCC);
			clroutp(o_MCA);
	#if ((Traction == 1) || (Tract_OL == 1))
			drop_brake(c_drop_brake_reset);
	#endif
			if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
				clroutp(o_MST);
			timers[tmotion] = 0;
			timers[tpatdly] = 0;
			timers[tsoftstp] = (int16)(fvars[fvsst] + 15);
		}
  	}
  	return;
}
//******************************
// Check start of run for Hydro 
//******************************

#if ((Traction == 0) && (Tract_OL == 0))

int16 chk_start(int16 cmd)
{
	static int16 dbn_cnt;

	if (io_fault != 0)
		return 0;

    if (cons[Micro_Relev] == 1)
	{
		clroutp(o_UPML);
		clroutp(o_DNML);
	}

	if (cmd == 1)
	{		// run up

		if ((firef == 0) && (ids_return_typ == 0) && (medf == 0))
		{
			// FST must be off
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_FST) == 0)	  // Fst is off
					dbn_cnt ++;		   // Exit the loop when FST goes oFF
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	// FST failed on
				record_fault(f_FST_failed_on);
				io_fault = 1;
				return 0;			
			}
		}

		// Verify that DEL is off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_DEL) == 0)
				dbn_cnt++;
			else
				dbn_cnt = 0;
		}

		if (timers[tiofault] >= c_io_dbn_time) 
		{	// Del failed on
			record_fault(f_delta_on);
			io_fault = 1;
			return 0;			
		}

		if ((cons[SFC_2004_IO] == 1) && (Drive_Type[cons[carnmb]] == 1))
		{
			// Potential input must be on
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_P) == 1)	  // Potential is on
					dbn_cnt ++;		   // Exit the loop when P goes on
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	// No Potential
				record_fault(f_P_off);
				io_fault = 1;
				return 0;			
			}
		}

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_MCC) == 0)	  // MCC turns off
				dbn_cnt ++;		   // Exit the loop when MCC turns off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	// MCC should not be on
			record_fault(f_MCC_on);
			io_fault = 1;
			return 0;
		}

		setoutp(o_MCC);			// Turn on MCC
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_MCC);
			if (rdinp(i_MCC) == 1)
				dbn_cnt ++;			// Exit loop when MCCI is on for 10 counts
			else
				dbn_cnt = 0;
		}

		if (timers[tiofault] >= c_io_dbn_time) 
		{		// if timer expired then MCCI failed off
			record_fault(f_MCC_off);
			io_fault = 1;
			return 0;
		}

		// Verify that MC is turned off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_MCA) == 0)	  // MC turns off
				dbn_cnt ++;		   // Exit the loop when MCC turns off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	// MCI should not be on
			record_fault(f_MCA_on);
			io_fault = 1;
			return 0;
		}

		setoutp(o_MCA);				// Turn on MC
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_MCA);
			if (rdinp(i_MCA) == 1)
				dbn_cnt ++;				// Exit loop if MCI on for 10 counts
			else
				dbn_cnt = 0;
		}
		if (timers[tiofault] >= c_io_dbn_time) 
		{				// If timer expired then MCI failed off
			record_fault(f_MCA_off);
			io_fault = 1;
			return 0;
		}

		// Check to see if delta is on

		timers[tmotion] = 0;
		dbn_cnt = 0;
		while( (dbn_cnt < c_dbn_cnt) && (timers[tmotion] < (2*fvars[fvydel]))) 
		{
			inctime(1);
			if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
			{
			 	if((timers[tmotion] >= fvars[fvydel]) && (rdinp(i_MCA) == 1))
					setoutp(o_MST);			// Turn ofn MST for Y-Delta start
			 	else
					clroutp(o_MST);
			}
			if (rdinp(i_DEL) == 1)
				dbn_cnt ++;						// Exit loop after delta on for 10 counts
			else
				dbn_cnt = 0;
		}

		if (timers[tmotion] >= (2* fvars[fvydel]))
		{			// Delta did not come on
			record_fault(f_delta_off);
			io_fault = 1;
			return 0;
		}


		if ((cons[SFC_2004_IO] == 1) && (Drive_Type[cons[carnmb]] == 1))
		{
			// Potential input must go off 
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_P) == 0)	  // Potential is off
					dbn_cnt ++;		   // Exit the loop when P goes off
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{		// Potential failed on
				record_fault(f_P_on);
				io_fault = 1;
				return 0;			
			}
		}

		// Verify that RUNA is off 
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_RUNA) == 0)	  // RunA is off
				dbn_cnt ++;		   // Exit the loop when Run goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	  // RunA is on when it should be off
			record_fault(f_runa_on);		// Runa failed on
			io_fault = 1;
			return 0;
		}
		

		// Verify that UPI is OFF

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_UP) == 0)
				dbn_cnt ++;		   // Exit the loop when up is off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	// UP input failed
			record_fault(f_up_on);
			io_fault = 1;
			return 0;
		}

		// Verify that UFI is off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_UF) == 0)
				dbn_cnt ++;		   // Exit the loop when up is off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	// UF input failed
			record_fault(f_upf_on);
			io_fault = 1;
			return 0;
		}

		setoutp(o_UP);		// Turn on UP
		if ((hsf == 1) && (no_high_speed == 0))
			setoutp(o_UPF);				// Turn on UP fast

		timers[tiofault] = 0;

		while(timers[tiofault] < 5)
		{						// Delay to allow RUNI input to come on	if RUNA output shorted
			inctime(1);
			setoutp(o_UP);
			if ((hsf == 1) && (no_high_speed == 0))
				setoutp(o_UPF);
		}

		// Verify that RUNA comes on
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_UP);
			if ((hsf == 1) && (no_high_speed == 0))
				setoutp(o_UPF);
			if (rdinp(i_RUNA) == 1)
				dbn_cnt ++;				// Exit loop when RUNI on for 10 counts
			else
				dbn_cnt = 0;
		}
		if (timers[tiofault] >= c_io_dbn_time)
		{				// RUNAI did not come on
			record_fault(f_runa_off);	// runa failed off or up did not turn on
			io_fault = 1;
			return 0;
		}

		// Verify that run is off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_RUN) == 0)	  // Run is off
				dbn_cnt ++;		   // Exit the loop when Run goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	  // Run is on when it should be off
			record_fault(f_runa_runi);
			io_fault = 1;
			return 0;
		}

		setoutp(o_RUNA);	  // Turn on RUNA

		// Verify that run comes on
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUNA);
			if (rdinp(i_RUN) == 1)
				dbn_cnt ++;				// Exit loop when RUNI on for 10 counts
			else
				dbn_cnt = 0;
		}
		if (timers[tiofault] >= c_io_dbn_time)
		{				// RUNI did not come on
			record_fault(f_runa_runi);	// run failed off
			io_fault = 1;
			return 0;
		}

		setoutp(o_RUN);		 // Turn on RUN  (Should cause RUNAI and RUNI to go off)

		// Verify RUNA goes off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUN);
			if (rdinp(i_RUNA) == 0)
				dbn_cnt ++;				// Exit loop if RUNAI goes off
			else
				dbn_cnt = 0;
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{		   // RUNAI did not go off
			record_fault(f_runo_runai);	// run output or runa input failed 
			io_fault = 1;
			return 0;
		}

		// Verify RUN goes off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUN);
			if (rdinp(i_RUN) == 0)
				dbn_cnt ++;				// Exit loop if RUNI goes off
			else
				dbn_cnt = 0;
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{		   // RUNI did not go off
			record_fault(f_runo_runi);			// RUN output failed off or run input failed on
			io_fault = 1;
			return 0;
		}

		// Verify that UP is on

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_UP) == 1)
				dbn_cnt ++;		   // Exit the loop when up is on
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{		   // UPI should be on at this point
			record_fault(f_up_off);
			io_fault = 1;
			return 0;
		}

		if ((hsf == 1) && (rdinp(i_UT) == 1) && (no_high_speed == 0)) 
		{
			// Verify that UF is on

			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_UF) == 1)
					dbn_cnt ++;		   // Exit the loop when up is on
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{		   // UFI should be on at this point
				record_fault(f_upf_off);
				io_fault = 1;
				return 0;
			}
		}
		else
		{
			// Verify that UFI stayted off

			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_UF) == 0)
					dbn_cnt ++;		   // Exit the loop when up is off
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	// UF input failed
				record_fault(f_upf_on);
				io_fault = 1;
				return 0;
			}
		}

		return 1;
	}
	else if (cmd == 2)
	{		// run down

		if ((firef == 0) && (ids_return_typ == 0) && (medf == 0))
		{
			// FST must be off
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_FST) == 0)	  // Fst is off
					dbn_cnt ++;		   // Exit the loop when FST goes oFF
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	// FST failed on
				record_fault(f_FST_failed_on);
				io_fault = 1;
				return 0;			
			}
		}

		// Verify that RUNA is off 
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_RUNA) == 0)	  // RunA is off
				dbn_cnt ++;		   // Exit the loop when Run goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	  // RunA is on when it should be off
			record_fault(f_runa_on);		// Runa failed on
			io_fault = 1;
			return 0;
		}
		
		// Verify that DN is off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_DNR) == 0)	  // Down run is off
				dbn_cnt ++;		   // Exit the loop when down run goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	   // DNI is on when it should be off
			record_fault(f_dnr_on);
			io_fault = 1;
			return 0;
		}

		// Verify that DF is off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_DF) == 0)	  // Down run FAST is off
				dbn_cnt ++;		   // Exit the loop when down run FAST goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	   // DFI is on when it should be off
			record_fault(f_df_on);
			io_fault = 1;
			return 0;
		}

		setoutp(o_DNR);		// Turn on DNR
		if ((hsf == 1) && (no_high_speed == 0))
			setoutp(o_DF);		// Turn on DF
		timers[tiofault] = 0;

		while(timers[tiofault] < 5)
		{				// Delay to allow RUNI to turn on if RUN output shorted
			inctime(1);
			setoutp(o_DNR);		
			if ((hsf == 1) && (no_high_speed == 0))
				setoutp(o_DF);
		}

		// Verify that RUNA comes on
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_DNR);		
			if ((hsf == 1) && (no_high_speed == 0))
				setoutp(o_DF);
			if (rdinp(i_RUNA) == 1)
				dbn_cnt ++;				// Exit loop when RUNI on for 10 counts
			else
				dbn_cnt = 0;
		}
		if (timers[tiofault] >= c_io_dbn_time)
		{				// RUNAI did not come on
			record_fault(f_runa_off);	// runa failed off or up did not turn on
			io_fault = 1;
			return 0;
		}

		// Verify that run is off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_RUN) == 0)	  // Run is off
				dbn_cnt ++;		   // Exit the loop when Run goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	  // Run is on when it should be off
			record_fault(f_runa_runi);
			io_fault = 1;
			return 0;
		}
		
		setoutp(o_RUNA);		 // Turn on RUNA

		// Verify that run comes on
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUNA);
		    if (rdinp(i_RUN) == 1)
				dbn_cnt ++;		   // Exit the loop when run comes on
			else
				dbn_cnt = 0;
		}
		if (timers[tiofault] >= c_io_dbn_time)
		{	   // RUNI did not go on
			record_fault(f_runa_runi);			// run failed off 
			io_fault = 1;
			return 0;
		}

		setoutp(o_RUN);	// Turn on RUN: RUNAI and RUNI should go off

		// Verify RUNA goes off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUN);
			if (rdinp(i_RUNA) == 0)
				dbn_cnt ++;		   // Exit the loop when runA goes off
			else
				dbn_cnt = 0;

		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{		// RUNAI did not go off
			record_fault(f_runo_runai);	// run output or runa input failed 
			io_fault = 1;
			return 0;
		}

		// Verify RUN goes off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUN);
			if (rdinp(i_RUN) == 0)
				dbn_cnt ++;				// Exit loop if RUNI goes off
			else
				dbn_cnt = 0;
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{		   // RUNI did not go off
			record_fault(f_runo_runi);			// RUN output failed off or run input failed on
			io_fault = 1;
			return 0;
		}

		// Verify that DN is on

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_DNR) == 1)	  // Down run is on
				dbn_cnt ++;		   // Exit the loop when down run goes on
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	   // DNI is off when it should be on
			record_fault(f_dnr_off);
			io_fault = 1;
			return 0;
		}


		if ((hsf == 1) && (rdinp(i_DT) == 1) && (no_high_speed == 0))
		{
			// Verify that DF is on

			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_DF) == 1)	  // Down run fast is on
					dbn_cnt ++;		   // Exit the loop when down fast run goes on
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	   // DNI is off when it should be on
				record_fault(f_df_off);
				io_fault = 1;
				return 0;
			}
		}
		else
		{
			// Verify that DF stayed off

			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_DF) == 0)	  // Down run FAST is off
					dbn_cnt ++;		   // Exit the loop when down run FAST goes off
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	   // DFI is on when it should be off
				record_fault(f_df_on);
				io_fault = 1;
				return 0;
			}
		}

		return 1;
	}
	else
		return 0;

}
#endif

//**********************************
// Check start of LEVELING for Hydro 
//**********************************

#if ((Traction == 0) && (Tract_OL == 0))

int16 chk_lev_start(int16 cmd)
{
	static int16 dbn_cnt;

	if (io_fault != 0)
		return 0;

	if (cmd == 1)
	{		// run up


		setoutp(o_MCC);			// Turn on MCC
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_MCC);
			if (rdinp(i_MCC) == 1)
				dbn_cnt ++;			// Exit loop when MCCI is on for 10 counts
			else
				dbn_cnt = 0;
		}

		if (timers[tiofault] >= c_io_dbn_time) 
		{		// if timer expired then MCCI failed off
			record_fault(f_MCC_off);
			io_fault = 1;
			return 0;
		}

		setoutp(o_MCA);				// Turn on MC
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_MCA);
			if (rdinp(i_MCA) == 1)
				dbn_cnt ++;				// Exit loop if MCI on for 10 counts
			else
				dbn_cnt = 0;
		}
		if (timers[tiofault] >= c_io_dbn_time) 
		{				// If timer expired then MCI failed off
			record_fault(f_MCA_off);
			io_fault = 1;
			return 0;
		}

		// Check to see if delta is on

		timers[tmotion] = 0;
		dbn_cnt = 0;
		while( (dbn_cnt < c_dbn_cnt) && (timers[tmotion] < (2*fvars[fvydel]))) 
		{
			inctime(1);
			if (rdinp(i_DEL) == 0)
			{		// delta is not on so turn on MST
				if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
				{
				 	if((timers[tmotion] >= fvars[fvydel]) && (rdinp(i_MCA) == 1))
						setoutp(o_MST);			// Turn ofn MST for Y-Delta start
				 	else
						clroutp(o_MST);
				}
			}
			else if (rdinp(i_DEL) == 1)
			{
				setoutp(o_MST);			// Turn ofn MST for Y-Delta start
				dbn_cnt ++;						// Exit loop after delta on for 10 counts
			}
			else
				dbn_cnt = 0;
		}

		if (timers[tmotion] >= (2* fvars[fvydel]))
		{			// Delta did not come on
			record_fault(f_delta_off);
			io_fault = 1;
			return 0;
		}


		if ((cons[SFC_2004_IO] == 1) && (Drive_Type[cons[carnmb]] == 1))
		{
			// Potential input must go off 
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_P) == 0)	  // Potential is off
					dbn_cnt ++;		   // Exit the loop when P goes off
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{		// Potential failed on
				record_fault(f_P_on);
				io_fault = 1;
				return 0;			
			}
		}


		setoutp(o_UP);		// Turn on UP
		clroutp(o_UPF);				// Turn off UP fast

		timers[tiofault] = 0;

		while(timers[tiofault] < 5)
		{						// Delay to allow RUNI input to come on	if RUNA output shorted
			inctime(1);
			setoutp(o_UP);
		}


		setoutp(o_RUNA);	  // Turn on RUNA
		setoutp(o_RUN);		 // Turn on RUN  (Should cause RUNAI and RUNI to go off)


		// Verify RUNA goes off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUNA);	  // Turn on RUNA
			setoutp(o_RUN);
			if (rdinp(i_RUNA) == 0)
				dbn_cnt ++;				// Exit loop if RUNAI goes off
			else
				dbn_cnt = 0;
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{		   // RUNAI did not go off
			record_fault(f_runo_runai);	// run output or runa input failed 
			io_fault = 1;
			return 0;
		}

		// Verify RUN goes off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUNA);	  // Turn on RUNA
			setoutp(o_RUN);
			if (rdinp(i_RUN) == 0)
				dbn_cnt ++;				// Exit loop if RUNI goes off
			else
				dbn_cnt = 0;
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{		   // RUNI did not go off
			record_fault(f_runo_runi);			// RUN output failed off or run input failed on
			io_fault = 1;
			return 0;
		}

		// Verify that UP is on

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_UP) == 1)
				dbn_cnt ++;		   // Exit the loop when up is on
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{		   // UPI should be on at this point
			record_fault(f_up_off);
			io_fault = 1;
			return 0;
		}

		// Verify that UFI stayted off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_UF) == 0)
				dbn_cnt ++;		   // Exit the loop when up is off
			else
				dbn_cnt = 0;
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{	// UF input failed
			record_fault(f_upf_on);
			io_fault = 1;
			return 0;
		}

		return 1;
	}
	else if (cmd == 2)
	{		// run down


		setoutp(o_DNR);		// Turn on DNR
		clroutp(o_DF);		// Turn off DF

		timers[tiofault] = 0;

		while(timers[tiofault] < 5)
		{				// Delay to allow RUNI to turn on if RUN output shorted
			inctime(1);
			setoutp(o_DNR);		
		}

		setoutp(o_RUNA);		 // Turn on RUNA
		setoutp(o_RUN);	// Turn on RUN: RUNAI and RUNI should go off

		// Verify RUNA goes off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUNA);		 // Turn on RUNA
			setoutp(o_RUN);
			if (rdinp(i_RUNA) == 0)
				dbn_cnt ++;		   // Exit the loop when runA goes off
			else
				dbn_cnt = 0;

		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{		// RUNAI did not go off
			record_fault(f_runo_runai);	// run output or runa input failed 
			io_fault = 1;
			return 0;
		}

		// Verify RUN goes off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			setoutp(o_RUNA);		 // Turn on RUNA
			setoutp(o_RUN);
			if (rdinp(i_RUN) == 0)
				dbn_cnt ++;				// Exit loop if RUNI goes off
			else
				dbn_cnt = 0;
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{		   // RUNI did not go off
			record_fault(f_runo_runi);			// RUN output failed off or run input failed on
			io_fault = 1;
			return 0;
		}

		// Verify that DN is on

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_DNR) == 1)	  // Down run is on
				dbn_cnt ++;		   // Exit the loop when down run goes on
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	   // DNI is off when it should be on
			record_fault(f_dnr_off);
			io_fault = 1;
			return 0;
		}


		// Verify that DF stayed off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_DFI) == 0)	  // Down run FAST is off
				dbn_cnt ++;		   // Exit the loop when down run FAST goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	   // DFI is on when it should be off
			record_fault(f_df_on);
			io_fault = 1;
			return 0;
		}

		return 1;
	}
	else
		return 0;

}
#endif


//*******************************************************
// Check start of run for Traction and Traction Open Loop 
//*******************************************************

#if ((Traction == 1) || (Tract_OL == 1))

int16 chk_start(int16 cmd)
{
	static int16 dbn_cnt;

	if (io_fault != 0) 
		return 0;

	clroutp(o_MCC);      // Clear motor starter output
	clroutp(o_MCA);

	if (cons[EM_BRK] == 7)
	{
		clroutp(o_EBK1);			// Emergency brake must be off to start a run
		clroutp(o_EBK2);
	}
	
	
	if ((cmd == 1) || (cmd == 2))
	{		// start i/o's

		if ((firef == 0) && (ids_return_typ == 0) && (medf == 0))
		{
			// FST must be off
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_FST) == 0)	  // Fst is off
					dbn_cnt ++;		   // Exit the loop when FST goes oFF
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	// FST failed on
				record_fault(f_FST_failed_on);
				io_fault = 1;
				return 0;			
			}
		}

		// Potential input must be on
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_P) == 1)	  // Potential is on
				dbn_cnt ++;		   // Exit the loop when P goes on
			else
				dbn_cnt = 0;
		}

		if (timers[tiofault] >= c_io_dbn_time)
		{	// No Potential
			record_fault(f_P_off);
			io_fault = 1;
			return 0;			
		}

		// check if run is already on
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_RUN) == 0)	  // Run is off
				dbn_cnt ++;		   // Exit the loop when Run goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	  // Run is on when it should be off
			record_fault(f_run_on);
			io_fault = 1;
			return 0;
		}
		
		// Verify that DEL is off

		if (Drive_Type[cons[carnmb]] != 4)
		{
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_DEL) == 0)
					dbn_cnt++;
				else
					dbn_cnt = 0;
			}

			if (timers[tiofault] >= c_io_dbn_time) 
			{	// Del failed on
				record_fault(f_delta_on);
				io_fault = 1;
				return 0;			
			}
		}

		setoutp(o_RUN);		 // Turn on run
		timers[tiofault] = 0;

		while((timers[tiofault] < c_io_dbn_time) && (rdinp(i_RUN) == 0))
		{
			inctime(1);
			setoutp(o_RUN);
		}
		if (timers[tiofault] >= c_io_dbn_time)
		{	   // if timer expired then run must be off
			record_fault(f_run_off);			// run failure off
			io_fault = 1;
			return 0;
		}

		// check if runA is already on
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_RUNA) == 0)	  // RunA is off
				dbn_cnt ++;		   // Exit the loop when Run goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	  // RunA is on when it should be off
			record_fault(f_runa_on);
			io_fault = 1;
			return 0;
		}
		
		setoutp(o_RUNA);
		timers[tiofault] = 0;

		while((timers[tiofault] < c_io_dbn_time) && (rdinp(i_RUNA) == 0))
		{
			inctime(1);
			setoutp(o_RUNA);
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{	  // timer expired so runa must be off
			record_fault(f_runa_off);			// Runa io failed off
			io_fault = 1;
			return 0;
		}

		// Potential input must go off 
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_P) == 0)	  // Potential is off
				dbn_cnt ++;		   // Exit the loop when P goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{		// Potential failed on
			record_fault(f_P_on);
			io_fault = 1;
			return 0;			
		}

		// Verify MCC and MC I/O

		// Verify that MCC is off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_MCC) == 0)	  // MCC turns off
				dbn_cnt ++;		   // Exit the loop when MCC turns off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	// MCC should not be on
			record_fault(f_MCC_on);
			io_fault = 1;
			return 0;
		}

		setoutp(o_MCC);

		// Verify that MCC comes on
		timers[tiofault] = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_MCC) == 0))
		{
			inctime(1);
			setoutp(o_MCC);
		}
		if (timers[tiofault] >= c_io_dbn_time) 
		{	// MCC input is still off
			record_fault(f_MCC_off);
			io_fault = 1;
			return 0;
		}

		// Verify that MC is off
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_MCA) == 0)	  // MC turns off
				dbn_cnt ++;		   // Exit the loop when MC turns off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	// MC should not be on
			record_fault(f_MCA_on);
			io_fault = 1;
			return 0;
		}

		setoutp(o_MCA);

		// Verify that MC comes on
		timers[tiofault] = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_MCA) == 0))
		{
			inctime(1);
			setoutp(o_MCA);
		}
		if (timers[tiofault] >= c_io_dbn_time) 
		{
			record_fault(f_MCA_off);
			io_fault = 1;
			return 0;
		}
		
		if (cons[EM_BRK] == 7)
		{
			// Check if Emergency Brake Switch is already on
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_EBKS) == 0)
					dbn_cnt++;
				else
					dbn_cnt = 0;
			}

			if (timers[tiofault] >= c_io_dbn_time) 
			{	// EBKS failed on
				record_fault(f_em_brk_sw_on);
				io_fault = 1;
				return 0;			
			}

			// check if EBK2 is already on
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_EBK2) == 0)	  // EBK2 is off
					dbn_cnt ++;		   // Exit the loop when EBK2 goes off
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	  // EBK2 is on when it should be off
				record_fault(f_EBK2_on);
				io_fault = 1;
				return 0;
			}

			// check if EBK1 is already on
			timers[tiofault] = 0;
			dbn_cnt = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
			{
				inctime(1);
				if (rdinp(i_EBK1) == 0)	  // EBK1 is off
					dbn_cnt ++;		   // Exit the loop when EBK1 goes off
				else
					dbn_cnt = 0;
			}

			if(timers[tiofault] >= c_io_dbn_time) 
			{	  // EBK1 is on when it should be off
				record_fault(f_EBK1_on);
				io_fault = 1;
				return 0;
			}

			setoutp(o_EBK2);

			// Verify that EBK2 comes on
			timers[tiofault] = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_EBK2) == 0))
			{
				inctime(1);
				setoutp(o_EBK2);
			}
			if (timers[tiofault] >= c_io_dbn_time) 
			{
				record_fault(f_EBK2_off);
				io_fault = 1;
				return 0;
			}
		
			setoutp(o_EBK1);

			// Verify that EBK1 comes on
			timers[tiofault] = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_EBK1) == 0))
			{
				inctime(1);
				setoutp(o_EBK1);
			}
			if (timers[tiofault] >= c_io_dbn_time) 
			{
				record_fault(f_EBK1_off);
				io_fault = 1;
				return 0;
			}
		
		}

		if ((Drive_Type[cons[carnmb]] != 5) && (Drive_Type[cons[carnmb]] != 8) && (Drive_Type[cons[carnmb]] != 10) && (cons[EM_BRK] != 6)) 
		{
			// Verify that delta comes on and stays on for 50 msec consecutive
			if (Drive_Type[cons[carnmb]] == 4)
				dbn_cnt = 10;
			else
				dbn_cnt = 5; 
			
			timers[tiofault] = 0;		// use tiofault for the debounce since it is a 10 msec timer
			timers[tmotion] = 0;		// use tmotion for the fault since it is a 100 msec timer
			while((timers[tiofault] < dbn_cnt) && (timers[tmotion] < (2*fvars[fvydel]))) 
			{		// delay for 50 msec to make sure del is on solid	(100 msec if gen)
				inctime(1);
				if ((cons[GOV_Reset] == 0) && (Drive_Type[cons[carnmb]] == 4))
		 		{
			 		if((timers[tmotion] >= fvars[fvydel]) && (rdinp(i_MCA) == 1))
						setoutp(o_MST);
				 	else
						clroutp(o_MST);
				}
				if (rdinp(i_DEL) == 0)	  // DEL turned off
					timers[tiofault] = 0;		// restart the timer if del goes off
			}

			if (timers[tmotion] >= (2* fvars[fvydel]))
			{	   // Del took too long	or failed to turn on
				if ((cons[EM_BRK] != 0) && (cons[EM_BRK] != 3) && (cons[EM_BRK] != 7))
					record_fault(f_em_brk_sw_off);
				else
					record_fault(f_delta_off);
				io_fault = 1;
				return 0;
			}
		}
	}
	else
		return 0;

	if (cmd == 1)
	{

		// Make sure the up input is off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_UP) == 0)
				dbn_cnt ++;		   // Exit the loop when up is off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	// UP input failed
			record_fault(f_up_on);
			io_fault = 1;
			return 0;
		}

		setoutp(o_UP);

#if(Tract_OL == 0)
		if (hsf == 1)
			setoutp(o_UPF);
#endif
		timers[tiofault] = 0;

		while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_UP) == 0))
		{
			inctime(1);
			setoutp(o_UP);
		}

		if (timers[tiofault] >= c_io_dbn_time) 
		{	// UP input did not come on
			record_fault(f_up_off);
			io_fault = 1;
			return 0;
		}

	}
	else if (cmd == 2)
	{		// run down

		// Make sure the down input is off

		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_DNR) == 0)
				dbn_cnt ++;		   // Exit the loop when DN is off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{	// DN input failed
			record_fault(f_dnr_on);
			io_fault = 1;
			return 0;
		}

		setoutp(o_DNR);

#if(Tract_OL == 0)
		if (hsf == 1)
		{
			setoutp(o_DF);
		}
#endif

		timers[tiofault] = 0;

		while((timers[tiofault] < c_io_dbn_time) && (rdinp(i_DNR) == 0))
		{
			inctime(1);
			setoutp(o_DNR);
		}
		if (timers[tiofault] >= c_io_dbn_time) 
		{	   // DNI input did not come on
			record_fault(f_dnr_off);
			io_fault = 1;
			return 0;
		}
	}

	if ((Drive_Type[cons[carnmb]] == 5) || (Drive_Type[cons[carnmb]] == 8) || (cons[EM_BRK] == 6)) 
	{													 // Deletee Drive_Type == 10  Quattro drive controls the MC.
		if ((cmd == 1) || (cmd == 2))
		{		// start i/o's
			// Verify that delta comes on and stays on for 50 msec consecutive
			dbn_cnt = 5; 
			
			timers[tiofault] = 0;		// use tiofault for the debounce since it is a 10 msec timer
			timers[tmotion] = 0;		// use tmotion for the fault since it is a 100 msec timer
			while((timers[tiofault] < dbn_cnt) && (timers[tmotion] < (2*fvars[fvydel]))) 
			{		// delay for 50 msec to make sure del is on solid	(100 msec if gen)
				inctime(1);
				if (rdinp(i_DEL) == 0)	  // DEL turned off
					timers[tiofault] = 0;		// restart the timer if del goes off
			}

			if (timers[tmotion] >= (2* fvars[fvydel]))
			{	   // Del took too long	or failed to turn on
				if ((cons[EM_BRK] != 0) && (cons[EM_BRK] != 3) && (cons[EM_BRK] != 7))
					record_fault(f_em_brk_sw_off);
				else
					record_fault(f_delta_off);
				io_fault = 1;
				return 0;
			}
		}
	}
	if (cons[EM_BRK] == 7)
	{													 
		if ((fvars[fvembksw] & 0x0001) == 0)
		{
			if ((cmd == 1) || (cmd == 2))
			{		// start i/o's
				// Verify that EBKS comes on and stays on for 50 msec consecutive
				dbn_cnt = 5; 
				
				timers[tiofault] = 0;		// use tiofault for the debounce since it is a 10 msec timer
				timers[tmotion] = 0;		// use tmotion for the fault since it is a 100 msec timer
				while((timers[tiofault] < dbn_cnt) && (timers[tmotion] < (2*fvars[fvydel]))) 
				{		// delay for 50 msec to make sure EBKS is on solid	(100 msec if gen)
					inctime(1);
					if (rdinp(i_EBKS) == 0)	  // EBKS turned off
						timers[tiofault] = 0;		// restart the timer if del goes off
				}

				if (timers[tmotion] >= (2* fvars[fvydel]))
				{	   // EBKS took too long or failed to turn on
					record_fault(f_em_brk_sw_off);
					io_fault = 1;
					return 0;
				}
			}
		}
	}


#if ((TS5300 == 1) || (TS3300 == 1))
	outp(DIO2_port,DIO2_out |= 0x40);
#endif
		
	return 1;
}

#endif

//************************************************************
// Check start of LEVELING for Traction and Traction Open Loop 
//************************************************************

#if ((Traction == 1) || (Tract_OL == 1))

int16 chk_lev_start(int16 cmd)
{
	static int16 dbn_cnt;

	if (io_fault != 0) 
		return 0;
	
	if ((cmd == 1) || (cmd == 2))
	{		// start i/o's

		// Potential input must be on
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if ((rdinp(i_P) == 1) || (rdinp(i_RUNA) == 1))	  // Potential is on or run is already up
				dbn_cnt ++;		   // Exit the loop when P goes on
			else
				dbn_cnt = 0;
		}

		if (timers[tiofault] >= c_io_dbn_time)
		{	// No Potential
			record_fault(f_P_off);
			io_fault = 1;
			return 0;			
		}

		setoutp(o_RUN);		 // Turn on run
		timers[tiofault] = 0;

		while((timers[tiofault] < c_io_dbn_time) && (rdinp(i_RUN) == 0))
		{
			inctime(1);
			setoutp(o_RUN);
		}
		if (timers[tiofault] >= c_io_dbn_time)
		{	   // if timer expired then run must be off
			record_fault(f_run_off);			// run failure off
			io_fault = 1;
			return 0;
		}

		setoutp(o_RUNA);
		timers[tiofault] = 0;

		while((timers[tiofault] < c_io_dbn_time) && (rdinp(i_RUNA) == 0))
		{
			inctime(1);
			setoutp(o_RUNA);
		}
		if(timers[tiofault] >= c_io_dbn_time) 
		{	  // timer expired so runa must be off
			record_fault(f_runa_off);			// Runa io failed off
			io_fault = 1;
			return 0;
		}

		// Potential input must go off 
		timers[tiofault] = 0;
		dbn_cnt = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (dbn_cnt < c_dbn_cnt))
		{
			inctime(1);
			if (rdinp(i_P) == 0)	  // Potential is off
				dbn_cnt ++;		   // Exit the loop when P goes off
			else
				dbn_cnt = 0;
		}

		if(timers[tiofault] >= c_io_dbn_time) 
		{		// Potential failed on
			record_fault(f_P_on);
			io_fault = 1;
			return 0;			
		}

		// Verify MCC and MC I/O


		setoutp(o_MCC);

		// Verify that MCC comes on
		timers[tiofault] = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_MCC) == 0))
		{
			inctime(1);
			setoutp(o_MCC);
		}
		if (timers[tiofault] >= c_io_dbn_time) 
		{	// MCC input is still off
			record_fault(f_MCC_off);
			io_fault = 1;
			return 0;
		}

		setoutp(o_MCA);

		// Verify that MC comes on
		timers[tiofault] = 0;
		while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_MCA) == 0))
		{
			inctime(1);
			setoutp(o_MCA);
		}
		if (timers[tiofault] >= c_io_dbn_time) 
		{
			record_fault(f_MCA_off);
			io_fault = 1;
			return 0;
		}
		
		if (cons[EM_BRK] == 7)
		{

			setoutp(o_EBK2);

			// Verify that EBK2 comes on
			timers[tiofault] = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_EBK2) == 0))
			{
				inctime(1);
				setoutp(o_EBK2);
			}
			if (timers[tiofault] >= c_io_dbn_time) 
			{
				record_fault(f_EBK2_off);
				io_fault = 1;
				return 0;
			}
		
			setoutp(o_EBK1);

			// Verify that EBK1 comes on
			timers[tiofault] = 0;
			while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_EBK1) == 0))
			{
				inctime(1);
				setoutp(o_EBK1);
			}
			if (timers[tiofault] >= c_io_dbn_time) 
			{
				record_fault(f_EBK1_off);
				io_fault = 1;
				return 0;
			}
		
		}

		if ((Drive_Type[cons[carnmb]] != 5) && (Drive_Type[cons[carnmb]] != 8) && (Drive_Type[cons[carnmb]] != 10) && (cons[EM_BRK] != 6)) 
		{
			// Verify that delta comes on and stays on for 50 msec consecutive
			if (Drive_Type[cons[carnmb]] == 4)
				dbn_cnt = 10;
			else
				dbn_cnt = 5; 
			
			timers[tiofault] = 0;		// use tiofault for the debounce since it is a 10 msec timer
			timers[tmotion] = 0;		// use tmotion for the fault since it is a 100 msec timer
			while((timers[tiofault] < dbn_cnt) && (timers[tmotion] < (2*fvars[fvydel]))) 
			{		// delay for 50 msec to make sure del is on solid	(100 msec if gen)
				inctime(1);
				if ((cons[GOV_Reset] == 0) && (Drive_Type[cons[carnmb]] == 4))
		 		{
			 		if((timers[tmotion] >= fvars[fvydel]) && (rdinp(i_MCA) == 1))
						setoutp(o_MST);
				 	else
						clroutp(o_MST);
				}
				if (rdinp(i_DEL) == 0)	  // DEL turned off
					timers[tiofault] = 0;		// restart the timer if del goes off
			}

			if (timers[tmotion] >= (2* fvars[fvydel]))
			{	   // Del took too long	or failed to turn on
				if ((cons[EM_BRK] != 0) && (cons[EM_BRK] != 3) && (cons[EM_BRK] != 7))
					record_fault(f_em_brk_sw_off);
				else
					record_fault(f_delta_off);
				io_fault = 1;
				return 0;
			}
		}
	}
	else
		return 0;

	if (cmd == 1)
	{

		// Make sure the up output is ON


		setoutp(o_UP);

#if(Tract_OL == 0)
		if (hsf == 1)
			setoutp(o_UPF);
#endif
		timers[tiofault] = 0;

		while ((timers[tiofault] < c_io_dbn_time) && (rdinp(i_UP) == 0))
		{
			inctime(1);
			setoutp(o_UP);
		}

		if (timers[tiofault] >= c_io_dbn_time) 
		{	// UP input did not come on
			record_fault(f_up_off);
			io_fault = 1;
			return 0;
		}

	}
	else if (cmd == 2)
	{		// run down

		// Make sure the down output is ON


		setoutp(o_DNR);

#if(Tract_OL == 0)
		if (hsf == 1)
		{
			setoutp(o_DF);
		}
#endif

		timers[tiofault] = 0;

		while((timers[tiofault] < c_io_dbn_time) && (rdinp(i_DNR) == 0))
		{
			inctime(1);
			setoutp(o_DNR);
		}
		if (timers[tiofault] >= c_io_dbn_time) 
		{	   // DNI input did not come on
			record_fault(f_dnr_off);
			io_fault = 1;
			return 0;
		}
	}

	if ((Drive_Type[cons[carnmb]] == 5) || (Drive_Type[cons[carnmb]] == 8) || (cons[EM_BRK] == 6)) 
	{													 // Deletee Drive_Type == 10  Quattro drive controls the MC.
		if ((cmd == 1) || (cmd == 2))
		{		// start i/o's
			// Verify that delta comes on and stays on for 50 msec consecutive
			dbn_cnt = 5; 
			
			timers[tiofault] = 0;		// use tiofault for the debounce since it is a 10 msec timer
			timers[tmotion] = 0;		// use tmotion for the fault since it is a 100 msec timer
			while((timers[tiofault] < dbn_cnt) && (timers[tmotion] < (2*fvars[fvydel]))) 
			{		// delay for 50 msec to make sure del is on solid	(100 msec if gen)
				inctime(1);
				if (rdinp(i_DEL) == 0)	  // DEL turned off
					timers[tiofault] = 0;		// restart the timer if del goes off
			}

			if (timers[tmotion] >= (2* fvars[fvydel]))
			{	   // Del took too long	or failed to turn on
				if ((cons[EM_BRK] != 0) && (cons[EM_BRK] != 3) && (cons[EM_BRK] != 7))
					record_fault(f_em_brk_sw_off);
				else
					record_fault(f_delta_off);
				io_fault = 1;
				return 0;
			}
		}
	}
	if (cons[EM_BRK] == 7)
	{													 
		if ((fvars[fvembksw] & 0x0001) == 0)
		{
			if ((cmd == 1) || (cmd == 2))
			{		// start i/o's
				// Verify that EBKS comes on and stays on for 50 msec consecutive
				dbn_cnt = 5; 
				
				timers[tiofault] = 0;		// use tiofault for the debounce since it is a 10 msec timer
				timers[tmotion] = 0;		// use tmotion for the fault since it is a 100 msec timer
				while((timers[tiofault] < dbn_cnt) && (timers[tmotion] < (2*fvars[fvydel]))) 
				{		// delay for 50 msec to make sure EBKS is on solid	(100 msec if gen)
					inctime(1);
					if (rdinp(i_EBKS) == 0)	  // EBKS turned off
						timers[tiofault] = 0;		// restart the timer if EBKS goes off
				}

				if (timers[tmotion] >= (2* fvars[fvydel]))
				{	   // EBKS took too long or failed to turn on
					record_fault(f_em_brk_sw_off);
					io_fault = 1;
					return 0;
				}
			}
		}
	}

	return 1;
}

#endif


// *****************************************
// This Procedure clears all motion outputs
// *****************************************
void clrall()
{
  	clroutp(o_DO);
  	clroutp(o_DC);
  	if (cons[rear] != 0)
  	{
			clroutp(o_DCR);			
			clroutp(o_DOR);
  	}
  	if (cons[Auto_Swing_DO] == 1)
  	{
    	clroutp(o_FSDO);
	  	if (cons[rear] != 0)
			clroutp(o_RSDO);
  	}
  	nudg_buz = 0;
  	rnudg_buz	= 0;
  	clroutp(o_RUN);
  	clroutp(o_MCC);
  	clroutp(o_MCA);
  	clroutp(o_RUNA);
#if ((Traction == 1) || (Tract_OL == 1))
	if (hold_brake_overspeed == 0)
  		drop_brake(c_drop_brake_reset);
#endif

#if((Traction == 0)&& (Tract_OL == 0))
	if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
	{
  		if(rdinp(i_UP) == 0)
	  		clroutp(o_MST);
	}
    if (cons[Micro_Relev] == 1)
	{
		clroutp(o_UPML);
		clroutp(o_DNML);
	}	
#endif
  	clroutp(o_DNR);
  	clroutp(o_DF);
  	clroutp(o_UPF);
  	clroutp(o_UP);
  	clrcc(0);
  	clrhc();
  	clrlant();
}

//*********************************************
// Clear direction Arrow procedure
//*********************************************

void clr_dir_arrow (void)
{
	up_dir_arrow = 0;
	dn_dir_arrow = 0;
	clroutp(o_UDAC);
	clroutp(o_DDAC);
	if (cons[RGB_CC] == 1)
	{
		clroutp(o_ATUL);
		clroutp(o_ATDL);
	}
}

// ******************************************
// This is the clear lanterns procedure
// ******************************************
void clrlant()
{
	lant_up = 0;
	lant_dn = 0;
	rlant_up = 0;
	rlant_dn = 0;
	cab_lant_up = 0;
	cab_lant_dn = 0;
	cab_rlant_up = 0;
	cab_rlant_dn = 0;

	if ((cons[dispis] & 2) != 0)
    	clroutp(o_LD);
	if (((cons[mand] == 0) && (cons[frghtd] == 0) && (cons[RCM_HWDoor] == 0)) || ((cons[dispis] & 2) != 0))
     	clroutp(o_LU);
	clroutp(o_CDL);
	clroutp(o_CUL);
	clroutp(o_CDLR);
	clroutp(o_CULR);
	
  return;
}
//*******************************************
// This is the Cycle Run Routine
//*******************************************

void cycle_run(void)
{
	if (fvars[fvcycrun] != 0)
	{
		if ( (servf == 1) && (dcalls == 0) &&         	// in service and no calls
		     ((cons[mand] == 2) || ((doorf == 0) && (rdoorf == 0))) && 		// Car has swing doors or Doors are closed
		     (dirf == 0) && (dpref == 0) )									// No direction flag and No direction preference
		{
			if ((minute_st == rt_minute) && (hour_st == rt_hour) && (day_st >= rt_day))
			{
				day_st = (int16)(rt_day + (rt_hour + fvars[fvcycrun]) / 24);
				if (day_st > 364)
					day_st -= 364;
				hour_st = (int16)((rt_hour + fvars[fvcycrun]) % 24);
				minute_st = rt_minute;

				if (position > (((cons[topf] - cons[bottomf]) + 1)/2))
					zone_fl = cons[bottomf];
				else
					zone_fl = cons[topf];
			}
			prev_minute = 61;		// force an update
		}
		else
		{
			if (rt_minute != prev_minute)
			{
				day_st = (int16)(rt_day + (rt_hour + fvars[fvcycrun]) / 24);
				if (day_st > 364)
					day_st -= 364;
				hour_st = (int16)((rt_hour + fvars[fvcycrun]) % 24);
				minute_st = rt_minute;
			}
			prev_minute = rt_minute;
		}
	}
	else
	{
		if (rt_minute != prev_minute)
		{
			day_st = (int16)(rt_day + (rt_hour + fvars[fvcycrun]) / 24);
			if (day_st > 364)
				day_st -= 364;
			hour_st = (int16)((rt_hour + fvars[fvcycrun]) % 24);
			minute_st = rt_minute;
		}
		prev_minute = rt_minute;
	}
}


//*******************************************
// This is the Diagnostics Mode
//*******************************************
void diag(void)
{


	keybrd_control();


	if ((inctime_count & 0x01) == 0)
   		Refresh_LCD();
	else
	{
		if (video_exist == 1)
			video_display_control();
	}
   	
   	dpyspi_control();
   	

	if ((fvars[fvcomdiag] & 0x01) != 0)
		comm_debug(USR1COM);
	else if ((fvars[fvcomdiag] & 4) != 0)
		galcom(USR1COM);
	else
		comm_diag(USR1COM);
	
	if ((fvars[fvcomdiag] & 0x02) != 0)
		comm_debug(USR2COM);
	else if ((fvars[fvcomdiag] & 8) != 0)
		galcom(USR2COM);
	else
	{
			
		if (Dispatcher == cons[carnmb])
		{
			if ((cons[ids] & 1) != 0)
				ids_comm();
			else
			{
				ids_uppeak = 0;
				ids_dnpeak = 0;
				ids_alt_fl_sec = 0;
				ids_ncu = 0;
				ids_alt_lby = 0;
				ids_alt_park = 0;
				comm_diag(USR2COM);
			}
		}
		else
		{
			ids_refresh = 1;
			ids_uppeak = 0;
			ids_dnpeak = 0;
			ids_alt_fl_sec = 0;
			ids_ncu = 0;
			ids_alt_lby = 0;
			ids_alt_park = 0;
			
			ui_uppeak = 0;
			ui_dnpeak = 0;
			ui_alt_fl_sec = 0;
			ui_ncu = 0;
			ui_alt_lby = 0;
			ui_alt_park = 0;
		}

		// Restart the com to enable or disable the RTS (485 Transmitter)
		if (prev_disp_com2 != Dispatcher)
			Restart_Com(USR2COM);
		prev_disp_com2 = Dispatcher;
	}
	
  	if(Current_Fault != 0)
  	{
    	if(timers[tfltled] >= 300)
	    	Current_Fault = 0;
  	}
}

// **********************************************
// Turn on the diagnostic Led
// **********************************************

void diag_led_on(void)
{
	if (fvars[fvcputiming] == 0)
		SIU.GPDO[Z6_LED].R = 0x01;
}

// **********************************************
// Turn off the diagnostic Led
// **********************************************

void diag_led_off(void)
{
	if (fvars[fvcputiming] == 0)
		SIU.GPDO[Z6_LED].R = 0x00;
}

// **********************************************
// This is direction selection procedure
// **********************************************
void dirsel()
{
int16 i,cbelow=0,cabove=0;

// int16 ocbelow=0,ocabove=0;
int16 recall_fl;

#if ((Traction == 1) || (Tract_OL == 1))
// if earth quake
  	if(cons[equake] != 0)                 // is earth quake feature enabled
  	{
	    if (((eqf >= 3) && ((rdinp(i_UL) == 0) || (rdinp(i_DL) == 0)))	// collision switch is on
	    	&& ((empf == 0) || (empf == ep_select) || (empf == ep_recall)))       
	    {				 // Collision switch on and allowed to run
	      	g_park[cons[carnmb]] = 0;
			lby_req[cons[carnmb]] = 0;
			if ((cons[firesv] == 2) && (cons[ansi] >= 2004))
			{						// prevent car from moving until car call placed
				get_onward_calls();
				if ((rdinp(i_FFS) == 0) || 
					(rdinp(i_SS) == 0) ||
					((fire_stopsw_hold == 1) &&	((firef > 3) || (rfiref > 3)) &&
						((onward_cc == 0) && (rdinp(i_CC(position)) == 0) &&
							((cons[rear] == 0) || (rdinp(i_CCR(position)) == 0)))))
				{
						dpref = 0;
						dcalls = 0;
						set_dir_arrow();
				      	return;
				}
			}
	      	if (above_cwt == 1)   // above the counter wieghts
	      	{
				dpref = 1;      // up preference
				dcalls = 1;     // call above
				dirf = 1;		// up direction
				stops[0] = cons[topf];
	      	}
	      	else                              // below the counter wieghts
	      	{
			    stops[0] = cons[bottomf];
				dpref = 2;      // down preference
				dcalls = 2;     // call below
				dirf = 2;		// down direction
	      	}
			set_dir_arrow();
	      	return;
	    }
		else if (eqf == 4)
		{
			dpref = 0;
			dcalls = 0;
			set_dir_arrow();
			return;
		}
  	}
#else
// if earth quake
  	if(cons[equake] != 0)                 // is earth quake feature enabled
  	{
		if (eqf == 4)
		{
			dpref = 0;
			dcalls = 0;
			set_dir_arrow();
			return;
		}
  	}

#endif

	if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
	{
		if ((rdinp(i_ATTUP) == 1) && (position != cons[topf]))
			cabove = 1;

		if ((rdinp(i_ATTDN) == 1) && (position != cons[bottomf]))
			cbelow = 1;

    	if((cabove == 0) && (cbelow == 0))
      		dcalls = 0;
    	if(cabove == 1)
      		dcalls = 1;
    	if(cbelow == 1)
      		dcalls = 2;
    	if((cbelow == 1)&&(cabove == 1))
      		dcalls = 3;

		if ((servf == 19) && (firef == 0) && (rfiref == 0))
			dcalls = 0;

		if ((empf != 0) && (empf != ep_select) && (empf != ep_recall))
			dcalls = 0;

    	setpref();
    	return;
	}

// Emergency Power Recall Operation
	if ((empf != 0) && (empf != ep_select))			// on emergency power and not selected to run automatic
	{
		if (empf == ep_recall)	// Recall Car 
		{
			
		    g_park[cons[carnmb]] = 0;
			lby_req[cons[carnmb]] = 0;

			if (firef >= 4)
			{					  // on phase 2
#if ((Traction == 0) && (Tract_OL == 0))
		    	if( ((firef == 5) || (firef == 6)) && ((cons[Australia] == 0) || (fs2_start == 1) || ((procf >= 3) && (procf <= 11)) ) )   // normal phase 2 operation
		    	{									  // and no emp seq operaiton
		      		for(i=cons[bottomf]; i <= cons[topf]; i++)
		      		{
						if(carcb[i] == 1)
						{
							if ((i > position) && ((cons[EMPop] & 0x02) != 0))
				    			cabove = 1;
				  			if(i < position)
				    			cbelow = 1;
						}
						if(cons[rear] != 0)
						{
							if(rcarcb[i] == 1)
							{
								if ((i > position) && ((cons[EMPop] & 0x02) != 0))
					    			cabove = 1;
					  			if(i < position)
					    			cbelow = 1;
							}
						}
		      		}
		      		if((cabove == 0) && (cbelow == 0))
						dcalls = 0;
		      		if(cabove == 1)
						dcalls = 1;
		      		if(cbelow == 1)
						dcalls = 2;
		      		if((cbelow == 1)&&(cabove == 1))
						dcalls = 3;
		      		setpref();
		    	}
		    	else        // door hold operation or power went off
		    	{
		      		dpref = 0;
		      		dcalls = 0;
		    	}
#else
		    	if( ((firef == 5) || (firef == 6)) && ((cons[Australia] == 0) || (fs2_start == 1) || ((procf >= 3) && (procf <= 11)) ) )   // normal phase 2 operation
		    	{
		      		for(i=cons[bottomf]; i <= cons[topf]; i++)
		      		{
						if(carcb[i] == 1)
						{
				 			if(i > position)
				    			cabove = 1;
				  			if(i < position)
				    			cbelow = 1;
						}
						if(cons[rear] != 0)
						{
							if(rcarcb[i] == 1)
							{
					 			if(i > position)
					   	 			cabove = 1;
					  			if(i < position)
					    			cbelow = 1;
							}
						}
		      		}
		      		if((cabove == 0) && (cbelow == 0))
						dcalls = 0;
		      		if(cabove == 1)
						dcalls = 1;
		      		if(cbelow == 1)
						dcalls = 2;
		      		if((cbelow == 1)&&(cabove == 1))
						dcalls = 3;
		      		setpref();
		    	}
		    	else        // door hold operation or power went off
		    	{
		      		dpref = 0;
		      		dcalls = 0;
		    	}
#endif
			}
			else if ((cons[ansi] >= 2007) && ((servf == 2) || (servf == 4)))
			{			 // Allow independent or attendant car to run during recall
	      		for(i=cons[bottomf]; i <= cons[topf]; i++)
	      		{
					if(carcb[i] == 1)
					{
			 			if(i > position)
			    			cabove = 1;
			  			if(i < position)
			    			cbelow = 1;
					}
					if(cons[rear] != 0)
					{
						if(rcarcb[i] == 1)
						{
				 			if(i > position)
				   	 			cabove = 1;
				  			if(i < position)
				    			cbelow = 1;
						}
					}
	      		}
	      		if((cabove == 0) && (cbelow == 0))
					dcalls = 0;
	      		if(cabove == 1)
					dcalls = 1;
	      		if(cbelow == 1)
					dcalls = 2;
	      		if((cbelow == 1)&&(cabove == 1))
					dcalls = 3;
	      		setpref();
	      		return;
			}
			else if (medf == 3)
			{
			    dpref = 0;        // no preference
			    dcalls = 0;       // no calls
			}
			else
			{	   // normal operation or on phase 1

				if (medf == 1) 
					recall_fl = fvars[fvmedfl];
				else if (medf == 2)
					recall_fl = position;
				else if (firef == 1)
					recall_fl = fvars[fvfs1f];
				else if (firef == 2)
					recall_fl = fvars[fvfs1af];
				else if (firef == 3)
					recall_fl = position;
				else
					recall_fl = fvars[fvepfl];

			    if(position > recall_fl) // elevator higher than main eggress
			    {
			      	dpref = 2;        // down preference
			      	dcalls = 2;       // call below
			    }
#if ((Traction == 1) || (Tract_OL == 1))
			    else if(position < recall_fl) // elevator lower than recall floor
			    {
			      	dpref = 1;        // up preference
			      	dcalls = 1;       // call above
			    }
			    else if(position == recall_fl) // elevator at the recall floor
			    {
			      	dpref = 0;        // no preference
			      	dcalls = 0;       // no calls
			    }
#else			  // Hydro
				else if ((cons[EMPop] & 0x02) != 0)
				{
				    if(position < recall_fl) // elevator lower than recall floor
				    {
				      	dpref = 1;        // up preference
				      	dcalls = 1;       // call above
				    }
				    else if(position == recall_fl) // elevator at the recall floor
				    {
				      	dpref = 0;        // no preference
				      	dcalls = 0;       // no calls
				    }
				}
			    else
			    {
			    	 if((position == recall_fl) && (rdinp(i_DL) == 0) && (rdinp(i_DT) == 1)) 
				    {
				      	dpref = 2;        // down preference
				      	dcalls = 2;       // call below
						dirf = 2;
				    }
				    else if((position == recall_fl) || (rdinp(i_DT) == 0))  // elevator at the recall floor
				    {
				      	dpref = 0;        // no preference
				      	dcalls = 0;       // no calls
				    }
					else if(rdinp(i_DT) == 1) // not at botom floor
				    {
				      	dpref = 2;        // down preference
				      	dcalls = 2;       // call below
						dirf = 2;
				    }
				}
#endif
				if ((cons[ansi] < 2007) && ((procf >= 14) && (procf <= 16)) && ((ind() == 1) || 
					(((cons[att] == 1) || (cons[att] == 2)) && (rdinp(i_ATT) == 1))))
				{			 // Prevent independent or attendant car from running during recall	when at the floor
					dpref = 0;
					dcalls = 0;
					dirf = 0;
				}
			    stops[0] = recall_fl;
			}
		}
		else
		{
	      	dpref = 0;        // no preference
	      	dcalls = 0;       // no calls
		}
	    return;
	}

// if low oil on a hydro
#if ((Traction == 0) && (Tract_OL == 0))
  	if(stallf != 0)
  	{
		g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;

		if (firef >= 4)
		{					  // on phase 2
	    	if( ((firef == 5) || (firef == 6)) && ((cons[Australia] == 0) || (fs2_start == 1) || ((procf >= 3) && (procf <= 11)) ) )   // normal phase 2 operation
	    	{
				cabove = 0;
	      		for(i=cons[bottomf]; i <= cons[topf]; i++)
		      	{
					if(carcb[i] == 1)
					{
			  			if(i < position)
			    			cbelow = 1;
					}
					if(cons[rear] != 0)
					{
						if(rcarcb[i] == 1)
						{
				  			if(i < position)
				    			cbelow = 1;
						}
					}
	      		}
	      		if(cbelow == 1)
					dcalls = 2;
				else
					dcalls = 0;
	      		setpref();
	    	}
	    	else        // door hold operation or power went off
	    	{
	      		dpref = 0;
	      		dcalls = 0;
	    	}
		}
		else if (medf == 3)
		{
		    dpref = 0;        // no preference
		    dcalls = 0;       // no calls
		}
		else
		{	   // normal operation or on phase 1

			if (medf == 1) 
				recall_fl = fvars[fvmedfl];
			else if (medf == 2)
				recall_fl = position;
			else if (firef == 1)
				recall_fl = fvars[fvfs1f];
			else if (firef == 2)
				recall_fl = fvars[fvfs1af];
			else if (firef == 3)
				recall_fl = position;
			else
				recall_fl = cons[bottomf];

		    if(position > recall_fl) // elevator higher than main eggress
		    {
		      	dpref = 2;        // down preference
		      	dcalls = 2;       // call below
				dirf = 2;
		    }
		    else if((position == recall_fl) && (rdinp(i_DL) == 0) && (rdinp(i_DT) == 1)) 
		    {
		      	dpref = 2;        // down preference
		      	dcalls = 2;       // call below
				dirf = 2;
		    }
		    else if((position == recall_fl) || (rdinp(i_DT) == 0))  // elevator at the recall floor
		    {
		      	dpref = 0;        // no preference
		      	dcalls = 0;       // no calls
		    }
			else if(rdinp(i_DT) == 1) // not at botom floor
		    {
		      	dpref = 2;        // down preference
		      	dcalls = 2;       // call below
				dirf = 2;
		    }
			stops[0] = recall_fl;

		}
	    return;
	}
#endif


// if reset
  	if(servf == 12)       // reset dive up
  	{
	    g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;
	    dpref = 1;          // up preference
	    dcalls = 1;         // call above
	    stops[0] = cons[topf];
	    return;
  	}
  	if(servf == 13)       // reset dive down
  	{
	    g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;
	    dpref = 2;          // down preference
	    dcalls = 2;         // call below
	    stops[0] = cons[bottomf];
	    return;
  	}

	if (cons[cblue] == 1)
	{
    	if (hsvf == 1)    // Hospital Emergency Operation
    	{
      		for(i=cons[bottomf]; i <= cons[topf]; i++)
      		{
				if(carcb[i] == 1)
				{
		 			if(i > position)
		    			cabove = 1;
		  			if(i < position)
		    			cbelow = 1;
				}
				if(cons[rear] != 0)
				{
					if(rcarcb[i] == 1)
					{
			 			if(i > position)
			   	 			cabove = 1;
			  			if(i < position)
			    			cbelow = 1;
					}
				}
      		}
      		if((cabove == 0) && (cbelow == 0))
				dcalls = 0;
      		if(cabove == 1)
				dcalls = 1;
      		if(cbelow == 1)
				dcalls = 2;
      		if((cbelow == 1)&&(cabove == 1))
				dcalls = 3;
      		setpref();
      		return;
    	}
	}

	if (medf != 0)
	{
		if (medf == 1)
		{
	    	g_park[cons[carnmb]] = 0;
			lby_req[cons[carnmb]] = 0;
	    	if(position > fvars[fvmedfl]) // elevator higher than main eggress
	    	{
	      		dpref = 2;        // down preference
	      		dcalls = 2;       // call below
	    	}
	    	if(position < fvars[fvmedfl]) // elevator lower than main eggress
	    	{
	      		dpref = 1;        // up preference
	      		dcalls = 1;       // call above
	    	}
	    	if(position == fvars[fvmedfl]) // elevator at the main eggress
	    	{
	      		dpref = 0;        // no preference
	      		dcalls = 0;       // no calls
	    	}
	    	stops[0] = fvars[fvmedfl];
			set_dir_arrow();
	    	return;
		}
	}
  	else if(firef == 1)
  	{	// if fire service phase 1 and main eggress
    	g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;
    	if(position > fvars[fvfs1f]) // elevator higher than main eggress
    	{
      		dpref = 2;        // down preference
      		dcalls = 2;       // call below
    	}
    	if(position < fvars[fvfs1f]) // elevator lower than main eggress
    	{
      		dpref = 1;        // up preference
      		dcalls = 1;       // call above
    	}
    	if(position == fvars[fvfs1f]) // elevator at the main eggress
    	{
      		dpref = 0;        // no preference
      		dcalls = 0;       // no calls
    	}
    	stops[0] = fvars[fvfs1f];
    	return;
  	}
// if fire service phase 1 and alternate eggress
  	else if(firef == 2)
  	{
    	g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;
    	if(position > fvars[fvfs1af]) // elevator higher than alternate eggress
    	{
      		dpref = 2;        // down preference
      		dcalls = 2;       // call below
    	}
    	if(position < fvars[fvfs1af]) // elevator lower than alternate eggress
    	{
      		dpref = 1;        // up preference
      		dcalls = 1;       // call above
    	}
    	if(position == fvars[fvfs1af]) // elevator at the alternate eggress
    	{
      		dpref = 0;        // no preference
      		dcalls = 0;       // no calls
    	}
    	stops[0] = fvars[fvfs1af];
   		return;
  	}
// if fire service phase 2
  	if(firef >= 3)
  	{
    	g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;
    	if( ((firef == 5) || (firef == 6)) && ((cons[Australia] == 0) || (fs2_start == 1) || ((procf >= 3) && (procf <= 11)) ) )   // normal phase 2 operation
    	{
      		for(i=cons[bottomf]; i <= cons[topf]; i++)
      		{
				if(carcb[i] == 1)
				{
		 			if(i > position)
		    			cabove = 1;
		  			if(i < position)
		    			cbelow = 1;
				}
				if(cons[rear] != 0)
				{
					if(rcarcb[i] == 1)
					{
			 			if(i > position)
			   	 			cabove = 1;
			  			if(i < position)
			    			cbelow = 1;
					}
				}
      		}
      		if((cabove == 0) && (cbelow == 0))
				dcalls = 0;
      		if(cabove == 1)
				dcalls = 1;
      		if(cbelow == 1)
				dcalls = 2;
      		if((cbelow == 1)&&(cabove == 1))
				dcalls = 3;
      		setpref();
      		return;
    	}
    	else        // door hold operation or power went off
    	{
      		dpref = 0;
      		dcalls = 0;
      		return;
    	}
  	}

  	if(medf >= 2)
  	{	   // Medical Emergency Service at the floor or running
    	g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;
    	if ((medf == 3) && (rdinp(i_EMS) == 1))    // Medical Emergency Operation
    	{
      		for(i=cons[bottomf]; i <= cons[topf]; i++)
      		{
				if(carcb[i] == 1)
				{
		 			if(i > position)
		    			cabove = 1;
		  			if(i < position)
		    			cbelow = 1;
				}
				if(cons[rear] != 0)
				{
					if(rcarcb[i] == 1)
					{
			 			if(i > position)
			   	 			cabove = 1;
			  			if(i < position)
			    			cbelow = 1;
					}
				}
      		}
      		if((cabove == 0) && (cbelow == 0))
				dcalls = 0;
      		if(cabove == 1)
				dcalls = 1;
      		if(cbelow == 1)
				dcalls = 2;
      		if((cbelow == 1)&&(cabove == 1))
				dcalls = 3;
      		setpref();
      		return;
    	}
    	else        // door hold operation 
    	{
      		dpref = 0;
      		dcalls = 0;
      		return;
    	}
  	}

// if code blue operation
  	if(cons[cblue] != 0)  // Code blue operation is enabled
  	{
    	if(codebf != 0)     // On code blue operation
    	{
      		g_park[cons[carnmb]] = 0;
			lby_req[cons[carnmb]] = 0;
      		if((codebf == 1)||(codebf==2))   // On code blue returning to emergency
      		{
				if (codebfl == 0)
				{
	  				dpref = 0;
	  				dcalls = 0;
				}
				else if(position > codebfl)  // elevator higher than emergency
				{
	  				dpref = 2;        // down preference
	  				dcalls = 2;       // call below
	  				stops[0] = codebfl;
				}
				else if(position < codebfl)  // elevator lower than emergency
				{
	  				dpref = 1;
	  				dcalls = 1;
	  				stops[0] = codebfl;
				}
				else if(position == codebfl) // elevator at emergency floor
				{
	  				dpref = 0;
	  				dcalls = 0;
				}
				set_dir_arrow();
				return;
      		}
      		return;
    	}
  	}

// if priority service (vip) operation
  	if (cons[VipSvc] != 0)  // Vip operation is enabled
  	{
    	if (vipf != 0)     // On Vip operation
    	{
      		g_park[cons[carnmb]] = 0;
			lby_req[cons[carnmb]] = 0;
      		if ((vipf == 1) || (vipf == 2))   // On vip returning to emergency
      		{
				if (position > vipfl)  // elevator higher than emergency
				{
	  				dpref = 2;        // down preference
	  				dcalls = 2;       // call below
	  				stops[0] = vipfl;
				}
				if (position < vipfl)  // elevator lower than emergency
				{
	  				dpref = 1;
	  				dcalls = 1;
	  				stops[0] = vipfl;
				}
				if (position == vipfl) // elevator at emergency floor
				{
	  				dpref = 0;
	  				dcalls = 0;
				}
				set_dir_arrow();
				return;
      		}
    	}
  	}

	if ((toc_can_error == 1) || (spb_can_error == 1) ||
		(hardware_init_fault == 1) || (door_motor_ovl == 1) ||
		((brk_can_error == 1) && ((cons[brake] == 2) || (cons[brake] == 3))) ||
		((ebrk_can_error == 1) && ((cons[brake] == 2) || (cons[brake] == 3)) && ((cons[EM_BRK] == 6) || (cons[Aux_Brake] == 1) || (cons[EM_BRK] == 7))) || 
		((sel_can_error == 1) && (cons[sel_type] == 2)) ||
		(((can_enc_com_err == 1) || (can_enc_init == 0) || (EncCan_Upd == 1)) && (cons[sel_type] == 3))) 
	{			   // Top of car communications error
    	g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;
   		dcalls = 0;
    	setpref();
    	return;
	}

// if independent operation or load weighing bypass or vip
  	if((servf == 2) || (servf == 3) || (servf == 23)) // answer car calls only
  	{
    	g_park[cons[carnmb]] = 0;
		lby_req[cons[carnmb]] = 0;
		zone_fl = 0;
//		onward_cc = 0;
    	for(i=cons[bottomf]; i <= cons[topf]; i++)
    	{
      		if(carcb[i] == 1)
      		{
				if(i > position)
	  				cabove = 1;
				if(i < position)
	  				cbelow = 1;
      		}
      		if(cons[rear] != 0)
      		{
	      		if(rcarcb[i] == 1)
	      		{
					if(i > position)
		  				cabove = 1;
					if(i < position)
		  				cbelow = 1;
	      		}
      		}
    	}
    	if((cabove == 0) && (cbelow == 0))
      		dcalls = 0;
    	if(cabove == 1)
      		dcalls = 1;
    	if(cbelow == 1)
      		dcalls = 2;
    	if((cbelow == 1)&&(cabove == 1))
      		dcalls = 3;
    	setpref();
    	return;
  	}

// if full automatic operation

	cc_above_lby = 0;
	cc_below_lby = 0;

  	for(i=cons[bottomf]; i <= cons[topf]; i++)
  	{
    	if(carcb[i] == 1)  // There is a car call
    	{
      		if(i > position) // call above car
				cabove = 1;
      		if(i < position) // call below car
				cbelow = 1;
    	}
    	if(cons[rear] != 0)
    	{
	    	if(rcarcb[i] == 1)  // There is a rear car call
	    	{
	      		if(i > position) // call above car
					cabove = 1;
	      		if(i < position) // call below car
					cbelow = 1;
	    	}
    	}
		if (i > lobby_fl) 
		{
			if ((carcb[i] == 1) || ((cons[rear] != 0) && (rcarcb[i] == 1)))
				cc_above_lby = 1;
		}
		if (i < lobby_fl) 
		{
			if ((carcb[i] == 1) || ((cons[rear] != 0) && (rcarcb[i] == 1)))
				cc_below_lby = 1;
		}
    	if((upcb[i] == 1)&&(i != cons[topf]))   // There is a up hall call
    	{
			if (ncu_door_seq == 3)
			{			 // only at the lobby on next up
      			if(i > position) // call above car
					cabove = 1;
			}
			else if (i > position)
				cabove = 1;
			else if (((i == position) && ((nudgst & 0x01) == 0)) && ((manual_door != 1) || (cons[frghtd] != 0)))
				cabove = 1;
      		if(i < position) // call below car
				cbelow = 1;
    	}
		if ((lby_req[cons[carnmb]] == i) && (i != cons[topf]))	// There is an up request at the lobby
		{
			if (ncu_door_seq == 3)
			{			 // only at the lobby on next up
      			if(i > position) // call above car
					cabove = 1;
			}
			else if (i > position)
				cabove = 1;
			else if (((i == position) && ((nudgst & 0x01) == 0)) && ((manual_door != 1) || (cons[frghtd] != 0)))
				cabove = 1;
      		if(i < position) // call below car
				cbelow = 1;
		}
    	if(cons[rear] != 0)
    	{
	    	if((rupcb[i] == 1)&&(i != cons[topf]))   // There is a rear up hall call
	    	{
	      		if(i > position) // call above car
					cabove = 1;
				else if (((i == position) && ((rnudgst & 0x01) == 0)) && ((manual_rdoor != 1) || (cons[frghtd] != 0)))
					cabove = 1;
	      		if(i < position) // call below car
					cbelow = 1;
	    	}
    	}
    	if((downcb[i] == 1)&&(i != cons[bottomf]))   // There is a down hall call
    	{
      		if(i > position) // call above car
				cabove = 1;
      		if(i < position) // call below car
				cbelow = 1;
			else if (((i == position) && ((nudgst & 0x02) == 0))  && ((manual_door != 1) || (cons[frghtd] != 0)))
			   cbelow = 1;
    	}
    	if(cons[rear] != 0)
    	{
	    	if((rdowncb[i] == 1)&&(i != cons[bottomf]))   // There is a down hall call
	    	{
	      		if(i > position) // call above car
					cabove = 1;
	      		if(i < position) // call below car
					cbelow = 1;
				else if (((i == position) && ((rnudgst & 0x02) == 0)) && ((manual_rdoor != 1) || (cons[frghtd] != 0)))
					cbelow = 1;
	    	}
    	}
  	}

  	if((cabove == 0) && (cbelow == 0))
    	dcalls = 0;
  	if(cabove == 1)
    	dcalls = 1;
  	if(cbelow == 1)
    	dcalls = 2;
  	if((cbelow == 1)&&(cabove == 1))
    	dcalls = 3;


//	onward_calls = (ocabove	& 1) | ((ocbelow & 1) << 1);

  	if( (dcalls != 0) && (g_park[cons[carnmb]] != 0) )
		g_park[cons[carnmb]] = 0;

  	setpref();

// if attendant operation
  	if(cons[att] != 0)
  	{
    	if(servf == 4)
    	{
	      	if((rdinp(i_ATTUP) == 1) && (position != cons[topf]) && ((dcalls & 0x1) == 1))
				dpref = 1;
	      	if((rdinp(i_ATTDN) == 1)	&& (position != cons[bottomf]) && ((dcalls & 0x2) == 0x2))
				dpref = 2;
		  	if (dpref != 0)
		    	set_dir_arrow();
    	}
  	}

#if ((Traction == 0) && (Tract_OL == 0))
// viscosity control return to lobby floor
	if((Drive_Type[cons[carnmb]] == 1) || (Drive_Type[cons[carnmb]] == 9))
	{
	  	if( (servf != 0) && (dpref == 0) && (dcalls == 0) &&
	      	(((rdinp(i_TPL) == 1) && (fvars[fvtpl] == 0)) || ((rdinp(i_TPL) == 0) && (fvars[fvtpl] == 1))) )
	  	{
			if(position > lobby_fl)
			{
				dpref = 2;
				dcalls = 2;
			}
			if(position < lobby_fl)
			{
				dpref = 1;
				dcalls = 1;
			}
			return;
	  	}
	}
#endif

// if homing
  	if( (servf != 0) && (dpref == 0) && (dcalls == 0))
	{
		if ((g_park[cons[carnmb]] >= cons[bottomf]) &&
      		(g_park[cons[carnmb]] <= cons[topf]) )
  		{
	    	if(position > g_park[cons[carnmb]])       // car above homeing floor
	    	{
	      		servf = 11;
	      		dpref = 2;
	      		dcalls = 2;
	      
	      		stops[0] = (g_park[cons[carnmb]]);
	//	  		set_dir_arrow();
	    	}
	   	 	if(position < g_park[cons[carnmb]])       // car below homeing floor
	    	{
	      		servf = 11;
	      		dpref = 1;
	      		dcalls = 1;
	      		stops[0] = (g_park[cons[carnmb]]);
	//	  		set_dir_arrow();
	    	}
		    if(position == g_park[cons[carnmb]])      // car at homeing floor
		    {
				if ((procf >= 14) && (procf <= 16))	// we are at the floor
			        servf = 1; // Car is at homing floor so go back to automatic
	    		else
	    	    	servf = 11;
	      		dpref = 0;
	      		dcalls = 0;
		    }
		}
		else if (servf == 11)
			servf = 1;
	}
	else if ((servf == 11) && (g_park[cons[carnmb]] == 0))
		servf = 1;

  	if( ((servf != 0) || ((servf == 0) && 
  			( ((rhjackf >= 2) && (cons[Reset_Jack] == 1)) || 
  			  (rdinp(i_AD) == 0) || 
  			  (((cons[ids] & 1) != 0) && (ids_ad_off[cons[carnmb]] == 1)) ||
  			  (((cons[Galileo] & 1) != 0) && (ui_ad_off[cons[carnmb]] == 1)) ) )) && (dpref == 0) && (dcalls == 0))
	{
		if ((zone_fl >= cons[bottomf]) &&
      		(zone_fl <= cons[topf]) )
  		{
	    	if(position > zone_fl)      // car above homing floor
	    	{
	      		dpref = 2;
	      		dcalls = 2;
	      
	      		stops[0] = zone_fl;
		  		set_dir_arrow();
	    	}
	   	 	if(position < zone_fl)       // car below homing floor
	    	{
	      		dpref = 1;
	      		dcalls = 1;
	      		stops[0] = zone_fl;
		  		set_dir_arrow();
	    	}
		    if(position == zone_fl)      // car at homing floor
		    {
				if ((procf >= 14) && (procf <= 16))	// we are at the floor
			        zone_fl = 0;
	      		dpref = 0;
	      		dcalls = 0;
		  		set_dir_arrow();
		    }
		}
	}

  	return;
}

//************************************
// Turn off Watchdog and all interrups
//************************************

void dog_ints_off(void)
{
/*
	int16 i;
	disable_dog();
  	_disable();
  	i = inp(0x21);
  	i = (i | 0x80);       // Masking interupt #7 Pg #3-140
  	outp(0x21,(uint8)i);
  	outp(c_timer_en_addr,0);		// Turn off timer enable output
  	_enable();
  	_disable();
  	for(i=0; i<=3; i++)
  	{
		// disable interrupts for all other ports
      	outp(0x21,(inp(0x21) | (uint8)(~com[i][1])));
     	// send any other control signals to uart
     	outp(com[i][7], 0x0); // disable interrupts (bit3), and pins low
     	outp(com[i][4], 0x00); //disable recieve interupt Pg 4-9
     	// thoroughly flush receiver input buffer
     	inp(com[i][8]);
     	inp(com[i][8]);  // clear any int_pending line status
     	inp(com[i][0]);
     	inp(com[i][0]);  // get rid of any old data
     	inp(com[i][0]);
  	}
  	_enable();
*/
}

void dog_ints_on(void)
{
	enable_dog();
  	inittim();    // Setup the hardware for a 1/100th of a second interupt
}

//*********************************************************
// Status of the door locks	(0=locks open, 1= locks closed)
// ********************************************************

int16 door_locks(void)
{		
	if (cons[topf] > 2)
	{
		if ( (rdinp(i_DLT) == 1) && (rdinp(i_DLB) == 1) && 
			 (rdinp(i_DLT_1) == 1) && (rdinp(i_DLB_1) == 1) && 
			 (rdinp(i_DLM) == 1) && (rdinp(i_DLM_1) == 1) &&
			 ((cons[rear] == 0) || ((rdinp(i_RLM) == 1) && (rdinp(i_RLM_1) == 1))) &&
			 (((cons[mand] == 0) && (cons[frghtd] == 0) && (cons[Australia] == 0)) || (man_dcc() == 1)) ) 
			return 1;
		else
			return 0;
	}
	else
	{	  // special case - only two floors
		if ( (rdinp(i_DLT) == 1) && (rdinp(i_DLB) == 1) && 
			(rdinp(i_DLT_1) == 1) && (rdinp(i_DLB_1) == 1) && 
			(((cons[access_type] & 0x0C) == 0) || ((rdinp(i_DLM) == 1) && (rdinp(i_DLM_1) == 1))) && 
			((cons[rear] == 0) || ((rdinp(i_RLM) == 1) && (rdinp(i_RLM_1) == 1))) &&
			(((cons[mand] == 0) && (cons[frghtd] == 0) && (cons[Australia] == 0)) || (man_dcc() == 1)) ) 
			return 1;
		else
			return 0;
	}
}
	


//************************************
// Set service flag for elevator off
//************************************
void elevator_off (void)
{
	int16 fl;
	if (((cons[Elev_off] & 3) != 0) || ((cons[ids] & 1) != 0) || ((cons[Galileo] & 1) != 0))
	{
	 	if ((firef == 0) && (rfiref == 0) && (codebf == 0) && (vipf == 0) && (eqf == 0) && (medf == 0))
		{
			if ((rdinp(i_ELOF) == 1) && ((cons[Elev_off] & 1) != 0) && (cons[loadw] != 1))
			{
				if (servf == 1) 
					servf = 19;
			}
			else if (servf == 19)
				servf = 1;

			if ((cons[sercom] & 0x01) != 0)				
			{
				if ((((rdinp(i_HEOF) == 1) || ((latch_HEOF == 1) && ((cons[Elev_off] & 4) != 0))) && ((cons[Elev_off] & 2) != 0)) || 
					(((cons[ids] & 1) != 0) && (ids_heof[cons[carnmb]] == 1)) ||
					(((cons[ids] & 1) != 0) && (ids_return_flr != 0)) || 
					(((cons[Galileo] & 1) != 0) && (ui_heof[cons[carnmb]] == 1))) 
				{
					if (servf == 1)
					{
						servf = 20;	// take car out of group service
					}
					if((cons[Elev_off] & 8) != 0)
					{
						if(((fvars[fveloff2] & 0x02) != 0)&&(latch_HEOF == 1))
						{
							setoutp(o_ELOO);
						}
						else if ((latch_HEOF == 1) && (timers[tsec] != 0))
						{	
								setoutp(o_ELOO);
						}
						else
						{
								clroutp(o_ELOO);
						}
					}
					if (((cons[Elev_off] & 4) != 0)  && (timers[theoff] >= 10))
						latch_HEOF = 1;

					if(ids_return_flr != 0)
					{
						fl = ids_return_flr;
						if ((fl < cons[bottomf]) || (fl > cons[topf]))
							fl = cons[bottomf];
						if ((position != fl) && (servf == 20))
			  			{
							clrcc(0);
							rear_slowdown &= ~cc_do;
							front_slowdown &= ~cc_do;
							zone_fl = fl;
							set_carcall(cons[carnmb],fl);
						}						
					}					
					else if ((fvars[fveloff] & 0x01) != 0)
					{						// Recall Car
						if (fvars[fvheoffl] == 0)
							fl = lobby_fl;
						else
							fl = fvars[fvheoffl];
						 
						if ((fl < cons[bottomf]) || (fl > cons[topf]))
							fl = cons[bottomf];

						if ((position != fl) && (servf == 20))
			  			{
							if((cons[Elev_off] & 0x10) == 0)
							{
								clrcc(0);
								rear_slowdown &= ~cc_do;
								front_slowdown &= ~cc_do;
							}
							zone_fl = fl;
							set_carcall(cons[carnmb],fl);
						}

					}
				}
				else if ((servf == 20) && (cons[Prison] == 0))
				{
					timers[theoff] = 0;
					if (servf == 20)
					{
						servf = 1;
					}
				}
			}
		}
		else 
		{
			if ((servf == 19) || (servf == 20))
			{
				if (latch_JAIL == 0)
				{
					servf = 1;
				}
			}
		}
		
		if(heof_over_ind == 0)
			timers[theofovrind] = 0;
		
	}
}

//************************************
// Set service flag for jail break
//************************************
void jail_break (void)
{
	int16 fl;
	if((cons[Prison] == 1) &&((cons[Elev_off] & 0x06) == 0))
	{
		if ((firef == 0) && (rfiref == 0) && (codebf == 0) && (vipf == 0) && (eqf == 0) && (medf == 0))
		{
			if(rdinp(i_JAILB) == 1)
			{
				if(timers[theoff] >= 10)
					latch_JAIL = 1;
			}
			else
			{
				timers[theoff] = 0;
			}
			if (rdinp(i_EOR) == 1)
			{
				latch_JAIL = 0;
				if(servf == 20)
				{
					servf = 1;
				}
			}
			if(latch_JAIL == 1)
			{
				if(servf == 1)
					servf = 20;
				setoutp(o_ELOO);
				//RECALL THE CAR
				if (fvars[fvheoffl] == 0)
					fl = lobby_fl;
				else
					fl = fvars[fvheoffl];
				 
				if ((fl < cons[bottomf]) || (fl > cons[topf]))
					fl = cons[bottomf];

				if ((position != fl) && (servf == 20))
	  			{
					clrcc(0);
					rear_slowdown &= ~cc_do;
					front_slowdown &= ~cc_do;
					zone_fl = fl;
					set_carcall(cons[carnmb],fl);
				}
				if (position == fl)
				{
					clrcc(0);
				}

			}
			else
			{
				clroutp(o_ELOO);
				
			}
			

		}
	}


}



//*******************************************
// Test if okay to recall on emergency power
//*******************************************

int16 ep_recall_ok(void)
{
//	if (ind() == 1)
	if (servf == 2)
		return(0);
//	if ((rdinp(i_ATT) == 1) && ((cons[att] == 1) || (cons[att] == 2)))
	if (servf == 4)
		return(0);
	if (stallf != 0)
		return(0);
 	if ((firef != 0) || (rfiref != 0) || (hsvf != 0) || (eqf != 0) || (medf != 0))
		return(0);
	if ((rdinp(i_ELOF) == 1) && ((cons[Elev_off] & 1) != 0) && (cons[loadw] != 1))
		return(0);
#if ((Traction == 1) || (Tract_OL == 1))
  	if (((rdinp(i_RTL) == 1) && (cons[otslbp] != 0)) || 
  		(((cons[ids] & 1) != 0) && (ids_rtl[cons[carnmb]] == 1)) ||
  		(((cons[Galileo] & 1) != 0) && (ui_rtl[cons[carnmb]] == 1)) ||
  		((rdinp(i_RTLDC) == 1) && ((cons[otslbp] & 0x04) != 0)))
#else
  	if (((rdinp(i_RTLH) == 1) && (cons[otslbp] != 0)) || 
  		(((cons[ids] & 1) != 0) && (ids_rtl[cons[carnmb]] == 1)) || 
  		(((cons[Galileo] & 1) != 0) && (ui_rtl[cons[carnmb]] == 1)) || 
  		((rdinp(i_RTLDC) == 1) && ((cons[otslbp] & 0x04) != 0)))
#endif
		return(0);

	if ((cons[sercom] & 0x01) != 0)
	{
		if (((rdinp(i_HEOF) == 1) && ((cons[Elev_off] & 2) != 0)) || (((cons[ids] & 1) != 0) && (ids_heof[cons[carnmb]] == 1)) ||
			(((cons[ids] & 1) != 0) && (ids_return_flr != 0)) || (((cons[Galileo] & 1) != 0) && (ui_heof[cons[carnmb]] == 1))) 

			return(0);
	}
	return(1);
}

#if ((Traction == 1) || (Tract_OL == 1))

void epr_dir(void)
{

	timers[tvpat] = 0;
#if (Traction == 1)
	Enc_dir = 0;
#endif
	dirf = 0;
	dpref = 0;
	timers[tpatdly] = 0;
  	timers[tmotion] = 0;

   	while(procf == 21)
   	{
		setempf();
		inctime(0);

		// Testing to see if saftey string is open
	    if(safeties() == 0)
	    {
			if ((statusf & sf_SS) == 0)
		  		record_fault(f_sstring);
			statusf |= sf_SS;
	      	procf = 12;       // go to saftey string open mode
	      	timers[tmotion] = 0;
			timers[tpatdly] = 0;
	      	return;
	    }
		else
			statusf &= ~sf_SS;


		// Testing to see if LC fuse is blown
		if(rdinp(i_LC) == 0)
	    {
			if ((statusf & sf_LC) == 0)
			  	record_fault(f_LC_fuse);
			statusf |= sf_LC;
			procf = 12;
			timers[tmotion] = 0;
			timers[tpatdly] = 0;
			return;
	    }
		else
			statusf &= ~sf_LC;

		// Testing to see if the ready from the Drive is open
		if((rdinp(i_READY) == 0) && (rdinp(i_GTS) == 1))
	    {
			if ((statusf & sf_READY) == 0)
		  		record_fault(f_drive_rdy);
			statusf |= sf_READY;
	      	procf = 12;       // go to saftey string open mode
	      	timers[tmotion] = 0;
			timers[tpatdly] = 0;
	      	return;
	    }
		else
			statusf &= ~sf_READY;

		// Testing to see if on inspection
	    if(chk_ins() == 1)
	    {
	      	procf = 2;        // go to inspection mode
	      	timers[tmotion] = 0;
			timers[tpatdly] = 0;
	      	return;
	    }

		if ((cons[Emp_Recover] == 2) && (drv_has_power != 2))
		{								// wait for power to transfer
	      	timers[tmotion] = 0;
			timers[tpatdly] = 0;
		}
		else if ((safe() == 1) && ((cons[ansi] < 2000) || (gripper_fault == 0)) && (timers[tmotion] < 1000))
		{

			if (cons[loadw] == 2)
				get_load(1);		// force load weigher update
#if (Tract_OL == 1)
			if ((cons[loadw] == 2) && ((lw_dir & c_lw_dir_error) == 0))
			{
				timers[tpatdly] = 0;
				epr_dirf = lw_dir;
			}
			else
				epr_dirf = c_lw_up;
#else
			if ((cons[loadw] == 2) && ((fvars[fveprdir] & 0x01) != 0) && ((lw_dir & c_lw_dir_error) == 0))
			{
				timers[tpatdly] = 0;
				epr_dirf = lw_dir;
			}
			else
			{		
				clroutp(o_UP);    // Turn off up output
				setoutp(o_RUN); // Turn on the run output
				setoutp(o_RUNA);
				setoutp(o_MCC);    // Turn on motor starter output
				setoutp(o_MCA);
				setoutp(o_DNR); // Turn on down output

				timers[tsoftstp] = 0;
				don_delay = 0;

			  	if ((rdinp(i_DON) == 0) || (rdinp(i_DEL) == 0) ||
			  	 ((rdinp(i_UP) == 0) && (rdinp(i_DNR) == 0)) )
			  	{
					timers[tvpat] = 0;	  
					timers[tdppflt] = 0;
			  	}

				set_pre_torque();
				torque = 0;				// Zero the pre-torque value on a relevel
				pick_brake(c_pick_brake_run);
				Velocity = 0;
				Vel_Step = 0;
				Dmd_Velocity = Velocity;
				if ((cons[sercom] & 8) == 0)
			 		DAC_Out();
#if (Simulator == 1)
			 	Enc_dir = sim_enc_dir;
#endif
				epr_dirf = Enc_dir;
		 	}	
			
#endif
			if (epr_dirf == prev_epr_dirf)
			{
				if ((timers[tvpat] > 300) || ((timers[tvpat] > 100) && (epr_dir != 0)))
				{
					if (epr_dirf == 2)
					{			// if the direction is down then run down 
				    	servf = 13;
				    	dirf = 2;
						dpref = 2;
#if(Traction == 1)
						Vel_Max_Set = Ep_Recov_Vel;		// Recovery Speed
				    	Velocity = 0;
						Dmd_Velocity = 0;
				    	timers[tvpat] = 0;
				    	
						if(cons[sel_type] == 3)
						{
							set_position_from_encoder();
					    	DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]]; 
						}
						else
						{
							set_position(1);	 // reset position to what we think is correct
					    	DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    	DPP_Count = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
							old_dpp = DPP_Count;
							preset_encoder_count(DPP_Count);
						}
						

				    	if ((cons[BinPiIn] == 1) || (cons[sel_type] != 0))
						{
							if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
							{
								setoutp(o_LE);
								setoutp(o_LE1);
				    		}
				    	}
				    	else
						{																							  
							clroutp(o_LE);
							clroutp(o_LE1);
				    	}
				    	timers[tdppflt] = 0;
				    	Lev_Mode=0;
				    	Vel_Step = 0;
#else
						position = cons[topf];
#endif
						procf = 3;
						break;
					}
					else
					{			// else if direction is up or no direction then run up (assume empty car)
						servf = 12;
						dirf = 1;
						dpref = 1;
#if(Traction == 1)
						set_position(2);	 // reset position to what we think is correct
						Vel_Max_Set = Ep_Recov_Vel;		// Recovery Speed
						Velocity = 0;
						Dmd_Velocity = 0;
						timers[tvpat] = 0;

						if(cons[sel_type] == 3)
						{
							set_position_from_encoder();
							DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
							
						}
						else
						{
							set_position(2);	 // reset position to what we think is correct
							DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
							DPP_Count = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
							old_dpp = DPP_Count;
							preset_encoder_count(DPP_Count);
						}

				    	if ((cons[BinPiIn] == 1) || (cons[sel_type] != 0))
					    {
							if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
							{
						    	setoutp(o_LE);
								setoutp(o_LE1);
							}
						}
						else
						{
					    	clroutp(o_LE);
							clroutp(o_LE1);
						}
						timers[tdppflt] = 0;
						Lev_Mode=0;
						Vel_Step = 0;
#else
						position = cons[bottomf];
#endif
						procf = 3;
						break;
					}
				}
			}
			else
			{
				timers[tvpat] = 0;
			}
			
			prev_epr_dirf = epr_dirf;
		}
		else
		{		// lost safe 

			timers[tpatdly] = 0;
						
			if ((timers[tsoftstp] <= fvars[fvsst]) && (leveling_fault != 0))  // soft stop needed
			{
			    if(dirf == 1)
			    {
					setoutp(o_UP);      // set up output
					clroutp(o_DNR);   // clear down output
			    }
			    else
			    {
					setoutp(o_DNR);   // set down output
					clroutp(o_UP);      // clear up output
			    }
				setoutp(o_RUN);   // set run output
				setoutp(o_RUNA);
			}
			else
			{
				clroutp(o_UP);      // clear up output
				clroutp(o_DNR);   // clear down output
				don_delay = 0;
				if (timers[tsoftstp] >= (fvars[fvsst] + 10))  // delay the drop of MCC and mc
				{
					clroutp(o_RUN);   // clear run output
					clroutp(o_RUNA);
					clroutp(o_MCC);      // Clear motor starter output
					clroutp(o_MCA);
				}
			}
			drop_brake(c_drop_brake_reset);
			if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
			{
				setoutp(o_LE);
				setoutp(o_LE1);
			}
			timers[tvpat] = 0;
#if(Traction == 1)
			Velocity = 0;
			Dmd_Velocity = 0;
			Vel_Step = 0;
#endif
			if ((door_locks() == 0) || (car_gate() == 0))
			{		// we reached this point so we need to run to recover so shut the door
				close_doors_during_reset(1);
			}
		}
		if (((timers[tmotion] > 1000) || ((cons[ansi] >= 2000) && (gripper_fault != 0))) && (timers[tsoftstp] >= (fvars[fvsst] + 10)))
		{				// allow softstop then return
			procf = 0;
			break;
		}
	}

#if(Traction == 1)
	old_dpp = DPP_Count;
	Prev_DPP_Count = DPP_Count;
	prev_Enc_Count = DPP_Count;	
#endif

	timers[tsafe] = 0;
	safe_fault_latch = 0;

	return;
}

//****************************************
// Emergency Power Set Power 
// Control of UPS single phase power
//****************************************

void epr_set_power(void)
{
	if (cons[Emp_Recover] == 2)
	{
		if (rdinp(i_EMP) == 1)
		{
			if (timers[tEP_epd] > 10)
			{
				clroutp(o_NPD);
			}

			if (timers[tEP_epd] > 100)
			{
				setoutp(o_EPD);
				clroutp(o_EPO);

			}

			if (Drive_Type[cons[carnmb]] == 3)		// hpv-600/900
			{
				if (timers[tEP_epd] > 120)
				{
					if (drv_ep_mode < 8)
						drv_ep_mode = set_drv_ep_mode(drv_ep_mode);

					drv_rset_ep_mode = 0;
				}
			}

		    if (timers[tEP_epd] > 150)
				drv_has_power = 2;
			else
				drv_has_power = 0;

			timers[tEP_npd] = 0;

			if ((rdinp(i_DZ) == 1) && (rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))
			{
				if (timers[tEP_epo] > 1200)
				{
					clroutp(o_NPD);
					clroutp(o_EPD);
					setoutp(o_EPO);
				}
			}
			else
				timers[tEP_epo] = 0;
		}
		else
		{
			drv_ep_mode = 0;

			if (timers[tEP_npd] > 10)
				clroutp(o_EPD);

			if (timers[tEP_npd] > 20)
			{
				setoutp(o_NPD);
				clroutp(o_EPO);

				if (Drive_Type[cons[carnmb]] == 3)		// hpv-600/900
				{
					if (drv_rset_ep_mode < 5)
						drv_rset_ep_mode = reset_drv_ep_mode(drv_rset_ep_mode);

					drv_ep_mode = 0;
				}
			}

			if (timers[tEP_npd] > 50)
				drv_has_power = 1;
			else
				drv_has_power = 0;

			timers[tEP_epd] = 0;
			timers[tEP_epo] = 0;
		}
	}
	else
		drv_has_power = 0;
}

#endif


// ************************************************
// This routine gets the next valid position
// ************************************************

int16 get_valid_fl(int16 pos, int16 dir)
{
	int16 i;

	if (dir == 1)
	{	// going up
		for (i=pos;i<cons[topf];i++)
		{
			if (valid_fl[i] == 1)
				return i;
		}
		return i;		// return top floor if none found
	}
	else if (dir == 2)
	{	// going down
		for (i=pos;i>cons[bottomf];i--)
		{
			if (valid_fl[i] == 1)
				return i;
		}
		return i;		// return bottom floor if none found
	}
	else
		return cons[topf];
}

// ******************************************
// This is the hall lantern procedure
// ******************************************
void hlants()
{
	int16 dis_lant_ncu = 0;
	int16 timed_lant = 0; // 0= fire as soon as hsf = 0 (slow down)
	int32 lantern_delay = 0;
	int32 Time_to_Stop = 0;

#if ((Traction == 0) && (Tract_OL == 0))
	Time_to_Stop = 0;
#endif

#if (Traction == 1)
	Time_to_Stop = (int32) (Max_Lant_Time * 10);
#endif

	//hall lanterns fire up as soon we slow down unless fv is nonzero or Timetostop > fv
	if ((fvars[fvhlandelay] != 0) && (Time_to_Stop > fvars[fvhlandelay]))
	{
		timed_lant = 1;
		lantern_delay = Time_to_Stop - fvars[fvhlandelay];
	}
	else
		timed_lant = 0;


	if ((next_up != 0) && (onward_calls == 0) && (position == lobby_fl) && (ncu_door_seq == 2) && (timers[tncu] > fvars[fvldt]))
		dis_lant_ncu = 1;
	else
		dis_lant_ncu = 0;

  	if( (firef != 0) || (ind() == 1) ||	(eqf != 0) || (codebf != 0) || (vipf != 0) || (hsvf == 1) ||
  	    ((rdinp(i_AD) == 0) ||
  	     ((servf == 25) && ((fvars[fvsabbdis] & 0x02) != 0)) || 
  	     (((cons[ids] & 1) != 0) && (ids_ad_off[cons[carnmb]] == 1)) || 
  	     (((cons[Galileo] & 1) != 0) && (ui_ad_off[cons[carnmb]] == 1))) || ((dpref == 0) && (fvars[fvarrivallant] == 0)) )
  	{
    	clrlant();
		if (((fvars[fvsabben2] & 0x02) != 0) && (servf == 25)) 
		{
			if ((dirf == 1) || ((dirf == 0) && (dpref == 1)))
			{
				setoutp(o_CUL);
				cab_lant_up = 1;
				if (cons[rear] != 0)
				{
					setoutp(o_CULR);
					cab_rlant_up = 1;
				}
			}
			else if ((dirf == 2) || ((dirf == 0) && (dpref == 2)))
			{
				setoutp(o_CDL);
				cab_lant_dn = 1;
				if (cons[rear] != 0)
				{
					setoutp(o_CDLR);
					cab_rlant_dn = 1;
				}
			}
		}
		if ((position == vipfl) && (servf == 23) && (vipf < 4))
		{
			if (g_vip_fl[cons[carnmb]] != 0)
			{
				if ((fvars[fvviplant] & 0x01) != 0)
				{
			   		if ((rdinp(i_DOL) == 0) || ((doorf != 0) && (((fvars[fvclantctl] & 0x01) != 0) || 
			   			((doorf != 0) && ((fvars[fvclantctl] & 0x02) != 0) && (rdinp(i_DPM) == 0)))))
					{
						if (position <= lobby_fl)  // at or below the lobby floor
						{
							setoutp(o_CUL);
							cab_lant_up = 1;
						}
						else
						{
							setoutp(o_CDL);
							cab_lant_dn = 1;
						}
					}
				}
				if ((fvars[fvviplant] & 0x02) != 0)
				{
					if (position <= lobby_fl)  // at or below the lobby floor
						lant_up = 1;
					else
						lant_dn = 1;
				}
			}
			else if ((g_rvip_fl[cons[carnmb]] != 0) && (cons[rear] != 0))
			{
				if ((fvars[fvviplant] & 0x01) != 0)
				{
			   		if ((rdinp(i_DOLR) == 0) || ((rdoorf != 0) && (((fvars[fvclantctl] & 0x01) != 0) || 
			   			((rdoorf != 0) && ((fvars[fvclantctl] & 0x02) != 0) && (rdinp(i_RPM) == 0)))))
					{
						if (position <= lobby_fl)  // at or below the lobby floor
						{
							setoutp(o_CULR);
							cab_rlant_up = 1;
						}
						else
						{
							setoutp(o_CDLR);
							cab_rlant_dn = 1;
						}
					}
				}
				if ((fvars[fvviplant] & 0x02) != 0)
				{
					if (position <= lobby_fl)  // at or below the lobby floor
						rlant_up = 1;
					else
						rlant_dn = 1;
				}
			}
		}

    	return;
  	}

	if (fvars[fvarrivallant] == 1)
	{

   		if ((rdinp(i_DOL) == 0) || ((doorf != 0) && (((fvars[fvclantctl] & 0x01) != 0) || 
   			((doorf != 0) && ((fvars[fvclantctl] & 0x02) != 0) && (rdinp(i_DPM) == 0)))))
		{
			if ((front_slowdown != 0) || (doorf !=0))
			{
				if (position <= lobby_fl)  // at or below the lobby floor
				{
					setoutp(o_CUL);
					clroutp(o_CDL);
					cab_lant_up = 1;
					cab_lant_dn = 0;
				}
				else
				{
					setoutp(o_CDL);
					clroutp(o_CUL);
					cab_lant_dn = 1;
					cab_lant_up = 0;
				}
			}
		}
		else if (doorf == 0)
		{
			cab_lant_up = 0;
			cab_lant_dn = 0;
			clroutp(o_CDL);
			clroutp(o_CUL);
		}

   		if ((rdinp(i_DOLR) == 0) || ((rdoorf != 0) && (((fvars[fvclantctl] & 0x01) != 0) || 
   			((rdoorf != 0) && ((fvars[fvclantctl] & 0x02) != 0) && (rdinp(i_RPM) == 0)))))
		{
			if ((rear_slowdown != 0) || (rdoorf != 0))			// Rear call stop
			{
				if (position <= lobby_fl)  // at or below the lobby floor
				{
					setoutp(o_CULR);
					clroutp(o_CDLR);
					cab_rlant_up = 1;
					cab_rlant_dn = 0;
				}
				else
				{
					setoutp(o_CDLR);
					clroutp(o_CULR);
					cab_rlant_dn = 1;
					cab_rlant_up = 0;
				}
			}
		}
		else if (rdoorf == 0)
		{
			cab_rlant_up = 0;
			cab_rlant_dn = 0;
			clroutp(o_CDLR);
			clroutp(o_CULR);
		}

		if (((front_slowdown != 0) && (rdoutp(o_RUN) == 1)) || (doorf !=0))
		{
			if (position <= lobby_fl)  // at or below the lobby floor
			{
				lant_up = 1;
				lant_dn = 0;
			}
			else
			{
				lant_dn = 1;
				lant_up = 0;
			}
		}
		else
		{
			lant_up = 0;
			lant_dn = 0;
		}

		if (((rear_slowdown != 0) && (rdoutp(o_RUN) == 1)) || (rdoorf != 0))			// Rear call stop
		{
			if (position <= lobby_fl)  // at or below the lobby floor
			{
 				rlant_up = 1;
				rlant_dn = 0;
 			}
 			else
 			{
 				rlant_dn = 1;
				rlant_up = 0;
			}
		}
		else
		{
			rlant_up = 0;
			rlant_dn = 0;
		}
		return;
	}

  	if(dpref == 0)
  	{
	 	timers[tcablnt] = 0;
	 	timers[trcablnt] = 0;
	 	timers[tlant] = 0;
	 	timers[trlant] = 0;
  	}
  	if(dpref == 1)
  	{
		if (((cons[mand] == 0) && (cons[frghtd] == 0) && (cons[RCM_HWDoor] == 0)) || ((cons[dispis] & 2) != 0))
		{		// use LU for lobby up hall lantern
			if (((position == lobby_fl) && (next_up == 0)) || (ncu_door[cons[carnmb]] == 1))			
			{
				if (timed_lant == 0)
				{
					setoutp(o_LU);	  // Ring the lantern at the lobby only when you are the next up car or when not running next up
				}
				else if (timers[tlant] >= (lantern_delay))

				{
					setoutp(o_LU);	  // Ring the lantern at the lobby only when you are the next up car or when not running next up
				}
			}
		}

		// Standard lantern operation
		if (((next_up == 0) || (position != lobby_fl) || (ncu_door[cons[carnmb]] == 1))) 
		{
			if (((front_slowdown != 0) || (doorf !=0)) && ((dis_lant_ncu == 0) || ((fvars[fvncul] & 0x01) == 0)))
			{
    			if (timed_lant == 0)
				{
					lant_up = 1;
				}
				else if (timers[tlant] >= fvars[fvhlandelay])
			    	lant_up = 1;	  // Ring the lantern at the lobby only when you are the next up car or when not running next up
				else
					lant_up = 0;
			}
			else if ((dis_lant_ncu == 1) && ((fvars[fvncul] & 0x01) != 0))
				lant_up = 0;

			if ((rear_slowdown != 0) || (rdoorf != 0))
			{
				if (timed_lant == 0)
				{
			    	rlant_up = 1;	  // Ring the lantern at the lobby only when you are the next up car or when not running next up
				}
		   		else if (timers[trlant] >= (lantern_delay))

				{
			    	rlant_up = 1;	  // Ring the lantern at the lobby only when you are the next up car or when not running next up
				}
			}
		}

		if ((cons[dispis] & 2) != 0)
	    	clroutp(o_LD);
		lant_dn = 0;
		rlant_dn = 0;
		cab_lant_dn = 0;
		cab_rlant_dn = 0;
    	clroutp(o_CDL);
    	clroutp(o_CDLR);
   		if ((rdinp(i_DOL) == 0) || ((doorf != 0) && (((fvars[fvclantctl] & 0x01) != 0) || 
   			((doorf != 0) && ((fvars[fvclantctl] & 0x02) != 0) && (rdinp(i_DPM) == 0)))))
		{
			if (((front_slowdown != 0) || (doorf !=0))  && ((dis_lant_ncu == 0) || ((fvars[fvncul] & 0x02) == 0)))
			{
				if (((fvars[fvsrlant] & 0x01) == 0) || (((fvars[fvsrlant] & 0x01) != 0) && ((front_slowdown & iruc_sd) != 0)))
				{ 
					setoutp(o_CUL);
					cab_lant_up = 1;
				}
			}
			else if ((dis_lant_ncu == 1) && ((fvars[fvncul] & 0x02) != 0))
			{
 		    	clroutp(o_CUL);
				cab_lant_up = 0;
			}
  		}
   		if ((rdinp(i_DOLR) == 0) || ((rdoorf != 0) && (((fvars[fvclantctl] & 0x01) != 0) || 
   			((rdoorf != 0) && ((fvars[fvclantctl] & 0x02) != 0) && (rdinp(i_RPM) == 0)))))
		{
			if ((rear_slowdown != 0) || (rdoorf != 0))			// Rear call stop
			{
				if (((fvars[fvsrlant] & 0x01) == 0) || (((fvars[fvsrlant] & 0x01) != 0) && ((rear_slowdown & iruc_sd) != 0)))
				{ 
					setoutp(o_CULR);
					cab_rlant_up = 1;
				}
			}
  		}
  	}
  	if(dpref == 2)
  	{
  	   	if (rdinp(i_DCL) == 0) 
			keep_lants_on = 0;
  	   	if ((cons[rear] == 0) || (rdinp(i_DCLR) == 0))  
			keep_rlants_on = 0;
		if (((cons[mand] == 0) && (cons[frghtd] == 0) && (cons[RCM_HWDoor] == 0)) || ((cons[dispis] & 2) != 0))		
	     	clroutp(o_LU);
		lant_up = 0;
		rlant_up = 0;
		cab_lant_up = 0;
		cab_rlant_up = 0;
     	clroutp(o_CUL);
     	clroutp(o_CULR);

     	if(fvars[fvdbl] == 0)
     	{
			if (((cons[dispis] & 2) != 0) && (position == lobby_fl))
			{
				if ((front_slowdown != 0) || (doorf !=0))
				{
					if (timed_lant == 0)

					{
						setoutp(o_LD);
				   	}
				   	else if (timers[tlant] >= (lantern_delay))

		    	   		setoutp(o_LD);
				}
       		}

			if ((front_slowdown != 0) || (doorf !=0))
			{
				if (timed_lant == 0)

				{
					lant_dn = 1;
				}
				else if (timers[tlant] >= (lantern_delay))

					lant_dn = 1;
			}
    	   	if ((rear_slowdown != 0) || (rdoorf != 0))			// Rear call stop
			{
				if (timed_lant == 0)

				{	
					rlant_dn = 1;
				}
				else if (timers[trlant] >= (lantern_delay))

		    	 	rlant_dn = 1;
		  	}

	   		if ((rdinp(i_DOL) == 0) || ((doorf != 0) && (((fvars[fvclantctl] & 0x01) != 0) || 
	   			((doorf != 0) && ((fvars[fvclantctl] & 0x02) != 0) && (rdinp(i_DPM) == 0)))))
	   		{
				if ((front_slowdown != 0) || (doorf !=0))
				{
					if (((fvars[fvsrlant] & 0x01) == 0) || (((fvars[fvsrlant] & 0x01) != 0) && ((front_slowdown & irdc_sd) != 0)))
					{ 
			   			setoutp(o_CDL);
						cab_lant_dn = 1;
					}
				}
     		}
	   		if ((rdinp(i_DOLR) == 0) || ((rdoorf != 0) && (((fvars[fvclantctl] & 0x01) != 0) || 
	   			((rdoorf != 0) && ((fvars[fvclantctl] & 0x02) != 0) && (rdinp(i_RPM) == 0)))))
	   		{
				if ((rear_slowdown != 0) || (rdoorf != 0))			// Rear call stop
				{
					if (((fvars[fvsrlant] & 0x01) == 0) || (((fvars[fvsrlant] & 0x01) != 0) && ((rear_slowdown & irdc_sd) != 0)))
					{ 
			   			setoutp(o_CDLR);
						cab_rlant_dn = 1;
					}
				}
     		}
     	}
     	else
     	{	  
     		// Double gong for front lantern
       		if (timed_lant == 0)
			{
		   		if( (timers[tlant] > fvars[fvlnton]) ||
		   						(timers[tlant] < fvars[fvlntof]) )
	       		{
					if (((cons[dispis] & 2) != 0) && (position == lobby_fl))
					{
						if ((front_slowdown != 0) || (doorf !=0))
							setoutp(o_LD);
					}
					if ((front_slowdown != 0) || (doorf !=0))
						lant_dn = 1;
	       		}
				else
	       		{
					if ((cons[dispis] & 2) != 0)
						clroutp(o_LD);
					lant_dn = 0;
	       		}
       		}
       		else
       		{
	       		if( (((timers[tlant] - (lantern_delay)) > fvars[fvlnton]) && ((timers[tlant] - (lantern_delay)) > 0)) ||
					(((timers[tlant] - (lantern_delay)) > 0) && ((timers[tlant] - (lantern_delay)) < fvars[fvlntof])))
	       		{
					if (((cons[dispis] & 2) != 0) && (position == lobby_fl))
					{
						if ((front_slowdown != 0) || (doorf !=0))
							setoutp(o_LD);
					}
					if ((front_slowdown != 0) || (doorf !=0))
						lant_dn = 1;
	       		}
	       		else
	       		{
					if ((cons[dispis] & 2) != 0)
						clroutp(o_LD);
					lant_dn = 0;
	       		}
			}

     		// Double gong for rear lantern
			if (timed_lant == 0)
			{
	       		if( (timers[trlant] > fvars[fvlnton]) ||
		   						(timers[trlant] < fvars[fvlntof]) )
				{
					if ((rear_slowdown != 0) || (rdoorf != 0))			// Rear call stop
						rlant_dn = 1;
	       		}
	       		else
	       		{
					rlant_dn = 0;
	       		}
			}
			else
			{
				if((((timers[trlant] - (Time_to_Stop - (lantern_delay))) > fvars[fvlnton]) && ((timers[trlant] - (lantern_delay)) > 0)) ||
								(((timers[trlant] - fvars[fvhlandelay]) < fvars[fvlntof]) && ((timers[trlant] - (lantern_delay)) > 0) ))
	       		{
					if ((rear_slowdown != 0) || (rdoorf != 0))			// Rear call stop
						rlant_dn = 1;
	       		}
	       		else
	       		{
					rlant_dn = 0;
	       		}
       		}

     		// Double gong for front cab lantern
       		if ( ((doorf != 2) && (doorf != 3) && (cons[frghtd] == 0) && ((fvars[fvclantctl] & 0x03) == 0)) ||  
       				((doorf == 0) && ((fvars[fvclantctl] & 0x01) != 0)) ||
					(((doorf == 0) || (rdinp(i_DPM) != 0)) && ((fvars[fvclantctl] & 0x02) != 0)) ||
       				((cons[frghtd] != 0) && (rdinp(i_DOL) != 0) && (front_slowdown !=0)) )
			 			timers[tcablnt] = 0;
       		if ((timers[tcablnt] > fvars[fvlnton]+2) || (timers[tcablnt] > doort))
	   				keep_lants_on = 1;

       		if((((timers[tcablnt] > fvars[fvlnton]+2) ||
	   		  (timers[tcablnt] < fvars[fvlntof]+2)) &&
	   		  (timers[tcablnt] > 2)) || (keep_lants_on == 1))
			{
				if ((front_slowdown != 0) || (doorf !=0))
				{
					if (((fvars[fvsrlant] & 0x01) == 0) || (((fvars[fvsrlant] & 0x01) != 0) && ((front_slowdown & irdc_sd) != 0)))
					{ 
						setoutp(o_CDL);
						cab_lant_dn = 1;
					}
				}
       		}
       		else
			{
				clroutp(o_CDL);
				cab_lant_dn = 0;
			}

     		// Double gong for rear cab lantern
       		if ( (cons[rear] != 0) && (((rdoorf != 2) && (rdoorf != 3) && (cons[frghtd] == 0) && ((fvars[fvclantctl] & 0x03) == 0)) || 
				 	((rdoorf == 0) && ((fvars[fvclantctl] & 0x01) != 0)) ||
					(((rdoorf == 0) || (rdinp(i_RPM) != 0)) && ((fvars[fvclantctl] & 0x02) != 0)) ||
       			 	((cons[frghtd] != 0) && (rdinp(i_DOLR) != 0) && (rear_slowdown !=0))) ) 
			 			timers[trcablnt] = 0;

       		if ((timers[trcablnt] > fvars[fvlnton]+2) || (timers[trcablnt] > rdoort))
	   				keep_rlants_on = 1;
       		if((((timers[trcablnt] > fvars[fvlnton]+2) ||
	   		  (timers[trcablnt] < fvars[fvlntof]+2)) &&
	   		  (timers[trcablnt] > 2)) || (keep_rlants_on == 1))
			{
				if ((rear_slowdown != 0) || (rdoorf != 0))			// Rear call stop
				{
					if (((fvars[fvsrlant] & 0x01) == 0) || (((fvars[fvsrlant] & 0x01) != 0) && ((rear_slowdown & irdc_sd) != 0)))
					{ 
						setoutp(o_CDLR);
						cab_rlant_dn = 1;
					}
				}
       		}
       		else
			{
				clroutp(o_CDLR);
				cab_rlant_dn = 0;
			}
     	}
   	}
	
  	return;
}

//***************************************
// Hydro control called from Inctime
//***************************************

void hydro_control (void)
{
	
#if ((Traction == 0) && (Tract_OL == 0))
		if ((cons[EMPop] & 0x03) == 0)
		{
	  		// Hydro car has it's own power for lowering
		  	if (rdinp(i_EMP) == 1)
		  	{
				hydro_on_emp = 1;
				if(rdinp(i_EPS) == 1)
					gempf = ep_switch;
				else
				{
			  		if (((empf == ep_home) || (empf == ep_home_close)) && (Group_IO_Com[cons[carnmb]][g_pos] == ep_recall_fl))
			  			gempf = ep_home;
			  		else
			  			gempf = ep_recall;
				}
		  	}
			else
			{
				gempf = no_ep;
				hydro_on_emp = 0;
			}
			prev_hydro_on_emp = hydro_on_emp;
		}

		if ((cons[home] >= 100) || (cons[Reset_Jack] == 1))
		{			// Must use simplex homing with this operation
			if (((firef != 0) || (rfiref != 0)) && (procf != 18))
			{
				if (rhjackf >= 1)
					rhjackf = 1;		// place jack reset on hold
		 		timers[trhjack] = 0;
				timers[tjackdly] = 0;
			}

			// Check to reset hydro jack
			if ((rhjackf == 1) || ((rhjackf == 2) && (procf != 18)))
			{
				if (timers[trhjack] > 600)		// check timer every 1 minute
				{
					local_gettime();
					if (t.hour >= 2)
					{
						if (position != cons[bottomf])
							zone_fl = cons[bottomf];
						else
							zone_fl = 0;
						if ((position == cons[bottomf]) && 
							(doorf == 0) && (rdinp(i_DCL) == 0) && 
							((cons[rear] == 0) || ((rdoorf == 0) && (rdinp(i_DCLR) == 0))) &&
							(dirf == 0) && (dpref == 0) && (dcalls == 0) &&
							((procf >= 14) && (procf <= 16)) &&
							((safe() == 1) || (((cons[mand] !=0) || (cons[frghtd] != 0)) && (man_dcc() == 1) && (car_gate() == 1))) && 
							(rdinp(i_DZ) == 1))
						{
							rhjackf = 2;
							servf = 0;
							if (timers[tjackdly] > 200)
							{
								procf = 18;
								zone_fl = 0;
							}
						}
						else
							timers[tjackdly] = 0;
					}
					else
					{
						timers[trhjack] = 0;
						timers[tjackdly] = 0;
					}
				}
				else
					timers[tjackdly] = 0;
			}
			else if (rhjackf == 0)
			{
		 		timers[trhjack] = 0;
				timers[tjackdly] = 0;
			}		
		}


#endif
}

//*******************************************
// Status Control from Inctime
//*******************************************
void status_control (int16 start_ck)
{
#if ((Traction == 1) || (Tract_OL == 1))
  	int16 timer_max;
#endif

#if (Tract_HR == 1)
	if (cons[sel_type] == 2)
	{
		rdinp(i_DZSA);
		rdinp(i_UNS);
		rdinp(i_DNS);
	}
#endif

	if (start_ck == 0)
	{
		if (cons[brake] == 3)
		{
			rdinp(i_BKS1);
			rdinp(i_BKS2);
			rdinp(i_BDBS);
		}

		
		if (cons[INS_EN_SFC] == 1)
		{
			if (rdinp(i_SFC) == 1)
			{
				if ((timers[tspb_sfc] <= 2)	|| (timers[tspb_sfc] > 10))
				{
					spb_sfc_fault = 0;
					timers[tspb_sfc] = 0;
				} 
			}
		}
		else
			spb_sfc_fault = 0;

	  	if( (old_firef != firef) || (old_rfiref != rfiref) || 
	  		(old_fire_floor != fire_floor) || (old_gripper_fault != gripper_fault) ||
	  		(old_eqf != eqf) || (old_above_cwt != above_cwt) ||
	  		(old_stallf != stallf))
	  	{
			Update_Control_Flags(cpu_Z6);
	      	old_firef = firef;
	      	old_rfiref = rfiref;
			old_fire_floor = fire_floor;
			old_gripper_fault = gripper_fault;
			old_eqf = eqf;
			old_above_cwt = above_cwt;
			old_stallf = stallf;
	  	}



		if (position != prev_position)
			Update_Pos(cpu_Z6);
		prev_position = position;

		set_scnd_position();
		if(scnd_pos != prev_scnd_pos)
		{
			Update_scnd_Pos(cpu_Z6);
			prev_scnd_pos = scnd_pos;
		}


#if ((Traction == 1) || (Tract_OL == 1))


		// Drive Ready Reset Control

		if ((statusf & sf_READY) != 0)
		{
			if (rdy_flt_latch == 0)
			{
				rdy_flt_latch = 1;
				if (drv_rst_cnt <= fvars[fvdrvrst])
					drv_rst_cnt++;
			}
		}
		else
		{
			rdy_flt_latch = 0;
			if (drv_rst_cnt == 0)
				timers[tdrvrst] = 0;
				
			if (fvars[fvdrvrst] > 0)
				timer_max = (int16)(12000/fvars[fvdrvrst]);
			else
				timer_max = 12000;

			if (timers[tdrvrst] > timer_max)
			{
				timers[tdrvrst] = 0;
				if (drv_rst_cnt <= fvars[fvdrvrst])
				{
					if (drv_rst_cnt > 0)
						drv_rst_cnt--;
				}
			}
		}	

 #if (Traction == 1)
		if (rset == 0)
		{
			if (DPP_Count > mid_hoistway)
				above_cwt = 1;
			else
				above_cwt = 0;
		}
 #else
		if (cons[equake] == 1)
		{
		   	if (rdinp(i_CWS) == 1)   // On the counter wieghts
				on_cws = 1;
			else if ((on_cws == 1) && (rdinp(i_CWS) == 0))
			{			 // Set position once we pass the switch
				if (dirf == 1)
					above_cwt = 1;
				else
					above_cwt = 0;
				on_cws = 0;
			}
		}

 #endif
 
#endif
	}
	
	if (start_ck == 0)
	{
	  	if(rdinp(i_HC) == 1)
			timers[thct] = 0;
	  	if((rdinp(i_HC) == 0) && (timers[thct] >10))
	  	{
		  	// HC fuse blown
			if ((power_status & ps_HC) == 0)
				record_fault(f_HC_fuse);
			power_status |= ps_HC;
	  	}
		else				  
			power_status &= ~ps_HC;

		if ((cons[housing] == 1) || (cons[housing] == 2))
		{
			if ((rdinp(i_CCP) == 1) && (rdinp(i_CCLP) == 1) && (rdinp(i_HCLP) == 1)  && ((rdinp(i_LHCP) == 1) || (cons[housing] != 2)))
				timers[tpst] = 0;
			if ((timers[tpst] > 10) && ((rdinp(i_CCP) == 0) || (rdinp(i_CCLP) == 0) || (rdinp(i_HCLP) == 0) || 
				((rdinp(i_LHCP) == 0) && (cons[housing] == 2)) ))
			{
				if (rdinp(i_CCP) == 0)
				{
					if ((power_status & ps_CC) == 0)
						record_fault(f_CC_fuse);
					power_status |= ps_CC;
				}
				if (rdinp(i_CCLP) == 0)
				{
					if ((power_status & ps_CCL) == 0)
						record_fault(f_CCL_fuse);
					power_status |= ps_CCL;
				}
				if (rdinp(i_HCLP) == 0)
				{
					if ((power_status & ps_HCL) == 0)
						record_fault(f_HCL_fuse);
					power_status |= ps_HCL;
				}
				if ((rdinp(i_LHCP) == 0) && (cons[housing] == 2))
				{
					if ((power_status & ps_LHC) == 0)
						record_fault(f_LHC_fuse);
					power_status |= ps_LHC;
				}

			}
			else power_status &= ~(ps_CC | ps_CCL | ps_HCL | ps_LHC);
		
		}
		else power_status &= ~(ps_CC | ps_CCL | ps_HCL  | ps_LHC);

		if (cons[housing] == 2)
		{
		 	if (rdinp(i_DMO) == 1)
				timers[tdmo] = 0;
		 	if ((rdinp( i_DMO) == 0) && (timers[tdmo] >10))
		 	{
				door_motor_ovl = 1;
		 		if ((statusf2 & sf_DMO) == 0)
		 			record_fault(f_Door_Motor_OVL);
		 		statusf2 |= sf_DMO;
		 	}
			else
			{
				door_motor_ovl = 0;
				statusf2 &= ~sf_DMO;
			}
		}
		else
		{
			door_motor_ovl = 0;
			statusf &= ~sf_DMO;
		}


		if (io_fault == 0)
		{
		
#if (GALaxy_4 == 0)
			if (rdinp(i_DL) != rdinp(i_DL_1))
			{
				if (timers[tdl] > 3)
				{
					record_fault(f_dl_fail);
				    io_fault = 1;
				}
			}
			else
				timers[tdl] = 0;

			if (rdinp(i_UL) != rdinp(i_UL_1))
			{
				if (timers[tul] > 3)
				{
					record_fault(f_ul_fail);
				    io_fault = 1;
				}
			}
			else
				timers[tul] = 0;
#endif

			if (rdinp(i_DLB) != rdinp(i_DLB_1))
			{
				if (timers[tdlb] > 3)
				{
					record_fault(f_dlb_fail);
				    io_fault = 1;
				}
			}
			else
				timers[tdlb] = 0;
				
			if (rdinp(i_DLM) != rdinp(i_DLM_1))
			{
				if (timers[tdlm] > 3)
				{
					record_fault(f_dlm_fail);
				    io_fault = 1;
				}
			}
			else
				timers[tdlm] = 0;

			if (rdinp(i_DLT) != rdinp(i_DLT_1))
			{
				if (timers[tdlt] > 3)
				{
					record_fault(f_dlt_fail);
				    io_fault = 1;
				}
			}
			else
				timers[tdlt] = 0;

			if (rdinp(i_GS) != rdinp(i_GS_1))
			{
				if (timers[tgs] > 3)
				{
					record_fault(f_gs_fail);
				    io_fault = 1;
				}
			}
			else
				timers[tgs] = 0;
			
			if ((cons[rear] == 1) && (rdinp(i_RLM) != rdinp(i_RLM_1)))
			{
				if (timers[trlm] > 3)
				{
					record_fault(f_rlm_fail);
				    io_fault = 1;
				}
			}
			else
				timers[trlm] = 0;

			if ((cons[rear] == 1) && (rdinp(i_RGS) != rdinp(i_RGS_1)))
			{
				if (timers[trgs] > 3)
				{
					record_fault(f_rgs_fail);
				    io_fault = 1;
				}
			}
			else
				timers[trgs] = 0;
		}
		else
		{
			timers[tdlt] = 0;
			timers[tdlm] = 0;
			timers[tdlb] = 0;
			timers[tgs] = 0;
			timers[trlm] = 0;
			timers[trgs] = 0;
			timers[tdl] = 0;
			timers[tul] = 0;
		}
	

	}

	if (start_ck == 0)
	{

		if (hardware_init_fault == 1)
			statusf2 |= sf_HWINIT;
		else
			statusf2 &= ~sf_HWINIT;

		if (safe_closetry >= 6)
			statusf2 |= sf_FDC;
		else
			statusf2 &= ~sf_FDC;

		if (safe_rclosetry >= 6)
			statusf2 |= sf_RDC;
		else
			statusf2 &= ~sf_RDC;

		if (cons[Voltage_Sensor] == 1)
		{
			if ((voltf & 0x07) != 0)
				statusf2 |= sf_LVolt;
			else
				statusf2 &= ~sf_LVolt;

			if ((voltf & 0x08) != 0)
				statusf2 |= sf_DVolt;
			else
				statusf2 &= ~sf_DVolt;
		}
		else
			statusf2 &= ~(sf_LVolt | sf_DVolt);

		if (pwl_ups_fault == 1)
			statusf2 |= sf_PWLUPS;
		else
			statusf2 &= ~sf_PWLUPS;

		if (in_pfc_sfc_test == 0)
		{
			if ((motion_fault == 0) && (gripper_fault == 0))
			{
				setoutp(o_PFC);
				if ((cons[INS_EN_SFC] == 1) && (rdinp(i_SFC) == 0) && (rdinp(i_READY) == 1))
				{			  // Lost SFC but still have drive ready
					if (timers[tspb_sfc] > 2)
					{
						spb_sfc_fault = 1;
						record_fault(f_SPB_SFC_flt);
					}
				}
			}
			else
				clroutp(o_PFC);
		}

	}
	
	if (io_fault == 0)
		timers[tiofltrst] = 0;
	
	if (timers[tiofltrst] > 20)
	{
		if (io_fault_cnt < 2)
			io_fault = 0;
		io_fault_cnt ++;
		timers[tiofltrst] = 0;
	}

	if((io_fault != 0) && (io_fault_cnt > 3))
	{
		statusf |= sf_IO;		// I/O Error
	}
	else
	{
		statusf &= ~sf_IO;
	}
	
	if (start_ck == 0)
	{


#if (Traction == 1) || (Tract_OL == 1)
		brk_iotest();
#endif

#if ((Traction == 1) || (Tract_OL == 1))
		if ((cons[loadw] == 2) && (lw_cal_seq != 0))
			calibrate_lw();
		if ((cons[LW_dis_sw] == 1) && (cons[medEm] == 0) && (rdinp(i_DLW) == 1))
			lw_disable = 1;										 // Uses EMS input
		else
			lw_disable = 0;
#endif

		if (cons[Voltage_Sensor] == 1)  
		{
#if (Simulator == 0)		
			if (can_dev[c_can_VS - c_can_START].online == 1)
			{
				if (L1_Voltage < fvars[fvlowlinevolt]) 
				{
					if ((voltf & 0x01) == 0)
						record_fault(f_L1_Voltage_Low);
					voltf |= 0x01;
				}
				else
					voltf &= ~0x01;
				if (L2_Voltage < fvars[fvlowlinevolt]) 
				{
					if ((voltf & 0x02) == 0)
						record_fault(f_L2_Voltage_Low);
					voltf |= 0x02;
				}
				else
					voltf &= ~0x02;
				if (L3_Voltage < fvars[fvlowlinevolt]) 
				{
					if ((voltf & 0x04) == 0)
						record_fault(f_L3_Voltage_Low);
					voltf |= 0x04;
				}
				else
					voltf &= ~0x04;
				if (Door_Voltage < fvars[fvlowdoorvolt]) 
				{
					if ((voltf & 0x08) == 0)
						record_fault(f_Door_Voltage_Low);
					voltf |= 0x08;
				}
				else
					voltf &= ~0x08;
			}
			else
				voltf = 0;
#endif
		}
		else
			voltf = 0;
	}
	
#if (Simulator == 0)
	// 1038 board

	iodata[1][0] = inp(BRD1A);
	iodata[1][1] = inp(BRD1B);
	iodata[1][2] = inp(BRD1C);
	iodata[1][3] = inp(BRD2A);
	iodata[1][4] = inp(BRD2B);
	iodata[1][5] = inp(BRD2C);
	iodata[1][6] = inp(BRD3A);
	iodata[1][7] = inp(BRD3B);
	iodata[1][9] = inp(BRD4A);
	iodata[1][10] = inp(BRD4B);
	iodata[1][12] = inp(BRD5A);
	iodata[1][13] = inp(BRD5B);
	
	// 1st serial expansion board
	iodata[1][18] = serial.brd_io[BRD7A];
	iodata[1][19] = serial.brd_io[BRD7B];
	iodata[1][20] = serial.brd_io[BRD7C];

	// 2nd serial expansion board
	iodata[1][24] = serial.brd_io[BRD9A];
	iodata[1][25] = serial.brd_io[BRD9B];
	iodata[1][26] = serial.brd_io[BRD9C];

	// 3rd serial expansion Board
	iodata[1][30] = serial.brd_io[BRD11A];
	iodata[1][31] = serial.brd_io[BRD11B];
	iodata[1][32] = serial.brd_io[BRD11C];

	// 4th serial expansion board
	iodata[1][36] = serial.brd_io[BRD13A];					// updating brd14a
	iodata[1][37] = serial.brd_io[BRD13B];					// updating brd14b
	iodata[1][38] = serial.brd_io[BRD13C];					// updating brd14c
	

	// 5th serial expansion board
	iodata[1][42] = serial.brd_io[BRD15A];					// updating brd16a
	iodata[1][43] = serial.brd_io[BRD15B];					// updating brd16b
	iodata[1][44] = serial.brd_io[BRD15C];					// updating brd16c
	

	// 6th serial expansion board
	iodata[1][48] = serial.brd_io[BRD17A];					// updating brd18a
	iodata[1][49] = serial.brd_io[BRD17B];					// updating brd18b
	iodata[1][50] = serial.brd_io[BRD17C];					// updating brd18c
	

	// 7th serial expansion board
	iodata[1][54] = serial.brd_io[BRD19A];				  	// updating brd20a
	iodata[1][55] = serial.brd_io[BRD19A];  				// updating brd20b
	iodata[1][56] = serial.brd_io[BRD19A];  				// updating brd20c
	
	// 7th serial expansion board
	iodata[1][60] = serial.brd_io[BRD21A];				  	// updating brd20a
	iodata[1][61] = serial.brd_io[BRD21A];  				// updating brd20b
	iodata[1][62] = serial.brd_io[BRD21A];  				// updating brd20c

	// TOC board
	iodata[1][66] = serial.brd_io[BRD23A];					// updating brd22a
	iodata[1][67] = serial.brd_io[BRD23B];					// updating brd22b
	iodata[1][68] = serial.brd_io[BRD23C];					// updating brd22c
	iodata[1][72] = serial.brd_io[BRD25A];					// updating brd24a
	iodata[1][73] = serial.brd_io[BRD25B];					// updating brd24b
		
#else
	#if (debug_io_enable == 1)

		iodata[1][18] = serial.brd_io[BRD7A];
		iodata[1][19] = serial.brd_io[BRD7B];
		iodata[1][20] = serial.brd_io[BRD7C];

	#endif
#endif

}
//*******************************************
// Set Car Outputs from Inctime
//*******************************************
void output_control (int16 start_ck)
{
	if (start_ck == 0)
	{
		
#if ((Traction == 1) || (Tract_OL == 1))
		if (cons[Emp_Recover] == 2)
			epr_set_power();
#endif

		if (((procf >= 3) && (procf <= 11)) || (rdoutp(o_UP) == 1) || (rdoutp(o_DNR) == 1))
		{	  // The car is moving
			setoutp(o_DBC);
			DBR_Temp_Fault = 0;
			statusf &= ~sf_DBR;
		}
		else 
		{
/*			if ((DIO1_in & 0x02) == 0)
			{	   // Temperature is too high: sensor trip point
				clroutp(o_DBC);
				if (DBR_Temp_Fault == 0)
					record_fault(f_dbr_temp_flt);
				DBR_Temp_Fault = 1;
				statusf |= sf_DBR;
			}
			else 
*/
			{		 
				setoutp(o_DBC); 
				DBR_Temp_Fault = 0;
				statusf &= ~sf_DBR;
			}
		}


#if (Traction == 1)
		if ((Drive_Type[cons[carnmb]] == 4) && (cons[GOV_Reset] == 0))
		{			// MG set
		  	if((timers[tgen] < fvars[fvgrt]) || (dpref != 0))	// generator output
			{
				setoutp(o_GEN);
				if (timers[tydel] > fvars[fvydel])
					setoutp(o_MST);		// Turn on delta contactor
		  	}
		  	else
			{
				clroutp(o_GEN);		// turn off gen output
				timers[tydel] = 0;			// reset timer for y-deta start
				clroutp(o_MST);		// turn off delta contactor
			}
		}
#endif
		// Motor Blower control
		if ((cons[MtrBlower] == 1) && (cons[GOV_Reset] == 0))
		{
		  	if ( (timers[tgen] < fvars[fvgrt]) || (dpref != 0) || 
		  				(rdoutp(o_UP) == 1) || (rdoutp(o_DNR) == 1) )
				setoutp(o_MTB);		  // Motor Blower output   (GEN output)
		  	else
				clroutp(o_MTB);		// turn off MTB output
		}

		if (cons[F1_ML_AL] == 1)
		{
			if (cons[equake] == 0)
			{
				if ((firef == 1) || (rfiref == 1) || (((firef == 3) || (rfiref == 3)) && (fire_floor == fvars[fvfs1f])))
					setoutp(o_F1ML);
				else
					clroutp(o_F1ML);
			}

			if (cons[medEm] == 0)
			{
				if ((firef == 2) || (rfiref == 2) || (((firef == 3) || (rfiref == 3)) && (fire_floor == fvars[fvfs1af])))
					setoutp(o_F1AL);
				else
					clroutp(o_F1AL);
			}
		}

		set_rcm();


		if ((cons[dispis] & 0x01) == 0)
		{
			if (cons[StagRear] == 1) 
			{
				if (stag_rmsk[position] == 1)
					setoutp(o_DTR);
				else
					clroutp(o_DTR);

				if (cons[exDHwL] == 0)
				{
					if (cons[vshort_tfl] == position)
						setoutp(o_SFST);
					else
						clroutp(o_SFST);
				}
			}
			else if (cons[vshort_tfl] != 0) 
			{
				if (cons[vshort_tfl] == position)
					setoutp(o_DTR);
				else
					clroutp(o_DTR);
			}
		}

		if ((cons[DZDoorEn] == 1) && (cons[medEm] == 0) && (cons[cblue] == 0))
		{
			if ((procf == 2) && (startf == 1))
				clroutp(o_DZDE);
#if (Traction == 1)
			else if ((Dmd_Velocity < (Pulses_per_Inch * 30.0)) &&   // less than 150 fpm.
				(hsf == 0) && (rdinp(i_DZ) == 1))
#else
			else if ((hsf == 0) && (rdinp(i_DZ) == 1))
#endif
				setoutp(o_DZDE);
			else
				clroutp(o_DZDE);
		}

		if ((cons[GLBP_LED] == 1) && (cons[medEm] == 0) && (cons[equake] == 0))
		{							// Uses EMLH, EQL
			if (rdinp(i_GBP) == 1) 
				setoutp(o_GBL);
			else
				clroutp(o_GBL);  
			
			if (rdinp(i_LBP) == 1)
				setoutp(o_LBL);
			else
				clroutp(o_LBL);
		}

		if (cons[GOV_Reset] == 1)
		{
			if ((govrstf == 1) && (timers[tgovrst] < 20))
				setoutp(o_GOVR);
			else 
			{
				if (govrstf == 1)
					govrstf = 2;
				clroutp(o_GOVR);
			}

			if ((govtripf == 1) && (timers[tgovtrip] < 20))
				setoutp(o_GOVT);
			else 
			{
				if (govtripf == 1)
					govtripf = 2;
				clroutp(o_GOVT);
			}
		}
	}
}

//************************************************
// Set Group Inputs and Outputs from Inctime
//************************************************
void set_grp_io (void)
{
#if (GALaxy_4 == 0)
	uint16 i;
#endif
	
	if (rdinp(i_EMP) == 1)
		gin_EMP = 1;
	else
		gin_EMP = 0;
	if (rdinp(i_EPT) == 1)
		gin_EPT = 1;
	else
		gin_EPT = 0;
	
	if (rdinp(i_ATTHC) == 1)
		gin_ATTHC = 1;
	else
		gin_ATTHC = 0;
	
    if (rdinp(i_DOL) == 0) 	  // if manual doors and the door is open
    	gin_DOL = 0;
    else
    	gin_DOL = 1;
    
    if (rdinp(i_DOLR) == 0)
    	gin_DOLR = 0;
    else 
    	gin_DOLR = 1;
    
  	if (rdinp(i_HC) == 1)	
  		gin_HCP = 1;
  	else
  		gin_HCP = 0;
	if (rdinp(i_SAB) == 1)
		gin_SAB = 1;
	else
		gin_SAB = 0;
	
	if (rdinp(i_SECFM) == 1)
		gin_SECFM = 1;
	else
		gin_SECFM = 0;
	
#if (GALaxy_4 == 0)
	if (gc_hc_dev == 0)
	{
	  	for(i=1; i < 5; i++)
	  	{
	   		if (rdinp(i_UCM(i)) == 1)// check to see if up hall call pushed
				gin_UC[i] = 1;
	   		else
	   			gin_UC[i] = 0;
	   		
	   		if (gout_UC[i] == 1)
				setoutp(o_UCML(i));		// no car cancelling the call
	   		else
				clroutp(o_UCML(i));		// no car cancelling the call
	  	}
	  	
	  	for(i=2; i <= cons[grtopf]; i++)
	  	{
	      	if (rdinp(i_DCM(i)) == 1)  //check to see if dn hall call pushed
				gin_DC[i] = 1;
	   		else
	   			gin_DC[i] = 0;
	   		
	   		if (gout_DC[i] == 1)
				setoutp(o_DCML(i));		// no car cancelling the call
	   		else
				clroutp(o_DCML(i));		// no car cancelling the call
	  	}
	}

  	if (gc_hc_dev == 0)
  	{			   // no serial hall call board
	  	if( (cons[carnmb] == 2) && (Dispatcher != 2) )
	  	{			  
			for(i=cons[bottomf]; i<cons[topf]; i++)
				clroutp(o_UCML(i));
			for(i=(int16)(cons[bottomf]+1); i<=cons[topf]; i++)
				clroutp(o_DCML(i));
	  	}	
	}
#endif
}

//**********************************
// Comm control called from Inctime
//**********************************
void comm_control (void)
{
#if ((Traction == 1) || (Tract_OL == 1))

	if ((cons[PWL_Brake] == 1) || ((cons[Emp_Recover] == 2) && ((cons[UPS_Type] == 1) || (cons[UPS_Type] == 2))))
		UPS_comm();
	else
		pwl_ups_fault = 0;
#else
		pwl_ups_fault = 0;
#endif

#if ((Traction == 1) || (Tract_OL == 1))
	if ((cons[Ser_IGEP] == 1) && (cons[carnmb] == Dispatcher))
		IGEP_comm();
#endif


#if ((Traction == 1) || (Tract_OL == 1))
	if ((cons[sercom] & 8) != 0)
		drv_com ();
#endif


  	if ((cons[sercom] & 0x02) != 0)		// Must be after diag for set_carcall to work
		can_control ();
  	
  	Group_Com();
}


//*******************************************
// Door Control from Inctime
//*******************************************

void door_control (int16 start_ck)
{
	if (start_ck == 0)
	{
		// Set Manual door flag here for front door and rear door
		// Note: This flag is set for any manual door operation.  Also manual_door is set on a per
		//       floor basis for special manual and automatic door so for lock checks the cons[mand] flag is used
		//       so that the door close contact must be on to have door locks.   

		if ((cons[mand] == 1) || (cons[mand] == 3))
		{
			manual_door = 1;		// Manual doors
			manual_rdoor = 1;
		}
		else if (cons[mand] == 2)
		{						   // Swing doors
				manual_door = 2;
				manual_rdoor = 2;
		}
		else if (((cons[mand] == 4) || (cons[mand] == 5)) && (cons[StagRear] == 1) && (stag_rmsk[position] == 1))
		{							
			if (cons[mand] == 4) 
			{					   // Automatic front with manual rear at staggard rear floor
				manual_door = 1;
				manual_rdoor = 0;
			}
			else if (cons[mand] == 5) 
			{					  // Automatic front with Swing rear at staggard rear floor
				manual_door = 2;
				manual_rdoor = 0;
			}
		}
		else if (cons[mand] == 6)	// Automatic front with swing rear door
		{
			manual_door = 0;
			manual_rdoor = 2;
		}
		else if ((cons[mand] == 7) && (cons[stag_auto_door] != 0))	// Automatic/swing fron with manual rear
		{													
			if (cons[stag_auto_door] == 1)
			{								// auto/swing front manual rear
				if (stag_ado_msk[position] == 1)
					manual_door = 2;		
				else
					manual_door = 0;
				manual_rdoor = 1;
			}
			else if (cons[stag_auto_door] == 2)
			{								 // auto/swing rear manual front
				manual_door = 1;
				if (stag_ado_rmsk[position] == 1)
					manual_rdoor = 2;
				else
					manual_rdoor = 0;
			}
			else if (cons[stag_auto_door] == 3)
			{								  // auto/swing front and rear
				if (stag_ado_msk[position] == 1)
					manual_door = 2;		
				else
					manual_door = 0;
				if (stag_ado_rmsk[position] == 1)
					manual_rdoor = 2;
				else
					manual_rdoor = 0;
			}
		}
		else if ((cons[mand] == 8) && (cons[stag_auto_door] != 0))	// Automatic/swing fron with manual rear
		{													
			if (cons[stag_auto_door] == 1)
			{								// auto/swing front manual rear
				if (stag_ado_msk[position] == 1)
					manual_door = 2;		
				else
					manual_door = 1;
				manual_rdoor = 1;
			}
			else if (cons[stag_auto_door] == 2)
			{								 // auto/swing rear manual front
				manual_door = 1;
				if (stag_ado_rmsk[position] == 1)
					manual_rdoor = 2;
				else
					manual_rdoor = 1;
			}
			else if (cons[stag_auto_door] == 3)
			{								  // auto/swing front and rear
				if (stag_ado_msk[position] == 1)
					manual_door = 2;		
				else
					manual_door = 1;
				if (stag_ado_rmsk[position] == 1)
					manual_rdoor = 2;
				else
					manual_rdoor = 1;
			}
		}
		else if ((cons[mand] == 9)&&(cons[stag_auto_door] != 0))
		{
			manual_door = 0;
			manual_rdoor = 0;
			if (stag_ado_msk[position] == 1)
			{
				auto_rcm = 1;
				manual_door = 2;
			}
			else if	(stag_ado_rmsk[position] == 1)
			{
				auto_rcm = 2;
				manual_rdoor = 2;
			}
			else
				auto_rcm = 0;

		}		
		else 
		{
			manual_door = 0;
			manual_rdoor = 0;
		}

		// 2=peele,3=courion,4=ems
		if (cons[frghtd] == 2)
			peelle_doors();

		if ((cons[frghtd] == 3) || (cons[frghtd] == 5))
			courion_doors();

		if (cons[frghtd] == 4)
			ems_doors();

		// Set for automatic freight door operation 

		if ((cons[frghtd] == 6) || (cons[frghtd] == 7) || (cons[frghtd] == 8))
			auto_freight_doors();
		
		if (cons[frghtd] == 9)
			guilbert_doors();
	
		if (cons[heavy_door] == 1)
		{
			if (heavy_door_fmsk[position] == 1)
				setoutp(o_HVD);
			else
				clroutp(o_HVD);

			if (heavy_door_rmsk[position] == 1)
				setoutp(o_HVDR);
			else
				clroutp(o_HVDR);
		}
	}
}

//*******************************************
// Buzzer Control from Inctime
//*******************************************

void light_buzzer_control (int16 start_ck)
{
	int16 keep_timer_zero;
	int16 keep_fan_on;

#if (Hollister) == 1
	static int16 sec_count;

		// 	Temp for Hollister
			
	if (start_ck == 0)
	{

		if (timers[tsec] != 0)
		{
			if (sec_count >= 1)
			{			 
				sec_count = 0;
				if (fvars[fvhcboncolor] != 0)
				{
					if (fvars[fvhcboncolor] < 15)
						fvars[fvhcboncolor] ++;
					else
						fvars[fvhcboncolor] = 1;

					fvars[fvhcboffcolor] = fvars[fvhcboncolor];
					calculate_button_color();
				}
			}
		}
		else
			sec_count ++;
	}
#endif


	if (start_ck == 0)
	{
		if (((cons[hben] & 0x01) != 0) && ((cons[sercom] & 0x2) != 0))
		{
			if (rdinp(i_HBE) == 1)
				hb_en = 1;			
		}
		else
			hb_en = 1;

		// Timing for Cab Light and fan control
		
		if (((servf == 20) || (servf == 19)) && ((fvars[fveloff] & 0x04) != 0))
			keep_timer_zero = 0;	  // time exp okay with door open
		else if ((doorf != 0) || ((cons[rear] != 0) && (rdoorf != 0))) 
			keep_timer_zero = 1;
		else
			keep_timer_zero = 0;

		if ((dpref != 0) || (keep_timer_zero == 1) ||
			(rdinp(i_UL) == 0) || (rdinp(i_DL) == 0) || (rdinp(i_DZ) == 0) ||
			(rdoutp(o_UP) == 1) || (rdoutp(o_DNR) == 1) )
		{		 // IF a run preference, doors open, not in the door zone or moving then zero 
				 // the timer to turn on the lights
			timers[tclf] = 0;
		}

		if ((cons[sercom] & 2) != 0)
		{	   // serial comm to the car (Can use both options)

			if ((servf != 1) && (((servf != 20) && (servf != 19)) || ((fvars[fveloff] & 0x04) == 0)))
				keep_fan_on = 1;
			else
				keep_fan_on = 0;
				
			if ((timers[tclf] < fvars[fvgrt]) ||  (keep_fan_on == 1))
			{
				if (fvars[fvclf] == 0)
					setoutp(o_CLF);	 // Cab light fan
				else
					clroutp(o_CLF);
			}
			else
			{
				if (fvars[fvclf] == 0)
					clroutp(o_CLF);
				else
					setoutp(o_CLF);	 // Cab light fan
			}
		}

		// Set output to indicate car is on fire service
		if ((fvars[fvfsofl] & 0x04) != 0)
		{
			if (rdoutp(o_FL) == 1)
				setoutp(o_FSO);
			else
				clroutp(o_FSO);
		}
		else if ((fvars[fvfsofl] & 0x01) == 0)
		{
			if (firef != 0)
	    	{
	      		if (((fvars[fvfsofl] & 0x02) != 0) && (timers[tsec] != 0))
					clroutp(o_FSO);
				else				
					setoutp(o_FSO);
			}
			else
				clroutp(o_FSO);
		}
		else 
		{
			if (fs1_effect != 0)
	    	{
	      		if (((fvars[fvfsofl] & 0x02) != 0) && (timers[tsec] != 0))
					clroutp(o_FSO);
				else				
					setoutp(o_FSO);
			}
			else
				clroutp(o_FSO);
		}

		if ((cons[FI_EP_Ext] != 0) || (cons[Australia] == 1))
		{				// Car emregency power hall light operation
			if (empf != 0)
			{
				setoutp(o_EPLH);
				if (empf == ep_recall)		// flash Recall light
				{
					if (timers[tsec] != 0)
						setoutp(o_EPRL);
					else
						clroutp(o_EPRL);
					clroutp(o_EPSL);
				}
				else if ((empf == ep_home) || (empf == ep_home_close))	// on steady
				{
					setoutp(o_EPRL);
					clroutp(o_EPSL);
				}
				else if (empf == ep_select)	// Selected to run
				{
					setoutp(o_EPSL);
					clroutp(o_EPRL);
				}
			}
			else
			{
				clroutp(o_EPLH);
				clroutp(o_EPRL);
				clroutp(o_EPSL);
			}

			if (rdoutp(o_FSO) == 1)
				setoutp(o_FLH);
			else
				clroutp(o_FLH);
		}	
		
		if (cons[RGB_CC] == 1)
		{
			if (rdoutp(o_FL) == 1)
				setoutp(o_FiFL);
			else
				clroutp(o_FiFL);
		}

		if ((cons[F1_CT] == 1) && ((cons[sercom] & 0x04) != 0))
		{
			if (rdoutp(o_FL) == 1)
				setoutp(o_FLCT);
			else
				clroutp(o_FLCT);

			if (rdoutp(o_FBNB) == 1)
				setoutp(o_FBNBCT);
			else
				clroutp(o_FBNBCT);
		}


		//Set or clear the att_buz_hc
		if(fvars[fvhcattbuz] == 1)
		{
			if((timers[tsec] == 0))
				att_buz_hc = 0;
			if((att_nmb_hc2buz>0) && (att_buz_hc ==0) && (att_buz_hc_en == 0) && ((timers[tsec] == 0)))
			{
				att_nmb_hc2buz--;
				att_buz_hc_en = 1;
			}
			if (att_buz_hc_en == 1)
			{
				if (timers[tsec] != 0)
				{
					att_buz_hc = 1;
					att_buz_hc_en = 0;
				}

			}
		}
		else
		{
			att_buz_hc_en = 0;
			att_buz_hc_en = 0;		
		}
		// Set or clear car buzzer

		// fire buzzer, nudging buzzer and medical emergency buzzer are the same output
		if ((fire_buz == 1) || (nudg_buz == 1) || (rnudg_buz == 1) || 
			(med_buz  == 1) || (att_buz_hc == 1) || ((att_buz == 1) && (att_buz_on == 1)) || (door_buz == 1) || (
			(gripper_fault == 1) && (fvars[fvgripbz] == 1)) )
			setoutp(o_FBNB);      // Turn on the buzzer
		else
			clroutp(o_FBNB);      // Turn off the buzzer

		if ((hb_en == 1) && (hb_cc_buz == 1))
		{
			if (timers[thbcc] >= fvars[fvhboncct])
				hb_cc_buz = 0;
		}

		if ((cons[frghtd] == 6) || (cons[frghtd] == 7) || (cons[frghtd] == 8))
		{
			if ((cons[cblue] ==  0) && (cons[medEm] == 0))
			{
				if ((freight_fdoor_alarm == 1) || (freight_rdoor_alarm == 1))
					setoutp(o_DCA);
				else
					clroutp(o_DCA);
			}			
		}


#if ((Traction == 1) || (Tract_OL == 1))
		if ((cons[MR_FBZ] == 1) && (cons[MtrBlower] == 0) && (cons[GOV_Reset] == 0))
		{
			if (fire_buz == 1)
				setoutp(o_FBZ);      // Turn on the machine room buzzer
			else
				clroutp(o_FBZ);      // Turn off the machine room buzzer
		}
#else
		if ((cons[MR_FBZ] == 1) && (cons[Auto_Swing_DO] == 0))
		{
			if (fire_buz == 1)
				setoutp(o_FBZ);      // Turn on the machine room buzzer
			else
				clroutp(o_FBZ);      // Turn off the machine room buzzer
		}
#endif

		if ( ((handicap_buz == 1) 
			 || ((hb_cc_buz == 1) && (((cons[hben] & 0x02) != 0) || ((cons[hben] & 0x04) != 0))))
			 || (cc_sec_buz == 1))
			setoutp(o_HB);
		else
		 	clroutp(o_HB);

		if ((cons[GLBP_LED] == 0) && (cons[medEm] == 0) && (cons[exDHwL] == 0) &&
			(cons[cblue] == 0) && (cons[DZDoorEn] == 0)	&& (cons[door_type] != 1) &&
			(cons[frghtd] != 6) && (cons[frghtd] != 7) && (cons[frghtd] != 8) &&
			(cons[F1_ML_AL] == 0) && (cons[Sabbath] != 0) )
		{
			if ((firef != 0) || (rfiref != 0))
			{
				sabb_buz = 0;
				sabb_ee_en = 0;
			}
			if(cons[Super_Sabbath] == 1)
			{
				if (sabb_buz ==1)
				{
					setoutp(o_SABUZ);
				}
				else
				{
					clroutp(o_SABUZ);
				}
				if(sabb_ee_en == 1)
				{
					setoutp(o_SABEE);
				}
				else
				{
					clroutp(o_SABEE);	
				}
			}
		}

		if (cons[Sabbath] != 0)
		{
			if ((firef != 0) || (rfiref != 0))
				sabbath_active = 0;
			else if ((rdinp(i_SAB) == 1) || (tmr_svc[s_sabbath] == 1))
				sabbath_active = 1;			// on sabbath operation
			else
			{		 // Go off of sabbath immediately or when car reaches lobby floor
				if ((fvars[fvsabben] & 0x04) == 0)
					sabbath_active = 0;
				else if ((position == lobby_fl) && (procf >= 14) && (procf <= 16)&&(doorf == 3))	// at floor at lobby
					sabbath_active = 0; 
			}

#if (Traction == 1)
			if (cons[speed] <= 1100)
			{			   // must not conflict with DT5
				if ((cons[Sabbath] == 4) || (cons[Sabbath] == 5))
				{
					if (servf == 25)
						setoutp(o_SABO);
					else
						clroutp(o_SABO);
				}
			}
#endif
		}

		if (((cons[dispis] & 2) == 0) || ((cons[GLBP_LED] == 0) && (cons[equake] == 0))) 
		{
		  	if ((((fvars[fvsapb] & 0x01) != 0) && (cons[nmbcars] == 1)) || ((fvars[fviser] & 0x02) != 0))
		  	{
	      		if ((rdinp(i_DOL) == 0) || (dpref != 0) || // if door is open or there is an onward pilot
					((cons[rear] != 0) && (rdinp(i_DOLR) == 0)))
					in_serv_lt = 0;
				else
					in_serv_lt = 1;

				if ((manual_door == 2) || (manual_rdoor == 2))
				{
					if ((man_dcc() == 0) || (dpref != 0))	
						in_serv_lt = 0;
					else
						in_serv_lt = 1;
				}
			}
			else
				in_serv_lt = 1;

			if(((cons[Elev_off] & 8) == 0)&&((cons[Elev_off] & 0x10) == 0))
			{
				if (((Drive_Type[cons[carnmb]] == 1) || (Drive_Type[cons[carnmb]] == 9)) && ((fvars[fvins] >= cons[speed]) || (fvars[fvinsiser] == 1))) 
				{		   // Hydro car
					// Set in service light
					if ((servf == 0) && (procf == 2))		// run faster on inspection on inspection
					{
						if ((fvars[fviser] & 0x01) == 0)
							setoutp(o_ISER);	  
						else
							clroutp(o_ISER);
					}
					else
					{
						if ((fvars[fviser] & 0x01) == 0)
							clroutp(o_ISER);
						else
							setoutp(o_ISER);	  
					}
				}
				else
				{		
													 
					// Set in service light
					if ( ( (servf == 1) || (servf == 4) || (servf == 11) || 
						   (  ( ((fvars[fviser] & 0x04) != 0) && 
								  ( (servf == 2) || (procf == 2) || 
								  	((safe() == 1) && ((servf == 12) || (servf == 13) || (procf == 1)))
								  ) 
							  ) 
						   ) 
					     ) && (in_serv_lt == 1) && (estop == 0))
					{					// Car is in service (if (fviser & 0x04) != 0 then car still operational)
						if ((fvars[fviser] & 0x01) == 0)
							setoutp(o_ISER);	   // auto, attendant, or homing(parking) or special case to not show inspection as out of service to use iser as an alarm
						else
							clroutp(o_ISER);
					}
					else
					{									  // invert logic of in-service light
						if ((fvars[fviser] & 0x01) == 0)
							clroutp(o_ISER);
						else
							setoutp(o_ISER);	   // auto, attendant, or homing(parking)
					}
				}
			}  
		}

		car_alrm = rdinp(i_ALRM);

		if(oserl_enable == 1)
		{
			if((ind() == 0) && (chk_ins() == 0) && (firef == 0))
			{
				oser_lt = 0;
				oser_bz = 0;
				oser_bz_pulse = 0;
				if((fvars[fvoser1] == 0) && (fvars[fvoser2] == 0))
				{
					if((servf == 1)||(servf == 2)||(servf == 4)|| (servf == 11))
						oser_lt = 0;
					else 			
						oser_lt = 1;	
				}
				else
				{
					if(((fvars[fvoser1] & 0x01) != 0)&&(dcalls != 0)&&(timers[tosernocall] > fvars[fvosernocall]))
					{
						oser_lt = 1;
						oser_bz = 1;
						oser_bz_pulse = 1;
					}
					else if (((front_slowdown & (cc_do | uc_do | dc_do)) != 0) || ((rear_slowdown & (cc_do | uc_do | dc_do)) != 0 ))
						timers[tosernocall] = 0;
					else if (dcalls == 0)
						timers[tosernocall] = 0;
						

					if(((fvars[fvoser1] & 0x02) != 0) && ((rdinp(i_DZ) == 0) && (timers[toserbtwfl] > fvars[fvoserbtwfl])))
						oser_lt = 1;
					else if(rdinp(i_DZ) == 1)
						timers[toserbtwfl] = 0;

					if(((fvars[fvoser1] & 0x04) != 0) && (rdinp(i_STP) == 0) && (timers[toserssopen] > fvars[fvoserssopen]))
					{
						oser_lt = 1;
						oser_bz = 1;
					}
					else if (rdinp(i_STP) == 1)
						timers[toserssopen] = 0;
					if(((fvars[fvoser1] & 0x01) != 0) && (rdinp(i_ALRM) == 1))
					{
						oser_lt = 1;
						oser_bz = 1;
					}
							
				}
				if(cons[distress] == 1)
				{
					if(rdinp(i_OSERA) == 1)
					{
						oser_lt = 0;
						oser_bz = 0;
						oser_bz_pulse = 0;
						timers[tosernocall] = 0;
						timers[toserbtwfl] = 0;
						timers[toserssopen] = 0;
					}
					if(oser_bz == 1)
					{
						if((oser_bz_pulse == 1) && (timers[tsec] != 0))
						{
							clroutp(o_OSERB);

						}
						else if (oser_bz == 1)
						{
							setoutp(o_OSERB);
						}
						else
							clroutp(o_OSERB);
					}
					else
					{
							clroutp(o_OSERB);
					}

				}

				if(oser_lt == 1)
					setoutp(o_OSERL);
				else
					clroutp(o_OSERL);

			}	

		}
	}
}


//*************************************************
// Check Motion Fault called from Inctime
//*************************************************

void chk_motion_fault (int16 start_ck)
{
	int16 i;
	
#if (Traction == 1)
	
	if (fvars[fvencinterval] < 1)
		enc_dbn_interval = 1;
	else
		enc_dbn_interval = fvars[fvencinterval];

	if (fvars[fvencsamples] < 2)
		enc_nmb_samples = 2;
	else
		enc_nmb_samples = fvars[fvencsamples];

	if (enc_vel_timer >= enc_dbn_interval) 
	{			
  		if (DPP_Count > Prev_DPP_Count)
		{
			t_Enc_dir = 1;			// Up direction
  			vel_DPP[vel_DPP_ptr++] = (DPP_Count - Prev_DPP_Count);		// Store dpp count at 10msec interval 
		}
  		else if (DPP_Count < Prev_DPP_Count)
		{
			t_Enc_dir = 2;			// Down Direction
			vel_DPP[vel_DPP_ptr++] = (Prev_DPP_Count - DPP_Count);		// Store dpp count at 10msec interval 
		}
		else				
		{
			t_Enc_dir = 0;			// No direction
			vel_DPP[vel_DPP_ptr++] = 0;
		}

  		Prev_DPP_Count = DPP_Count;

		if ((t_Enc_dir == Prev_Enc_dir) && (enc_dir_timer >= 3))
		{
			Enc_dir = t_Enc_dir;
			enc_dir_timer = 0;
		}

		Prev_Enc_dir = t_Enc_dir;

		// Update velocity calculation from encoder every 10 msec
		if (vel_DPP_ptr > (enc_nmb_samples - 1))
			vel_DPP_ptr = 0;

		tvel_DPP = 0;
		// This routine can only run once if all conditions are met. If not, then it clears flag and does not run
		//It prevents the rope gripper from tripping if the ppr is updated 
		if((new_PPR_setting == 1) && ((chk_ins() == 1)||(rdoutp(o_RUN) == 0)) && (cons[sel_type] == 3))
		{
			tvel_DPP = 0;
			for (i=0;i<10;i++)
				vel_DPP[i] = 0;
			new_PPR_setting = 0;
		}
		else
		{
			new_PPR_setting = 0;
		}

		for(i=0;i<=(enc_nmb_samples - 1);i++)
			tvel_DPP = tvel_DPP + vel_DPP[i];		
		Enc_vel = (float)tvel_DPP;
		Enc_vel = Enc_vel * ((float)100.0/(float)(enc_nmb_samples * enc_dbn_interval));	  // * 100 to get seconds / 10 samples

		enc_vel_timer -= enc_dbn_interval;		
	}


	enc_vel_fpm = (int16)((Enc_vel * 5.0)/(Pulses_per_Inch));

	if ((enc_vel_fpm > ((cons[speed] * fvars[fvovrspd])/100)) && (Overspeed_Test == 0))
	{	// Trip at 125%
		if (enc_vel_fpm > (cons[speed] * 1.25))
		{
			if (ovs_dbn_tim > 30)
			{
				if ((cons[ansi] >= 2000) && (gripper_fault == 0))
				{			// Trip the gripper if over 125
					if (cons[EM_BRK] != 0)
						record_fault(f_EMBK_trip);
					else
						record_fault(f_grip_trip);
					gripper_fault = 1;
					SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
					gripper_test = 20;		// don't run the gripper test accidentally
					clroutp(o_GR1R);
					clroutp(o_GR2R);
					clroutp(o_LE);
					clroutp(o_LE1);
				}
				ovs_dbn_tim = 0;
				if (motion_fault == 0)
					record_fault(f_vel_overspeed);
				motion_fault = 1;
			}
		}
		if (ovs_dbn_tim > 150)
		{		// Trip from overspeed parameter
			if (((fvars[fvspbgrip] & 0x02) != 0) && (cons[ansi] >= 2000) && (gripper_fault == 0))
			{
				if (cons[EM_BRK] != 0)
					record_fault(f_EMBK_trip);
				else
					record_fault(f_grip_trip);
				gripper_fault = 1;
				SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
				gripper_test = 20;		// don't run the gripper test accidentally
				clroutp(o_GR1R);
				clroutp(o_GR2R);
				clroutp(o_LE);
				clroutp(o_LE1);
			}
			if (estop == 0)
				record_fault(f_vel_overspeed);
			estop = 1;
		}
	}
	else
		ovs_dbn_tim = 0;

	if (start_ck == 0)
	{
		// Velocity Difference
	 
		dmd_vel_fpm = (int16)(((Drv_Velocity * 5.0)/(Pulses_per_Inch)) + 0.5);	// demand velocity to the drive
		if ((enc_vel_fpm > (dmd_vel_fpm * 2)) &&  ((enc_vel_fpm - dmd_vel_fpm) > fvars[fvveldiff])  &&
							((enc_vel_fpm > 100) || (enc_vel_fpm > cons[speed])))
		{
			if ((estop == 0) && (((procf >= 4) && (procf <= 11)) || ((procf >= 14) && (procf <= 16))) && (tmr_vel_diff > 20) && (fvars[fvveldifffltdis] == 0))
			{
				record_fault(f_vel_decel_diff);
				estop = 1;
				if ((cons[ansi] >= 2000) && (gripper_fault == 0))
				{			// Trip the gripper if over 125
					gripper_fault = 1;
					SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
					gripper_test = 20;		// don't run the gripper test accidentally
					clroutp(o_GR1R);
					clroutp(o_GR2R);
					clroutp(o_LE);
					clroutp(o_LE1);
				}
				vel_decel_diff_fault = 1;
			}
		}
		else
			tmr_vel_diff = 0;
			
		if (estop == 0)
		{
			if (abs(enc_vel_fpm - SPB_can.velocity) > fvars[fvslipveldiff])
				spb_vel_diff = 1;
			else
				spb_vel_diff = 0;
		}
		else
		{
			if (abs(enc_vel_fpm - SPB_can.velocity) > (fvars[fvslipveldiff] * 2))
				spb_vel_diff = 1;
			else
				spb_vel_diff = 0;
		}
		
		if ((spb_vel_diff == 1) && (fvars[fvslipveldiff] != 0) && (fvars[fvslipveldiffdis] == 0))
		{
		
#if (Simulator == 0)
			if (tmr_spb_vel_diff > 30)		// 300 msec
			{
				record_fault(f_spb_vel_diff);
				estop = 1;
				if ((cons[ansi] >= 2000) && (gripper_fault == 0))
				{			// Trip the gripper if over 125
					gripper_fault = 1;
					SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
					gripper_test = 20;		// don't run the gripper test accidentally
					clroutp(o_GR1R);
					clroutp(o_GR2R);
					clroutp(o_LE);
					clroutp(o_LE1);
				}
				spb_vel_diff_fault = 1;
			}
#endif
		}
		else
			tmr_spb_vel_diff = 0;
	}	

	if ((drive_online == 0) && ((cons[sercom] & 8) != 0))
		estop = 1;
#endif

#if((Traction == 1) || (Tract_OL == 1))
	if (start_ck == 0)
	{
		// SPB Direction Fault
		if ((chk_ins() == 0) && (
#if (Traction == 1)
			((cons[sel_type] != 0) && (((SPB_can.version == 5) && (SPB_can.revision >= 9)) || (SPB_can.version > 5)) ) || 
#endif
			((SPB_can.version == 5) && (SPB_can.revision >= 17)) ||
			((SPB_can.version == 6) && (SPB_can.revision >= 5)) ||
			(SPB_can.version > 6)) )
		{
#if (Traction == 1)
			if ( ((SPB_can.velocity > 100) || (enc_vel_fpm > 100)) && 
				 ( ((SPB_can.vel_dir == 1) && (rdoutp(o_DNR) == 1)) || 
				   ((SPB_can.vel_dir == 2) && (rdoutp(o_UP) == 1))) )
#else
			if ( (SPB_can.velocity > 100) && 
				( ((SPB_can.vel_dir == 1) && (rdoutp(o_DNR) == 1)) || 
				  ((SPB_can.vel_dir == 2) && (rdoutp(o_UP) == 1))) )
#endif
			{	   // Car moving up while trying to run down and vise versa.
#if (Simulator == 0)			
				if ((estop == 0) && (procf >= 4) && (procf <= 11) && (tmr_spb_enc_dir > 20) && (fvars[fvspbdirfltdis] == 0))
				{
					record_fault(f_spb_dir_fault);
					estop = 1;
					if ((cons[ansi] >= 2000) && (gripper_fault == 0))
					{			// Trip the gripper if over 125
						gripper_fault = 1;
						SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
						gripper_test = 20;		// don't run the gripper test accidentally
						clroutp(o_GR1R);
						clroutp(o_GR2R);
						clroutp(o_LE);
						clroutp(o_LE1);
					}
					spb_dir_fault = 1;
				}
#endif
			}
			else
				tmr_spb_enc_dir = 0; 
		}
		else
			tmr_spb_enc_dir = 0; 

  #if (Traction == 1)
		// Controller Encoder Direction Fault
		if (chk_ins() == 0) 
		{		// not on inspection
			if ((enc_vel_fpm > 50) && ( ((rdoutp(o_UP) == 1) && (Enc_dir == 2)) || ((rdoutp(o_DNR) == 1) && (Enc_dir == 1)) ))
			{
				if ((estop == 0) && (procf >= 4) && (procf <= 11) && (tmr_enc_dir > 20) && (fvars[fvdirfltdis] == 0))
				{
					record_fault(f_dir_fault);
					estop = 1;
					if ((cons[ansi] >= 2000) && (gripper_fault == 0))
					{			// Trip the gripper if over 125
						gripper_fault = 1;
						SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
						gripper_test = 20;		// don't run the gripper test accidentally
						clroutp(o_GR1R);
						clroutp(o_GR2R);
						clroutp(o_LE);
						clroutp(o_LE1);
					}
					spb_dir_fault = 1;
				}
			}
			else
				tmr_enc_dir = 0; 
		}
		else
			tmr_enc_dir = 0; 
  #endif

	}

#endif

	if (start_ck == 0)
	{

#if(((Traction == 1) || (Tract_OL == 1)))
		// Fault checks
	   
		if (cons[ansi] >= 2000)
		{
			if ( (((rdinp(i_GBP) == 0) && (rdinp(i_LBP) == 0)) || (rdinp(i_INS) == 0)) && 
							(rdinp(i_ACC) == 0) )
			{
				if ((door_locks() == 0) && (car_gate() == 0) && (rdinp(i_LC) == 1) && (rdinp(i_GTS) == 1))
				{			// Both car gate and hoistway doors are open
					if (rdinp(i_DZ) == 1)	
						gripper_trip_enable = 1;
				}
				else
					gripper_trip_enable = 0;
			}
			else
				gripper_trip_enable = 0;
			
			
			//**********************************************************	
			// Detect Unintended motion with doors closed
			//**********************************************************	


			if (((rdoutp(o_UP) == 1) || (rdoutp(o_DNR) == 1)) || ((procf >= 3) && (procf <=11)))
			{				 // CPU running the car
				intended_motion = 1;
				intended_motion_spb = 1;
				timers[tintmot] = 0;

#if (Traction == 1)
				st_enc_vel = enc_vel_fpm;
				em_stop_time = (int16)(((Dmd_Velocity/Em_Decel) + 3.0) * 10.0);
#else
				em_stop_time = 50;
#endif
				st_spb_vel = SPB_can.velocity;
			}

			else 
			{
			
				
#if (Traction == 1)
				enc_diff = enc_vel_fpm - st_enc_vel;
				
				if ((enc_diff > 0) && (timers[tintmot] < 3))
				{
					st_enc_vel = enc_vel_fpm;
					enc_diff = 0;
				}
				
				if (((enc_diff > 0) && (timers[tintmot] > 4)) || (timers[tintmot] > em_stop_time) || (enc_vel_fpm < 3)) // 700 msec to start to slow down
				{
					st_enc_vel = 0;
					intended_motion = 0;
				}
#endif
				spb_diff = SPB_can.velocity - st_spb_vel;
				
				if ((spb_diff > 0) && (timers[tintmot] < 4))
				{
					st_spb_vel = SPB_can.velocity;
					spb_diff = 0;
				}
				
				if (((spb_diff > 0) && (timers[tintmot] > 5)) || (timers[tintmot] > em_stop_time) || (SPB_can.velocity < 3)) // 700 msec to start to slow down
				{
					st_spb_vel = 0;
					intended_motion_spb = 0;
				}


			}

			// Check unintended motion velocity from SPB or ENC
			if ((door_locks() == 0) && (car_gate() == 0) && (rdinp(i_LC) == 1) && (rdinp(i_GTS) == 1))
				doors_open = 1;
			else
				doors_open = 0;

#if (Traction == 1)
		
			if ( ( (((SPB_can.velocity > 50) || ((SPB_can.velocity > 5) && (doors_open == 1))) && ((fvars[fvspbgrip] & 0x01) != 0)  && (intended_motion_spb == 0)) || 
				   (((enc_vel_fpm > 50) || ((enc_vel_fpm > 5) && (doors_open == 1))) && ((fvars[fvspbgrip] & 0x04) != 0) && (intended_motion == 0)) ) &&	   
#else																														   
			if ( ((SPB_can.velocity > 50) || ((SPB_can.velocity > 5) && (doors_open == 1))) && ((fvars[fvspbgrip] & 0x01) != 0) && (intended_motion_spb == 0)) && 
 //				(rdoutp(o_RUN) == 0) && (rdoutp(o_MCC) == 0) &&
#endif
					(rdoutp(o_UP) == 0) && (rdoutp(o_DNR) == 0) && (rdinp(i_LC) == 1) &&		// not in motion routine
					(rdinp(i_DZ) == 0) && (rdinp(i_DZA) == 0) )
			{
				if(gripper_spd_trip_timer > 2)
				{

					if (gripper_fault == 0)
					{
						record_fault(f_umotion_flt);
						fault_prog_flag1 = 3;
						if (cons[EM_BRK] != 0)
							record_fault(f_EMBK_trip);
						else
							record_fault(f_grip_trip);
						gripper_fault = 1;
						SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
						gripper_test = 20;		// don't run the gripper test accidentally
						clroutp(o_GR1R);
						clroutp(o_GR2R);
						clroutp(o_LE);
						clroutp(o_LE1);
					}
				}
			}
			else
				gripper_spd_trip_timer = 0;

			if ((SPB_can.service == s_UMOTION_err) && ((SPB_can.command & spbc_reset_umotion) == 0))
			{
				if (gripper_fault == 0)
				{
					record_fault(f_spb_umotion);
					gripper_fault = 1;
					gripper_test = 20;		// don't run the gripper test accidentally
					clroutp(o_GR1R);
					clroutp(o_GR2R);
					clroutp(o_LE);
					clroutp(o_LE1);
				}
			}
			
			// Ascending Overspeed check from governor

			if ((rdinp(i_GOV) == 0) && (rdinp(i_LC) == 1)) 
			{
				if (gov_flt_timer > 3)
				{
#if (Traction == 1)
					if ((gripper_fault == 0) && ((enc_vel_fpm > 150) || (enc_vel_fpm >= cons[speed]) || 
											(SPB_can.velocity > 150) || (SPB_can.velocity >= cons[speed]) ||
											(fvars[fvgovgrip] == 0)))
#else
					if ((gripper_fault == 0) && ((SPB_can.velocity > 150) || (SPB_can.velocity >= cons[speed]) || (fvars[fvgovgrip] == 0)))
#endif
					{
						fault_prog_flag1 = 4;
						if (cons[EM_BRK] != 0)
							record_fault(f_EMBK_trip);
						else
							record_fault(f_grip_trip);
						gripper_fault = 1;
						SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
						gripper_test = 20;		// don't run the gripper test accidentally
					}
					clroutp(o_GR1R);
					clroutp(o_GR2R);
					clroutp(o_LE);
					clroutp(o_LE1);
				}
			}
			else
				gov_flt_timer = 0;
			
			// Unintended motion with doors open and leaving the door zone

			if (chk_ins() == 1)
			{		// on Inspection
				if ( (((rdinp(i_GBP) == 0) && (rdinp(i_LBP) == 0)) || (rdinp(i_INS) == 0)) && 
							(rdinp(i_ACC) == 0) )
				{
					if ((door_locks() == 0) && (car_gate() == 0) && (rdinp(i_LC) == 1) && (rdinp(i_GTS) == 1))
					{			// Both car gate and hoistway doors are open
						if ((gripper_trip_enable == 1) && ((rdinp(i_DZ) == 0) && ((cons[Car_Sw] == 0) || ((rdinp(i_UL) == 0) && (rdinp(i_DL) == 0))) ))
						{		// Not on a door zone
							if ((gripper_fault == 0) && (gripper_flt_timer > 3))
							{
								record_fault(f_umotion_flt);
								fault_prog_flag1 = 5;
								if (cons[EM_BRK] != 0)
									record_fault(f_EMBK_trip);
								else
									record_fault(f_grip_trip);
								gripper_fault = 1;
								SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
								gripper_test = 20;		// don't run the gripper test accidentally
								clroutp(o_GR1R);
								clroutp(o_GR2R);
								clroutp(o_LE);
								clroutp(o_LE1);
							}
						}
						else gripper_flt_timer = 0;
					}
					else gripper_flt_timer = 0;
				}
				else gripper_flt_timer = 0;
			}
			else // if (procf != 1)		 Allow gripper trip in reset mode 
			{	 // on auto
				if ((door_locks() == 0) && (car_gate() == 0) && (rdinp(i_LC) == 1) && (rdinp(i_GTS) == 1))
				{			// Both car gate and hoistway doors are open
					if ((gripper_trip_enable == 1) && ((rdinp(i_DZ) == 0) && ((cons[Car_Sw] == 0) || ((rdinp(i_UL) == 0) && (rdinp(i_DL) == 0))) ))
					{		// Not on a door zone
						if ((gripper_fault == 0) && (gripper_flt_timer > 3))
						{
							record_fault(f_umotion_flt);
							fault_prog_flag1 = 6;
							if (cons[EM_BRK] != 0)
								record_fault(f_EMBK_trip);
							else
								record_fault(f_grip_trip);
							gripper_fault = 1;
							SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
							gripper_test = 20;		// don't run the gripper test accidentally
							clroutp(o_GR1R);
							clroutp(o_GR2R);
							clroutp(o_LE);
							clroutp(o_LE1);
						}
					}
					else gripper_flt_timer = 0;
				}
				else gripper_flt_timer = 0;
			}
	//		else gripper_flt_timer = 0;
		}
		else
			gripper_fault = 0;

		if (gripper_fault == 1)
			statusf |= sf_GRIP;
		else
			statusf &= ~sf_GRIP;

		if (leveling_fault != 0)
			statusf |= sf_LEV;
		else 
			statusf &= ~sf_LEV;

		if (BKS_Run_Fault == 1)
			statusf2 |= sf_BKSR;
		else
			statusf2 &= ~sf_BKSR;

#else

		if ((Drive_Type[cons[carnmb]] == 1) || ((Drive_Type[cons[carnmb]] == 9) && (cons[SFC_2004_IO] == 0)))
		{
				setoutp(o_GR1R);
				setoutp(o_GR2R);
		}
		else if ((Drive_Type[cons[carnmb]] == 9) && (in_pfc_sfc_test == 0))
		{	  // Use the grippe relays to power the soft-starter
			if ((hy_rdy_test == 1) && (hy_reset_cnt < fvars[fvdrvrst]) && 
				(rdoutp(o_RUN) == 0) && (rdinp(i_DEL) == 0) && (rdinp(i_MCA) == 0))
			{	// test mode and not running
				if ((rdinp(i_P) == 1) || (hy_ep_rdy_test == 1))
				{
					if ((rdinp(i_P) == 1) && (hy_ep_rdy_test == 0))
						statusf |= sf_P;		// potential error
					if (timers[thyreset] < 50)
					{
						clroutp(o_GR1R);
						clroutp(o_GR2R);
					}
					else
					{
						setoutp(o_GR1R);
						setoutp(o_GR2R);
					}

					if (timers[thyreset] > 60)
						hy_ep_rdy_test = 0;

					if (timers[thyreset] > 300)
					{
						timers[thyreset] = 0;
						hy_reset_cnt++;
					}
				}
				else
				{
					hy_rdy_test = 0;
					timers[thyreset] = 0;
				}
			}
			else
			{
				if (rdinp(i_P) == 1)
				{
					statusf |= sf_P;		// potential error
					if (timers[thyreset] > 30)
					{
						hy_rdy_test = 1;
						timers[thyreset] = 0;
					}
				}
				else
				{
					timers[thyreset] = 0;
					statusf &= ~sf_P;		// clear potential error
				}
				setoutp(o_GR1R);
				setoutp(o_GR2R);
			}
		}
#endif
	}
}

//******************************************
// Security control set from Inctime
//******************************************
void security_control (int16 start_ck)
{
	int16 i;
  	int16 fl;
  	int16 fl_ix;

	if (start_ck == 0)
	{
		if (cons[cc_pb_sec] == 1)
		{
			for (i = 0; i <= 3; i++)
			{
				if (Clear_All_Codes_All_Floors(0,i, cpu_Z6) != 0)		// Delete codes in multiple calls
					break;
				if (Add_One_Code_All_Floors(0,i,zero_Code, cpu_Z6) != 0)  // add codes in multiple calls
					break; 
				if (Delete_One_Code_All_Floors(0,i,zero_Code, cpu_Z6) != 0)	  // delete codes in multiple calls
					break;
			}
		}
	  	if ((cons[SecFlCfg] == 1) || (cons[SecFlCfg] == 5))
	  	{
			if (((rdinp(i_SECFM) == 1) || (tmr_svc[s_alt_fl_sec] == 1) || 
				(((cons[ids] & 1) != 0) && (ids_alt_fl_sec == 1)) ||
				(((cons[Galileo] & 1) != 0) && (ui_alt_fl_sec == 1))) && 
					(firef == 0) && (medf == 0) && (empf == 0))
			{
				if (Sec_Fl_Mask == 0)
				{
					Sec_Fl_Mask = 1;
				    for(i=1; i<car_size; i++)
				    {
						ccmsk[i] = &ccsmsk[i][0];
						ucmsk[i] = &ucsmsk[i][0];
						dcmsk[i] = &dcsmsk[i][0];
						rccmsk[i] = &rccsmsk[i][0];
						rucmsk[i] = &rucsmsk[i][0];
						rdcmsk[i] = &rdcsmsk[i][0];
						if (cons[LbyUpReq] != 0)
						{
							if ((lby_up_req_car[i] & 0x04) != 0)
								lby_up_req_car[i] |= 0x02;		  // set flag to disable standard up hall call
						}	
					}
				 	clrcc(1);		// cancel the call with the invalid mask
				}
			}
			else
			{
				if (Sec_Fl_Mask != 0)
				{
					Sec_Fl_Mask = 0;
				    for(i=1; i<car_size; i++)
				    {
						ccmsk[i] = &ccnmsk[i][0];
						ucmsk[i] = &ucnmsk[i][0];
						dcmsk[i] = &dcnmsk[i][0];
						rccmsk[i] = &rccnmsk[i][0];
						rucmsk[i] = &rucnmsk[i][0];
						rdcmsk[i] = &rdcnmsk[i][0];
						if ((cons[LbyUpReq] & 0x04) != 0)
							lby_up_req_car[i] &= ~0x02;			// clear disable bit
					}
				 	clrcc(1);	// cancel the call with the invalid mask
				}
			}
		}
	  	else if (cons[SecFlCfg] == 2)
		{
			if ((sec_fl_ctrl[cons[carnmb]] == 0) || (firef != 0) || (medf != 0) || (empf != 0))
			{
				if (Sec_Fl_Mask != 0)
				{
					Sec_Fl_Mask = 0;
					ccmsk[cons[carnmb]] = &ccnmsk[cons[carnmb]][0];
					ucmsk[cons[carnmb]] = &ucnmsk[cons[carnmb]][0];
					dcmsk[cons[carnmb]] = &dcnmsk[cons[carnmb]][0];
					rccmsk[cons[carnmb]] = &rccnmsk[cons[carnmb]][0];
					rucmsk[cons[carnmb]] = &rucnmsk[cons[carnmb]][0];
					rdcmsk[cons[carnmb]] = &rdcnmsk[cons[carnmb]][0];
				 	clrcc(1);		// cancel the call with the invalid mask
				}
			}
			else if (sec_fl_ctrl[cons[carnmb]] == 1)
			{
				if (Sec_Fl_Mask != 1)
				{
					Sec_Fl_Mask = 1;
					ccmsk[cons[carnmb]] = &ccsmsk[cons[carnmb]][0];
					ucmsk[cons[carnmb]] = &ucsmsk[cons[carnmb]][0];
					dcmsk[cons[carnmb]] = &dcsmsk[cons[carnmb]][0];
					rccmsk[cons[carnmb]] = &rccsmsk[cons[carnmb]][0];
					rucmsk[cons[carnmb]] = &rucsmsk[cons[carnmb]][0];
					rdcmsk[cons[carnmb]] = &rdcsmsk[cons[carnmb]][0];
				 	clrcc(1);		// cancel the call with the invalid mask
				}
			}
			else if ((sec_fl_ctrl[cons[carnmb]] == 2) && (cons[SecFlCfg_2] != 0))
			{
				if (Sec_Fl_Mask != 2)
				{
					Sec_Fl_Mask = 2;
					ccmsk[cons[carnmb]] = &ccs2msk[cons[carnmb]][0];
					ucmsk[cons[carnmb]] = &ucs2msk[cons[carnmb]][0]; 
					dcmsk[cons[carnmb]] = &dcs2msk[cons[carnmb]][0];
					rccmsk[cons[carnmb]] = &rccs2msk[cons[carnmb]][0];
					rucmsk[cons[carnmb]] = &rucs2msk[cons[carnmb]][0]; 
					rdcmsk[cons[carnmb]] = &rdcs2msk[cons[carnmb]][0];
				 	clrcc(1);		// cancel the call with the invalid mask
				}
			}
			else if ((sec_fl_ctrl[cons[carnmb]] == 3) && (cons[SecFlCfg_3] != 0))
			{
				if (Sec_Fl_Mask != 3)
				{
					Sec_Fl_Mask = 3;
					ccmsk[cons[carnmb]] = &ccs3msk[cons[carnmb]][0];
					ucmsk[cons[carnmb]] = &ucs3msk[cons[carnmb]][0];
					dcmsk[cons[carnmb]] = &dcs3msk[cons[carnmb]][0];
					rccmsk[cons[carnmb]] = &rccs3msk[cons[carnmb]][0];
				 	rucmsk[cons[carnmb]] = &rucs3msk[cons[carnmb]][0];
				 	rdcmsk[cons[carnmb]] = &rdcs3msk[cons[carnmb]][0];
				 	clrcc(1);		// cancel the call with the invalid mask
				}
			}
			else if ((sec_fl_ctrl[cons[carnmb]] == 4) && (cons[SecFlCfg_4] != 0))
			{
				if (Sec_Fl_Mask != 4)
				{
					Sec_Fl_Mask = 4;
					ccmsk[cons[carnmb]] = &ccs4msk[cons[carnmb]][0];
					ucmsk[cons[carnmb]] = &ucs4msk[cons[carnmb]][0];
					dcmsk[cons[carnmb]] = &dcs4msk[cons[carnmb]][0];
					rccmsk[cons[carnmb]] = &rccs4msk[cons[carnmb]][0];
					rucmsk[cons[carnmb]] = &rucs4msk[cons[carnmb]][0];
					rdcmsk[cons[carnmb]] = &rdcs4msk[cons[carnmb]][0];
				 	clrcc(1);		// cancel the call with the invalid mask
 				}
			}
		}
				
	

		if (cons[Second_Riser] != 0)
		{
	 		if (((sr_cc_ctrl[cons[carnmb]] & 0x01) != 0) && (firef == 0) && (medf == 0) && (empf == 0))
			{
				if (sr_cc_mask == 0)
				{
					sr_cc_mask = 1;
				    for(i=1; i<car_size; i++)
				    {
						if (Valid_SR_Car[i] != 0)
						{
							ccmsk[i] = &irccmsk[i][0];
							rccmsk[i] = &rirccmsk[i][0];
						}
					}
				 	clrcc(1);	// cancel the call with the invalid mask
				}
			}
			else
			{
				if (sr_cc_mask == 1)
				{
					sr_cc_mask = 0;
					if (((cons[SecFlCfg] == 1) || (cons[SecFlCfg] == 5)) && (Sec_Fl_Mask == 1) && (firef == 0) && (medf == 0) && (empf == 0))
					{		   // car still on security so use security mask
					    for(i=1; i<car_size; i++)
					    {
							if (Valid_SR_Car[i] != 0)
							{
								Sec_Fl_Mask = 0;
								ccmsk[i] = &ccsmsk[i][0];
								rccmsk[i] = &rccsmsk[i][0];
							}
	 					}
					}
					else
					{	  // otherwise on normal service so use normal mask
					    for(i=1; i<car_size; i++)
					    {
							if (Valid_SR_Car[i] != 0)
							{
								Sec_Fl_Mask = 0;
								ccmsk[i] = &ccnmsk[i][0];
								rccmsk[i] = &rccnmsk[i][0];
							}
						}
					}
				 	clrcc(1);	// cancel the call with the invalid mask
				}
			}
		}

		if (Grp_CC_Override == 1)
		{
			if ((fvars[fvsecfl] >= cons[bottomf]) && (fvars[fvsecfl] <= cons[topf]))
				fl = fvars[fvsecfl];
			else
				fl = fvars[fvlob];					
			for (i=cons[bottomf];i<=cons[topf];i++)
			{
				fl_ix = (i-1)/32;
				if (((gc_cc_sec_ovr_panic[fl_ix] & fl_mask[i]) != 0) && (carcb[i] == 1) && ((position != i) || (position != fl) || (procf <14) || (procf > 16)))
				{
					if (sec_panic_recall == 0)
					{
						sec_recall_complete = 0;
						sec_panic_recall = 1;	
					}
				}
				if (((gc_rcc_sec_ovr_panic[fl_ix] & fl_mask[i]) != 0) && (rcarcb[i] == 0) && ((position != i) || (position != fl) || (procf <14) || (procf > 16)))
				{
					if (sec_panic_recall == 0)
					{
						sec_recall_complete = 1;
						sec_panic_recall = 1;
					}
				}
			}
		}

			// Independent Security Recall
		if (cons[IndSec] == 1)
		{
			if (rdinp(i_INDS) == 0)
				ind_sec_recall = 0;
			else if (ind_sec_recall == 0)
			{
				ind_sec_recall = 1;
				sec_recall_complete = 0;
			}
		}
		else 
			ind_sec_recall = 0;

		if ((((Security_Type[cons[carnmb]] != 0) || (cons[Remote_CC] != 0)) && ((fvars[fvsecrec] & 0x01) != 0) || (Grp_CC_Override == 1)) ||
			((cons[IndSec] == 1) && (rdinp(i_INDS) == 1)))
		{
			if ((firef == 0) && (rfiref == 0) && (medf == 0) &&	(empf == 0) &&
				((gc_sec == 1) || (rdinp(i_CCS(0)) == 1) || ((rdinp(i_SECFM) == 1) && ((cons[SecFlCfg] == 1) || (cons[SecFlCfg] == 5))) ||
				  ((cons[IndSec] == 1) && (rdinp(i_INDS) == 1)) ||
				  (remote_cc == 1) || (remote_rcc == 1) || (sec_panic_recall == 1)))
			{
				if (sec_recall_complete == 0)
				{
					if (sec_recall == 0)
					{
						if ((cons[carnmb] == Dispatcher) && (((fvars[fvsecrec2] & 0x03) == 0) || ((fvars[fvsecrec2] & 0x01) != 0)))
							grp_clrhc();
					 	clrcc(0);
						if ((fvars[fvsecfl] >= cons[bottomf]) && (fvars[fvsecfl] <= cons[topf]))
							fl = fvars[fvsecfl];
						else
							fl = fvars[fvlob];					
						if ((fvars[fvsecrec] & 0x02) != 0)
							set_carcall(cons[carnmb],fl);	  // OPEN DOOR AT FLOOR
						if ((fvars[fvsecrec] & 0x04) != 0)
							set_rcarcall(cons[carnmb],fl);	  // OPEN DOOR AT FLOOR
					}
					sec_recall = 1;
				}
				if ((servf == 1) || (servf == 24) || ((cons[IndSec] == 1) && (rdinp(i_INDS) == 1) && (servf == 2))) 
				{
					if ((fvars[fvsecfl] >= cons[bottomf]) && (fvars[fvsecfl] <= cons[topf]))
						fl = fvars[fvsecfl];
					else
						fl = fvars[fvlob];					
					if (sec_recall == 1)
					{
						if (position != fl) 
						{
							zone_fl = fl;
							if (((sec_recall_complete == 0) && ((fvars[fvsecrec2] & 0x03) == 0)) || ((fvars[fvsecrec2] & 0x01) != 0))
								servf = 24;
						}
						else if ((procf >= 14) && (procf <= 16))
						{	
							servf = 1;
							sec_recall = 0;
							sec_recall_complete = 1;
							sec_panic_recall = 0;
							zone_fl = 0;
						}
					}
					else if ((fvars[fvsecrec] & 0x08) != 0)
					{
						if (position > fl)
							recall_dir = 2;
						else if (position < fl)
							recall_dir = 1;
						if ((position != fl) && (procf >= 14) && (procf <= 16) && ((dpref == 0) || dirf == recall_dir))
						{
							sec_recall = 1;
							if ((fvars[fvsecrec] & 0x02) != 0)
								set_carcall(cons[carnmb],fl);	  // OPEN DOOR AT FLOOR
							if ((fvars[fvsecrec] & 0x04) != 0)
								set_rcarcall(cons[carnmb],fl);	  // OPEN DOOR AT FLOOR
						}
					}
				}
			}
			else
			{
				if (((sec_recall_complete == 1) || (sec_recall == 1)) && (servf == 24))
					servf = 1;
				sec_recall = 0;
				sec_recall_complete = 0;
			}
		}
		else
		{ 
			sec_recall = 0;
			sec_recall_complete = 0;
		}

		if (cons[Remote_CC] != 0)
		{
			if ((rdinp(i_SCS) == 1) && (firef == 0))
				remote_cc = 1;
			else if ((tugf == 1)&&(rdinp(i_THDS) == 1) && (firef == 0))
				remote_cc = 1;
			else
				remote_cc = 0;

			if ((cons[rear] == 1) && (rdinp(i_SCSR) == 1) && (rfiref == 0))
				remote_rcc = 1;
			else if ((tugf == 1)&&(rdinp(i_THDS) == 1) && (firef == 0))
				remote_rcc = 1;
			else
				remote_rcc = 0;
		}
		else
		{
			remote_cc = 0;
			remote_rcc = 0;
		}
		
		if (((Security_Type[cons[carnmb]] & 0x40) == 0) &&(Security_Type[cons[carnmb]] & 0x01) != 0)	
		{
		    if((rdinp(i_DOL) == 0) || ((cons[rear] !=0) && (rdinp(i_DOLR) == 0)))
			{
				if (((fvars[fvopenlctl] & 0x10) != 0))
				{
					setoutp(o_OPENL);
				}
				else
				{
					if(((fvars[fvopenlctl] & 0x01) != 0) && (firef == 3))
					{
						setoutp(o_OPENL);
					}
 #if ((Traction == 1) || (Tract_OL == 1))
					if(((fvars[fvopenlctl] & 0x02) != 0) &&
							(((rdinp(i_RTL) == 1) && (cons[otslbp] != 0)) ||
							(((cons[ids] & 1) != 0) && (ids_rtl[cons[carnmb]] == 1)) ||
							(((cons[Galileo] & 1) != 0) && (ui_rtl[cons[carnmb]] == 1)) ||
							((rdinp(i_RTLDC) == 1) && ((cons[otslbp] & 0x04) != 0))))
#else
					if(((fvars[fvopenlctl] & 0x02) != 0) &&
							(((rdinp(i_RTLH) == 1) && (cons[otslbp] != 0)) || 
					  		(((cons[ids] & 1) != 0) && (ids_rtl[cons[carnmb]] == 1)) || 
					  		(((cons[Galileo] & 1) != 0) && (ui_rtl[cons[carnmb]] == 1)) || 
					  		((rdinp(i_RTLDC) == 1) && ((cons[otslbp] & 0x04) != 0))))
#endif
					{
						setoutp(o_OPENL);
					}
					if(((fvars[fvopenlctl] & 0x04) != 0) && ((empf == 4) || ((empf == 6) && (position == fvars[fvepfl]))))
					{
						setoutp(o_OPENL);
					}
					if(((fvars[fvopenlctl] & 0x08) != 0) && (position == lobby_fl))
					{
						setoutp(o_OPENL);
					}

				}
			}
			else
			{
				clroutp(o_OPENL);				
			}
		 
		}

		if((Security_Type[cons[carnmb]] & 0x40) == 0)
		{
			if (((Security_Type[cons[carnmb]] & 0x01) != 0) || ((Security_Type[cons[carnmb]] & 0x10) != 0))
			{
				if (fvars[fvinsec] == 0)
				{
					if ((rdinp(i_CCS(0)) == 1) || (rdinp(i_RCCS(0)) == 1))
						setoutp(o_INSEC);
					else
						clroutp(o_INSEC);		
				}
				else
				{
					if ((rdinp(i_CCS(0)) == 1) || (rdinp(i_RCCS(0)) == 1))
						clroutp(o_INSEC);		
					else
						setoutp(o_INSEC);
				}

			}
			else
			{
				clroutp(o_INSEC);
			}
		}
		
		if (((Security_Type[cons[carnmb]] & 0x01) != 0) || ((Security_Type[cons[carnmb]] & 0x10) != 0))
		{
			if (firef != 0)
				setoutp(o_FSOCS);
			else
				clroutp(o_FSOCS);
			if (cons[rear] != 0)
			{
				if (firef != 0)
					setoutp(o_FSORS);
				else
					clroutp(o_FSORS);
			}
		}

	}
}


//****************************************
// Encoder Control called from Inctime
//****************************************

void encoder_control (int16 start_ck)
{
		
#if(Traction == 1)
	
	if (cons[sel_type] == 3)
	{
		
		if (start_ck == 1)
		{
			enc_start_read_cnt++;
			if (enc_start_read_cnt >= 5)
			{						// slowdown encoder read during start
				if (cons[sel_type] == 3)
					Enc_Can_Control();
				
				enc_start_read_cnt = 0;
				Read_Encoder();
			}
		}
		else
		{
			if (cons[sel_type] == 3)
				Enc_Can_Control();
		
			enc_start_read_cnt = 5;		// set count to read encoder the first time through
			Read_Encoder();
		}

	}
	else
	{
		can_enc_com_err = 0;
		can_enc_init = 0;
		Read_Encoder();
	}
#endif

}
// ******************************************
// This is the increment timers procedure
//*******************************************
void inctime(int16 start_ck)
{
  	int16 i;


	if ((fvars[fvcputiming] & 0x0001) != 0)
		SIU.GPDO[Z6_LED].R = 0x01;


	// *******************************
	// Increment Timer Section
	// *******************************

  	while(timers[tinc] >= 10)
  	{
  	  	timers[tten]++;
  	  	timers[tbuf]++;
  	  	timers[tinc] = (timers[tinc] - 10);
		timers[tcom_que] = (timers[tcom_que] + 1) & 0x7FFF;
#if (Simulator == 1)
		sim_door_timer++;
#endif
  	}
  	if(timers[tbuf] >= 10)
  	{
  	  	timers[tbuf] = (timers[tbuf] - 10);
  	  	timers[tsec]++;
		rt_second ++;
		if (rt_second > 59)
		{
			rt_second = 0;
			rt_minute++;
			if (rt_minute > 59)
			{
				rt_minute = 0;
				rt_hour++;
				if (rt_hour > 23)
				{
					rt_hour = 0;
					if (rt_day > 364)
						rt_day = 0;
				}
			}
		}
				
  	  	petdog();                   // petting the watchdog Pg#2-9
  	  	for(i=cons[bottomf]; i<=cons[topf]; i++)
    	{
      		cctim[i]++;
      		if(cctim[i] > 32000)
				cctim[i] = 32000;
      		if(cons[rear] != 0)
      		{
				ccrtim[i]++;
				if(ccrtim[i] > 32000)
				ccrtim[i] = 32000;
      		}
    	}
    	for(i=cons[bottomf]; i<cons[topf]; i++)
    	{
    	  	uctim[i]++;
    	  	if(uctim[i] > 32000)
				uctim[i] = 32000;
    	  	if(grtop_rfl != 0)
    	  	{
				ucrtim[i]++;
				if(ucrtim[i] > 32000)
				ucrtim[i] = 32000;
    	  	}
    	}
    	for(i=(cons[bottomf]+1); i<=cons[topf]; i++)
    	{
    	  	dctim[i]++;
    	  	if(dctim[i] > 32000)
				dctim[i] = 32000;
    	  	if(grtop_rfl != 0)
    	  	{
				dcrtim[i]++;
				if(dcrtim[i] > 32000)
					dcrtim[i] = 32000;
    	  	}
    	}

    	if(timers[tsec] == 1)       // turn on diag light 
    	{
			diag_led_on();
    	}
    	if(timers[tsec] >= 2)       // turn off diag light 
    	{
			diag_led_off();
    	  	timers[tsec] = 0;
    	}
  	}
  	if(timers[tten] >= 1)
  	{
  	  	for(i=9; i<tnmb; i++)       // incrementing all 1/10th of second timers
  	  	{
  	  	  	if((timers[i] + timers[tten]) < 32000)
				timers[i] = (timers[i] + timers[tten]);
  	  	}
  	  	timers[tten] = 0;
  	}

	inctime_count++;
	
	//***********************
	// End of timer section
	//***********************
	
	encoder_control(start_ck);
	
	chk_motion_fault(start_ck);

	status_control(start_ck);

	em_brake_control(start_ck);
	
#if (debug_io_enable == 1)

	#if(Traction == 1)
	
		if((Velocity == 0) && (rqst_dbgtoFC == 1))
		{
			rqst_dbgtoFC = writedbgtoFC(debug_io_1); 
		}
	#endif
#endif

	if (start_ck == 0)
	{

		loop_cnt++;
		if (loop_cnt > 100)			// interrupt is not running
			re_init_can = 1;

	}

	door_control(start_ck);

	diag();

	comm_control();
	
	if (start_ck == 0)
	{
		group_ETA();

	//	if(cons[home] != 0)
	//	  group_park();

		if((nmbstops != 0) && (procf <= 11))          // in motion
		  Group_IO_Com[cons[carnmb]][g_nxt_stp] = stops[0];
		else
		  Group_IO_Com[cons[carnmb]][g_nxt_stp] = 0;

		if((g_park[cons[carnmb]] != 0) && (procf <= 11))
		  Group_IO_Com[cons[carnmb]][g_nxt_stp] = g_park[cons[carnmb]];

		// Test for slowdown condition for this car 
		if ((hsf == 0) && (procf >= 3) && (procf <= 11))
		  	Group_IO_Com[cons[carnmb]][g_nxt_stp] = position;
	}

	if (start_ck == 0)
	{
  		set_grp_io();
//		group_control();
		
		hydro_control();
		

	}

	security_control(start_ck);

	light_buzzer_control(start_ck);

	output_control(start_ck);

#if (Simulator == 1)
  	sim_control();
#endif

	if ((fvars[fvcputiming] & 0x0001) != 0)
		SIU.GPDO[Z6_LED].R = 0x00;

  return;
}

//**********************************************************
//** Independent service from MR or COP ********************
//**********************************************************

int16 ind (void)
{
	if((cb_over_ind == 1)&&(timers[tcbovrind] > fvars[fvfs1dto]))
		return 0;
	if((heof_over_ind == 1)&&(timers[theofovrind] > 100))
		return 0;
	if((cons[hugs] == 3) && (rdinp(i_HUGB) == 0) && (rdinp(i_HUGI) == 1))
		return 0;
	if (rdinp(i_IND) == 1)
		return 1;
	if ((rdinp(i_INDC) == 1) && ((cons[sercom] & 2) != 0))
		return 1;
	if ((remote_cc == 1) && (cons[Remote_CC] == 1) && (rdinp(i_RM_INDC) == 1))
		return 1;
	if (((cons[ids] & 1) != 0) && (ids_ind[cons[carnmb]] == 1) && (firef == 0) && (rfiref == 0))
		return 1;
	if (((cons[Galileo] & 1) != 0) && (ui_ind[cons[carnmb]] == 1) && (firef == 0) && (rfiref == 0))
		return 1;
	if ((cons[IndSec] == 1) && (rdinp(i_INDS) == 1) && (ind_sec_recall == 1) && (sec_recall_complete == 1))
		return 1;
	return 0;
}

// ********************************************************
// Interrupt for DZ
// ********************************************************

	// Set RTS line high or low here when pin defined *******
	// int pin active, RTS and DTR low (enable driver chip)
void int_DZ (void)
{
	
/*	if ((Drive_Type[cons[carnmb]] == 14) || (Drive_Type[cons[carnmb]] == 15))
	{
		if (((fvars[fvppupd] & 0x02) != 0) && (cons[dpp_upd] != 0))
  			outp(com[comnmb][c_int_enable], 0x08); //enable modem status interrupt
		else
			outp(com[comnmb][c_int_enable], 0x00);	// no interrupts enabled
	}
	else 
	{
		if (((fvars[fvppupd] & 0x02) != 0) && (cons[dpp_upd] != 0))
  			outp(com[comnmb][c_int_enable], 0x09); //enable recieve and modem status interupts 
		else
	  		outp(com[comnmb][c_int_enable], 0x01); //enable recieve interupt
	}
*/	
}


// *********************************************************
// This is the 1/100th of a second interupt timer procedure
// *********************************************************
void inttim(void)
{
	int16 i;

  	if (int_flag == 1)
  	{
		int_flag = 0;
  	}
  	else
  	{
		int_flag = 1;
  	}
  	timers[tinc]++;
  	timers[tvpat]++;
  	timers[tcom_response]++;
		
	if (timers[tpatdly] < 32000)
		timers[tpatdly]++;
	
  	timers[tiofault]++;

  	if (gripper_flt_timer < 32000)
  		gripper_flt_timer++;

  	if (gov_flt_timer < 32000)
  		gov_flt_timer++;

  	if (gripper_spd_trip_timer < 32000)
  		gripper_spd_trip_timer++;
  	
  	if (ovs_dbn_tim < 32000)
  		ovs_dbn_tim++;
  	
  	if (tmr_lim_dir < 32000)
		tmr_lim_dir++;		// Timer for limit direction fault

	if (tmr_vel_diff < 32000)
		tmr_vel_diff++;	// Timer for velocity difference fault

	if (tmr_spb_enc_dir < 32000)
		tmr_spb_enc_dir++; 	// Timer for SPB encoder direction fault

	if (tmr_enc_dir < 32000)
		tmr_enc_dir++; 	// Timer for controller encoder direction fault

	if (tmr_uldl_dir < 32000)
		tmr_uldl_dir++;		// Timer for limit direction fault

	if (tmr_spb_vel_diff < 32000)
		tmr_spb_vel_diff++; 	// Timer for SPB velocity difference fault

	drive_update_timer++;

  	can_sel_timer++;
	can_sync_timer++;

	if (enc_dir_timer < 32000)
		enc_dir_timer++;

	if (dz_dbn_timer < 32000)
		dz_dbn_timer ++;

#if (Simulator == 0)	// when using the simulator this timer is incremented by the sim_motion
  	enc_vel_timer++;
#else
  	sim_vel_timer++;
  #if (Sim_Motion == 0)
  	enc_vel_timer++;
  #endif
#endif

	dpyspi_timer++;
	
	if (loop_cnt > 10)
		loop_cnt = 10;

	if (loop_cnt_ptr >= 9)
		loop_cnt_ptr = 0;
	else
		loop_cnt_ptr++;

	loop_cnt_array[loop_cnt_ptr] = loop_cnt;
	loop_cnt = 0;

	for(i=0;i<=9;i++)
		avg_loop_cnt += loop_cnt_array[i];
	avg_loop_cnt = avg_loop_cnt/10;

    PIT.TFLG1.R = 0x00000001;    
}

// *****************************************************
//	Zero important timers
// *****************************************************
void inittim()
{
  	// Zero critical i/o timers

  	timers[tdl] = 0;
  	timers[tul] = 0;
  	timers[tdlm] = 0;
  	timers[tdlb] = 0;
  	timers[tdlt] = 0;
  	timers[tgs] = 0;
	timers[tlct] = 0;
	timers[tsst] = 0;
	timers[tinst] = 0;
	timers[thct] = 0;
	timers[tdmo] = 0;
	timers[tpst] = 0;
	timers[teprcldly] = 0;		// emergency power recall delay.
	timers[tebrkio] = 0;
	timers[tebkdrop] = 0;
	timers[tcol] = 0;
  	timers[tinc] = 0;
  	timers[tten] = 0;
  	timers[tbuf] = 0;

	timers[tEP_npd] = 0;
	timers[tEP_epd] = 0;
	timers[tEP_epo] = 0;
  return;
}

// ***************************************************
// Routine to set appropriate flags on an initial stop
// ***************************************************

void initial_stop (void)
{
	Overspeed_Test = 0;
	hold_brake_overspeed = 0;
	Buffer_Test = 0;
	if( (rset == 0) && (no_fault == 1) )
	{
		if(start_floor < position)
			flight_times[start_floor][position] = (timers[tmotion]/10);
		else
			flight_times[position][start_floor] = (timers[tmotion]/10);
		Update_Flight_Times(cpu_Z6);
	}
	Update_Control_Flags(cpu_Z6);
	timers[tcablnt] = 0;
 	timers[trcablnt] = 0;
	timers[tdo] = 0;
	timers[trdo] = 0;
	timers[tgen] = 0;
	timers[tebkdrop] = 0;
	timers[tsoftstp] = 0;
	timers[tnit] = 0;
    timers[tdwel] = 0;
	timers[tattbzini] = 0;
    timers[trdwel] = 0;
	timers[tnudge] = 0;
	timers[trnudge] = 0;
	timers[teeto] = 0;
	timers[treeto] = 0;
	timers[tfdo_adv_de] = 0;
	timers[trdo_adv_de] = 0;
	closetry = 0;
	rclosetry = 0;
	safe_closetry = 0;
	safe_rclosetry = 0;
	Door_Lock_Fault = 0;
	RCM_Lock_Fault = 0;
	lev_startf = 0;

	timers[tgripper] = 0;
	if( (firef > 3) || (rfiref > 3) || (medf == 3) || 
		((fvars[fvhsvdccc] == 1) && (hsvf == 1)) || ((fvars[fvinddccc] == 1) && (servf == 2)))
		clrcc(0);
}


//***********************************************
// Initialize Ram Data for car and group
//***********************************************

void init_ram_data(void)
{

int16 i;

	// zero group data from cars

	for (i=1;i<=cons[nmbcars];i++)
	{
		Group_IO_Com[i][g_procf] = 0;
		Group_IO_Com[i][g_servf] = 0;
		Group_IO_Com[i][g_empf] = 0;
		Group_IO_Com[i][g_firef] = 0;
		Group_IO_Com[i][g_doorf] = 0;
		Group_IO_Com[i][g_rdoorf] = 0;
		Group_IO_Com[i][g_dirf] = 0;
		Group_IO_Com[i][g_dpref] = 0;
		Group_IO_Com[i][g_codebf] = 0;
		Group_IO_Com[i][g_dcalls] = 0;
		Group_IO_Com[i][g_cancel_upr] = 0;
		Group_IO_Com[i][g_cancel_dnr] = 0;
		Group_IO_Com[i][g_cur_flt] = 0;
		Group_IO_Com[i][g_statusf1_l] = 0;
		Group_IO_Com[i][g_statusf1_h] = 0;
		Group_IO_Com[i][g_control] = 0;
		Group_IO_Com[i][g_ss_stat] = 0;
		Group_IO_Com[i][g_cancel_irup] = 0;
		Group_IO_Com[i][g_cancel_irdn] = 0;
		Group_IO_Com[i][g_cancel_rirup] = 0;
		Group_IO_Com[i][g_cancel_rirdn] = 0;
		Group_IO_Com[i][g_vipf] = 0;
		Group_IO_Com[i][g_nmbcc] = 0;
		Group_IO_Com[i][g_topcc] = 0;
		Group_IO_Com[i][g_botcc] = 0;
		Group_IO_Com[i][g_fire_status] = 0;
		Group_IO_Com[i][g_ins_status] = 0;
		g_dmd_vel[i] = 0;			// group demand velocity in fpm for each car
		g_enc_vel[i] = 0;			// group encoder velocity in fpm for each car
		g_enc_dir[i] = 0;			// group encoder direction for each car
		g_flr_cnt[i] = 0;			// floor reference count for each car
		g_pls_cnt[i] = 0;			// car encoder pulse count for each car
		g_L1_Voltage[i] = 0;
		g_L2_Voltage[i] = 0;
		g_L3_Voltage[i] = 0;
		g_Door_Voltage[i] = 0;
		g_Voltage_Dev_Online[i] = 0;
	}

  	// Zero critical i/o timers

  	timers[tdl] = 0;
  	timers[tul] = 0;
  	timers[tdlm] = 0;
  	timers[tdlb] = 0;
  	timers[tdlt] = 0;
  	timers[tgs] = 0;
	timers[tlct] = 0;
	timers[tsst] = 0;
	timers[tinst] = 0;
	timers[thct] = 0;
	timers[tdmo] = 0;
	timers[tpst] = 0;
	timers[teprcldly] = 0;		// emergency power recall delay.
	timers[tebrkio] = 0;
	timers[tebkdrop] = 0;
	timers[tcol] = 0;
}

//******************************************
// Elevator is turned off by keyed a switch
//******************************************
void key_ots()
{
  return;
}

//*********************************
// Elevator stalled out of service
//*********************************
void stall()
{
	while(procf == 17)
	{
		servf = 14;
		inctime(0);
		setfsf();
		clrall();
	    if(chk_ins() == 1)
		{
#if ((Traction == 0) && (Tract_OL == 0))
			if (cons[ansi] < 2007)
			{
				if ((cons[Low_Oil] == 0) || 
					(((rdinp(i_LOS) == 0) && (fvars[fvlos] == 0)) || 
						((rdinp(i_LOS) == 1) && (fvars[fvlos] == 1))))
				{
					stallf = 0;
					procf = 2;
				}
			}
#else
			stallf = 0;
			procf = 2;
#endif
		}
		if (ccnmsk[cons[carnmb]][position] != 0)
		{
			if ((rdinp(i_DOB) == 1) || 
				((cons[RGB_CC] == 1) && (rdinp(i_FiDOB) == 1)) || 
				((manual_door == 2) && (man_fdcc() == 0)))
			{
				procf = 15;
				stallf = 1;
			}
		}
		if ((cons[rear] != 0) && (rccnmsk[cons[carnmb]][position] != 0))
		{
			if ((rdinp(i_DOBR) == 1) || 
				((cons[RGB_CC] == 1) && (rdinp(i_FiDOBR) == 1)) || 
				((manual_rdoor == 2) && (man_rdcc() == 0)))
			{
				procf = 15;
				stallf = 1;
			}
		}

#if(Traction == 1)
		// Make sure the motor field is not at full field
	    if(timers[tff] > 40)
			clroutp(o_FF);
//	    clroutp(o_FW);
#endif
  }
  return;
}
//*********************************
// Elevator has low pressure switch
//*********************************
#if ((Traction == 0) && (Tract_OL == 0))
void low_pressure(void)
{
	timers[tfault] = 0;
	record_fault(f_lowpress);
	clrall();
	doorf = 3;
	if (cons[rear] == 1)
		rdoorf = 3;
	dpref = 0;

  	while(procf == 19)
  	{
		servf = 21;
		inctime(0);
		// Testing to see if saftey string is open
    	if(safeties() == 1)
			timers[tsst] = 0;
    	else if(timers[tsst] > 10)
    	{
			if ((statusf & sf_SS) == 0)
				record_fault(f_sstring);
			statusf |= sf_SS;
      		procf = 12;       // go to saftey string open mode
      		return;
    	}
		else
			statusf &= ~sf_SS;

		// Testing to see if LC fuse is blown
    	if(rdinp(i_LC) == 1)
			timers[tlct] = 0;
    	if((rdinp(i_LC) == 0) && (timers[tlct] > 10))
    	{
			if ((statusf & sf_LC) == 0)
				record_fault(f_LC_fuse);
			statusf |= sf_LC;
			procf = 12;
			return;
    	}
		else
			statusf &= ~sf_LC;
  	    if (chk_ins() == 1)
		{			   // exit on inspection
			lps_stall = 0;
			procf = 2;
			return;
		}
		if (rdinp(i_DZ) == 1)
		{		// Allowed to open the door
				
			if ((rdinp(i_DOB) == 1) || ((cons[RGB_CC] == 1) && (rdinp(i_FiDOB) == 1)))
			{
				doort = fvars[fvccdt];
				doorf = 1;	// open door
		    	timers[tdo] = 0;
			}
			if (cons[rear] != 0)
			{
				if ((rdinp(i_DOBR) == 1) || ((cons[RGB_CC] == 1) && (rdinp(i_FiDOBR) == 1)))
				{
					rdoort = fvars[fvccdt];
					rdoorf = 1;	// open door
			    	timers[trdo] = 0;
				}
			}
			else
				rdoorf = 0;
		}
		else 
		{
			if (rdinp(i_DCL) == 0)
				doorf = 0;
			else
				doorf = 3;	// close door
			if (cons[rear] != 0)
			{
				if (rdinp(i_DCLR) == 0)
					rdoorf = 0;
				else
					rdoorf = 3;	// close door
			}
			else
				rdoorf = 0;
		}

	  	if(doorf == 0)
	  	{
	    	timers[tdo] = 0;
	    	timers[tdwel] = 0;
	    	timers[tdc] = 0;
	    	timers[tlant] = 0;
	    	timers[trlant] = 0;
	  	}
	  	if( (cons[rear] == 0) || (rdoorf == 0) )
	  	{
	    	timers[trdo] = 0;
	    	timers[trdwel] = 0;
	    	timers[trdc] = 0;
	  	}


		// Checking to see if dead floor level
		if((rdinp(i_DL) == 1) && (rdinp(i_UL) == 1))   // dead floor level
		{
			if (((rdinp(i_LPS) == 0) && 
				(fvars[fvlps] == 0)) || ((rdinp(i_LPS) == 1) && (fvars[fvlps] == 1)))
			{
				if ((timers[tfault] >= fvars[fvfltt]) && (lps_stall == 0))
				{			 // Go to reset mode
					procf = 0;
					return;
				}
			}

			if(relevel == 1)
				timers[tsoftstp] = 0;
			relevel = 0;              // not releveling
			relevel_req = 0;

			timers[trelev] = 0;
			// Hydro only
		    setoutp(o_LE);        // set the leveling enable output
			setoutp(o_LE1);
			clroutp(o_DNR);   // clear down output
			clroutp(o_UP);      // clear up output
			clroutp(o_RUN);   // clear run output
			clroutp(o_RUNA);

	        // Checking to see if a soft stop is needed
			if(timers[tsoftstp] <= fvars[fvsst])  // soft stop needed
			{
				timers[tmotion] = 0;      // not in motion clear motion timer
				if(dirf == 1)
				{
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
					    setoutp(o_MST);
				    setoutp(o_MCC);
					setoutp(o_MCA);
				}
			}
			else      // No soft stop
			{
				dirf = 0;
				// viscoustiy control run the motor
				if( (servf != 0) && (dpref == 0) && (dcalls == 0) &&
				(((rdinp(i_TPL) == 1) && (fvars[fvtpl] == 0)) || ((rdinp(i_TPL) == 0) && (fvars[fvtpl] == 1))) &&
				(rdoorf == 0) && (doorf == 0) && (position == lobby_fl) )
				{
					if(timers[tmotion] > 100)
						timers[tmotion] = 100;
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
					{
				  		if(timers[tmotion] > fvars[fvydel])
				       		setoutp(o_MST);
				  		else
				       		clroutp(o_MST);
					}
				  	setoutp(o_MCC);
					setoutp(o_MCA);
				  	Viscosity = timers[tmotion];
			    }
			    else
			    {
				  	if (((rdinp(i_TPL) == 0) && (fvars[fvtpl] == 0)) || ((rdinp(i_TPL) == 1) && (fvars[fvtpl] == 1)))
				  	{
						if(Viscosity == 0)
						{
					    	timers[tmotion] = 0;      // not in motion clear motion timer
						}
						else
						{
					    	if((timers[tmotion] - Viscosity) > 25)
								Viscosity = 0;
						}
				  	}
				  	else
				  	{
						if((timers[tmotion] - Viscosity) > 25)
						{
							timers[tmotion] = 0;
							Viscosity = 0;
						}
				  	}
				  	clroutp(o_MCC);
					clroutp(o_MCA);
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
					  	clroutp(o_MST);
				}
	      	}
		}
	// Elevator is not level needs to relevel
		else
		{
	    		// can't relevel too long
		  	 if ( ((timers[tmotion] >= fvars[fvstall]) || (lps_stall == 1)) ||
				// wait for relevel timer to expire
				(timers[trelev] < 20) ||	 // wait 2 seconds
	    		// can't relevel up if on the up directional stop
		  		(rdinp(i_UN) == 0) ||
	    		// can't relevel until soft stop has occured
		  		(timers[tsoftstp] <= (fvars[fvsst] + 15)) ||
				((rdinp(i_DZ) == 0) && ((door_locks() == 0) || (car_gate() == 0))) ||
		  		((empf != no_ep) && (empf != ep_recall) && (empf != ep_select)) )
	      	{

				dirf = 0;
				if((timers[tmotion] >= fvars[fvstall]) && (lps_stall == 0))
				  lps_stall = 1;
				else
				  timers[tmotion] = 0;
				relevel_req = 1;
				relevel = 0;
				if((timers[tsoftstp] > fvars[fvsst]) || (dirf == 2))
				{
					clroutp(o_MCC);      // Clear motor starter output
					clroutp(o_MCA);
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
						clroutp(o_MST); // Turn off motor starter timer output
				}
		    	setoutp(o_LE);        // set the leveling enable output
				setoutp(o_LE1);
				clroutp(o_UP);      // Clear up output
				clroutp(o_DNR);   // Clear down output
				clroutp(o_RUN);   // Clear run output
				clroutp(o_RUNA);
			}
		    else
		    {
		      	// relevel up
				if((rdinp(i_DL) == 0) && (rdinp(i_UL) == 1) || 
						((rdinp(i_DZ) == 0) && (door_locks() == 1) && (car_gate() == 1)) )
				{
					relevel = 1;
					relevel_req = 0;
			  		dirf = 1;
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
					{
			  			if(timers[tmotion] > fvars[fvydel])
			     			setoutp(o_MST);
				  		else
				     		clroutp(o_MST);
					}
			  		setoutp(o_MCC);    // Turn on motor starter output
					setoutp(o_MCA);
			  		setoutp(o_UP);    // Turn on up output
			  		setoutp(o_RUN); // Turn on the run output
					setoutp(o_RUNA);
			  		clroutp(o_DNR); // Turn off down output
				}
			}
		}
	    doors();
	    if(cons[rear] != 0)
			rdoors();

  	}
  	return;
}
#endif

//**********************************
// Manual door close contact is made
//**********************************

int16 man_dcc(void)
{						
	return ((man_fdcc() == 1) && ((man_rdcc() == 1) || (cons[rear] == 0)));
}

int16 man_fdcc(void)
{
	if ((cons[mand] != 0) || (cons[frghtd] != 0) || (cons[Australia] == 1))
	{
		if (cons[topf] > 2)
		{
			if (((rdinp(i_BDC) == 1) || (((cons[access_type] & 0x0A) == 0x08) && (cons[rear] != 0))) && 
				((rdinp(i_TDC) == 1) || (((cons[access_type] & 0x05) == 0x04) && (cons[rear] != 0))) &&
				(rdinp(i_MDC) == 1)) 
				return(1);
			else
				return(0);
		}
		else
		{		  // Special case of only top and bottom floor
			if (((rdinp(i_BDC) == 1) || (((cons[access_type] & 0x0A) == 0x08) && (cons[rear] != 0))) && 
				((rdinp(i_TDC) == 1) || (((cons[access_type] & 0x05) == 0x04) && (cons[rear] != 0))) &&
			    (((cons[access_type] & 0x0C) == 0) || (rdinp(i_MDC) == 1)))
				return(1);
			else
				return(0);
		}
	}
	else
		return(0); 
}

int16 man_rdcc(void)
{
	if ((cons[mand] != 0) || (cons[frghtd] != 0) || (cons[Australia] == 1))
	{
		if (cons[topf] > 2)
		{
			if (((rdinp(i_BDC) == 1) || (((cons[access_type] & 0x0A) == 0x02) || (cons[access_type] == 0))) && 
				((rdinp(i_TDC) == 1) || (((cons[access_type] & 0x05) == 0x01) || (cons[access_type] == 0))) &&
				(rdinp(i_MDCR) == 1)) 
				return(1);
			else
				return(0);
		}
		else
		{		  // Special case of only top and bottom floor
			if (((rdinp(i_BDC) == 1) || (((cons[access_type] & 0x0A) == 0x02) || (cons[access_type] == 0))) && 
				((rdinp(i_TDC) == 1) || (((cons[access_type] & 0x05) == 0x01) || (cons[access_type] == 0))) &&
			    (((cons[access_type] & 0x3) == 0) || (rdinp(i_MDCR) == 1)))
				return(1);
			else
				return(0);
		}
	}
	else
		return(0); 
}

// ********************************
// This is the motion procedure
// ********************************
void motion()
{
#if (Traction == 1)
  float pulse_dist;
  int16 pos;
#endif
  int16 eexit = 0;        // emergency exit of the motion prodedure
  int16 running=0;

  prev_dirf = dirf;
  pfc_sfc_test = 0;
  in_pfc_sfc_test = 0;
  SPB_can.command &= ~spbc_GR1_test;			// Clear GR1 test
  SPB_can.command &= ~spbc_SFC_test;			// Clear SFC test
  ncu_door_seq = 0;
  leveling_fault_cnt = 0;
  ovs_dbn_tim = 0;
  preset = 0;
  timers[tnudge] = 0;
  timers[trnudge] = 0;
  timers[teeto] = 0;
  timers[treeto] = 0;
  timers[tgts_ex] = 0;

  preopen_time = 0;
  pwr_up_reset = 0;
  timers[tdonbrkflt] = 0;
  front_slowdown = 0;
  rear_slowdown = 0;
  lev_startf = 0;

  clr_door_vars();

  
  if ((dirf == 1) && (position == lobby_fl))
  {
	if ((lwd_set_at_lby == 1) || (nmb_cc_above_lby >= fvars[fvupcccnt]))
		up_peak_trigger = 1;
  }

  fault_run = 0;
  timers[tlevto] = 0;
  lev_to = 0;

#if (Traction == 1)
  estop_recovery = 0;
#endif

  while((procf >= 3) && (procf <= 11))
  {

	// Keep the Soft starter motor contactor on except when testing
	if ((Drive_Type[cons[carnmb]] == 9) && (in_pfc_sfc_test == 0))
		setoutp(o_MST);

	if(rdinp(i_DZ) == 0)
	    DZ_ON_Fault = 0;
	if (rdinp(i_DZA) == 0)
		DZA_ON_Fault = 0;
	if(rdinp(i_UL) == 0)
	    UL_ON_Fault = 0;
	if (rdinp(i_DL) == 0)
		DL_ON_Fault = 0;
  #if ((Traction == 1) || (Tract_OL == 1))
	if(rdinp(i_GRT2) == 0)
		gripper_test = 0;

	if ((fvars[fvbkliftsw] != 0) && (firef == 0) && (rfiref == 0))
	{
		if ((BKS_Run_Fault == 0) && (rdoutp(o_BRK) == 1))
		{	// Controller is turning on the brake and there is not brake fault detected
			if ( (((rdinp(i_BRKS) == 0) && (fvars[fvbls] == 0)) 
							|| ((rdinp(i_BRKS) != 0) && (fvars[fvbls] != 0)))
					&&  ((cons[Aux_Brake] == 0) || (((rdinp(i_XBKS1) == 0) && (fvars[fvbls] == 0)) 
							|| ((rdinp(i_XBKS1) != 0) && (fvars[fvbls] != 0))))
			   )
			{ 
				timers[tbksrun] = 0;
				BRK_Pick_Test = 0;
			}
			else if (BRK_Pick_Test == 1)
			{			// Brake has not picked yet
				if (timers[tbksrun] > 30)
				{
					BKS_Run_Fault = 1;
					record_fault(f_bks_run);
				}
			}
			else
			{
				if (timers[tbksrun] > 15)
				{		// brake has picked but has dropped out
					BKS_Run_Fault = 1;
					BRK_Pick_Test = 1;		// set fault condition
					record_fault(f_bks_run);
				}
			}
		}
		else
			timers[tbksrun] = 0;
	}
	else
		BRK_Pick_Test = 0;

 #endif
	nudg_buz = 0;
	rnudg_buz = 0;
	att_buz = 0;
	sabb_buz = 0;
	sabb_ee_en = 0;
	att_buz_on = 0;
	timers[tattbz] = 0;
	timers[tattbzcyc] = 0;
	door_buz = 0;
	freight_fdoor_alarm = 0;
	freight_rdoor_alarm = 0;
	timers[tdoorbz] = 0;
#if (Traction == 1)
	if(procf == 3)
		procf = 4;
	if((timers[tdppflt] >= 20) && (Dmd_Velocity > (Pulses_per_Inch * 15.0)))  // (75fpm * 12 in)/60sec = 15 in/sec * ppi = pps
	{	//check every 2 seconds and speed > 75 fpm
		if(((cons[speed] >= 50)&&(labs(DPP_Count - old_dpp) < (2 * Pulses_per_Inch))) ||
			((cons[speed] < 50)&&(labs(DPP_Count - old_dpp) < (1 * Pulses_per_Inch)) ))
		{
			procf = 11;		//Emergency slowdown no pulses
			if (fault_run == 0)
				fault_run_cnt++;
			fault_run = 1;
	  		record_fault(f_pulse_75fpm_2in);
		}
		if((dirf == 1) && (DPP_Count < old_dpp))
		{
			if (fault_run == 0)
				fault_run_cnt++;
			fault_run = 1;
			procf = 11;		//Dpp Pulsing wrong direction
	  		record_fault(f_pulse_dir_up);
		}
		if((dirf == 2) && (DPP_Count > old_dpp))
		{
			procf = 11;             //DPP Pulsing wrong direction
			if (fault_run == 0)
				fault_run_cnt++;
			fault_run = 1;
	  		record_fault(f_pulse_dir_dn);
		}
		old_dpp = DPP_Count;
		timers[tdppflt] = 0;
	}
	switch(procf)
	{
	  case 4:
		Mode_1();
		break;
	  case 5:
		Mode_2();
		break;
	  case 6:
		Mode_3();
		break;
	  case 7:
		Mode_4();
		break;
	  case 8:
		Mode_5();
		break;
	  case 9:
		Mode_6();
		break;
	  case 10:
		Mode_7();
		break;
	  case 11:
		Mode_8();
		preset_pos = 1;
	    DZ_ON_Fault = 0;
		DZA_ON_Fault = 0;
	    UL_ON_Fault = 0;
		DL_ON_Fault = 0;
  #if ((Traction == 1) || (Tract_OL == 1))
		gripper_test = 0;
		BRK_Pick_Test = 0;
  #endif
		break;
	  default:
		Mode_8();
		break;
	}

	limit_velocity();
	if ((cons[sercom] & 8) == 0)
		
	DAC_Out();

	if (cons[dpp_upd] != 0)
	{
		update_dpp();
	}

#endif
	if ((adv_pre_trq_run == 0) || (fvars[fvadvpretrq] == 0))
	{
		doorf = 0;
		rdoorf = 0;
	}
	Group_IO_Com[cons[carnmb]][g_cancel_up] = 0;
	Group_IO_Com[cons[carnmb]][g_cancel_dn] = 0;
	Group_IO_Com[cons[carnmb]][g_cancel_upr] = 0;
	Group_IO_Com[cons[carnmb]][g_cancel_dnr] = 0;
	inctime(0);          // increment the timers
	if (((((firef == 0) || (hsvf == 1)) && (( empf == no_ep) || (empf == ep_select))) || (firef >= 4) || (rfiref >= 4)) )
	  	carcall();			// not on fire or on phase 2 and not on emergency power or selected to run
	if (((firef == 0) && (ind() == 0) && (codebf == 0) && (vipf == 0)) && (( empf == no_ep) || (empf == ep_select)))
	  	hallcall();

	return_to_lobby();
	elevator_off();
	jail_break();
	setvipf();
	setcodebf();
	sethsvf();
	setfsf();
	setempf();
	seteqf();
	setmedf();
	settugf();

	if ( (cons[Sabbath] == 5) && (sabbath_active == 1) )
	{
		if ((ir_active == 1) && ((fvars[fvsabben] & 0x01) != 0))
		{
			if (servf == 25)
			{
				servf = 1;
				clrcc(0);
			}
		}
	}


	if (((rdinp(i_FS2C) == 1) || ((cons[RGB_CC] == 1) && (rdinp(i_FiFS2C) == 1))) && 
				((firef > 3) || ((firef == 0) && ((servf == 2) || (servf == 4)))))
	{
	    clrcc(0);
		dpref = 0;
	}
	if ((firef >= 1) && (firef <= 3) && (medf == 0) && (hsvf == 0))
	{
		clrcc(0);
		clrhc();
		setoutp(o_FST);  // turn on the fire service stopswitch bypass
		setoutp(o_FSTP);  // turn on the fire service stopswitch bypass
		FS_DOB_DIS = 1;
		clr_dir_arrow();
	}
	else if ((medf >= 1) && (medf <= 2))
	{		  // override stop swtich on medical emergency service
		clrcc(0);
		clrhc();
		setoutp(o_FST);  // turn on the fire service stopswitch bypass
		setoutp(o_FSTP);  // turn on the fire service stopswitch bypass
		FS_DOB_DIS = 1;
		clr_dir_arrow();
	}
	else if((ids_return_typ & 0x01) != 0)
	{
		clrhc();
		setoutp(o_FST);  // turn on the fire service stopswitch bypass
		setoutp(o_FSTP);  // turn on the fire service stopswitch bypass
		FS_DOB_DIS = 1;
		clr_dir_arrow();		
	}
	else
	{
	  clroutp(o_FST);  // turn off the fire service stopswitch bypass
	  clroutp(o_FSTP);  // turn off the fire service stopswitch bypass
	  FS_DOB_DIS = 0;
	}

#if ((Traction == 1) || (Tract_OL == 1))
	if ((empf > no_ep) && (empf != ep_select) && (empf != ep_recall))
	{		   // do not answer calls until car is selected to run or to recall
		clrcc(0);
		clrhc();
	}
	else if (empf == ep_recall)
	{
		if ((firef <= 3) && ((servf != 2) && (servf != 4) || (cons[ansi] < 2007)))
		{			// let car answer phase 2 calls
			clrcc(0);
			clrhc();
		}
	}
#endif
		
   	if(safeties() == 1)
		timers[tsst] = 0;
   	else if (timers[tsst] > 2)
	{		// the saftey string is open
	  	eexit = 1;
		if ((statusf & sf_SS) == 0)
		  	record_fault(f_sstring);
      	statusf |= sf_SS;
	  	procf = 12;
	}
	else
		statusf &= ~sf_SS;
				// Testing to see if LC fuse is blown
	if(rdinp(i_LC) == 0)
	{
		eexit = 1;
		if ((statusf & sf_LC) == 0)
		  	record_fault(f_LC_fuse);
		statusf |= sf_LC;
		procf = 12;
	}
	else
		statusf &= ~sf_LC;

#if((Traction == 1) || (Tract_OL == 1))
  	if((rdinp(i_READY) == 0) && (rdinp(i_GTS) == 1))
	{
		if (timers[tdrvrdy] > 3)
		{
		  	eexit = 1;
			if ((statusf & sf_READY) == 0)
				record_fault(f_drive_rdy);
		    statusf |= sf_READY;
		  	procf = 12;
		}
	}
	else
	{
		statusf &= ~sf_READY;
		timers[tdrvrdy] = 0;
	}
	
	if ((rdinp(i_GTS) == 0) && (safeties() == 1))
	{
		if (timers[tgts_ex] > 3)
		{
			procf = 12;
			eexit = 1;
			record_fault(f_gts_eexit);
		}
	}
	else
		timers[tgts_ex] = 0;
	
#endif

    if((chk_ins() == 1) && (safeties() == 1))
	{
		if (timers[tinst] > 3)
		{
			procf = 2;
			eexit = 1;
			record_fault(f_ins_eexit);
		}
	}
	else
		timers[tinst] = 0;
	

	if(eexit == 1)
	{
		record_fault(f_eexit);
		adv_pre_trq_fault = 1;
		Overspeed_Test = 0;
		Buffer_Test = 0;
		DZ_ON_Fault = 0;
		DZA_ON_Fault = 0;
		UL_ON_Fault = 0;
		DL_ON_Fault = 0;
		gripper_test = 0;
		BRK_Pick_Test = 0;
		clroutp(o_UP);
		clroutp(o_DNR);
		clroutp(o_DF);
		clroutp(o_UPF);
		clroutp(o_RUN);
		clroutp(o_RUNA);
#if ((Traction == 1) || (Tract_OL == 1))
		if (hold_brake_overspeed == 0)
			drop_brake(c_drop_brake_estop);
		if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
		{
			setoutp(o_LE);
			setoutp(o_LE1);
		}
#else
    	setoutp(o_LE);        // set the leveling enable output
		setoutp(o_LE1);
#endif
		clroutp(o_DC);
		clroutp(o_DO);
		clroutp(o_DCR);
		clroutp(o_DOR);
		return;
	}

	if((dirf == 1) && (rdinp(i_UN) == 0) && (rdinp(i_READY) == 1))
	{                                   // hit the up directional stop
#if (Tract_OL == 1)
		clroutp(o_UPF);			// Zero speed UPF:B1,DF:B0 = 0,0
		clroutp(o_DF);	
#else
		clroutp(o_UPF);
#endif
		clroutp(o_UP);
		if (estop == 0)
		{		// Write fault once
		  	record_fault(f_un_open);
		}
//		if ((safeties() == 1) && (rdinp(i_GTS) == 1)	&& (rdinp(i_READY) == 1) && (rdinp(i_STP) == 1)) 
//			position = cons[topf];	  // Deleted from here because of i/o race condition when sfc drops
		timers[tcablnt] = 0;
	 	timers[trcablnt] = 0;
		timers[tdo] = 0;
		estop = 1;
	}
	if((dirf == 2) && (rdinp(i_DN) == 0) && (rdinp(i_READY) == 1))
	{                                   // hit the up directional stop
#if(Tract_OL == 1)
		clroutp(o_UPF);			// Zero speed UPF:B1,DF:B0 = 0,0
		clroutp(o_DF);	
#else
		clroutp(o_DF);
#endif
		clroutp(o_DNR);
		if (estop == 0)
		{	   // Write fault once
		  	record_fault(f_dn_open);
		}
//		if ((safeties() == 1) && (rdinp(i_GTS) == 1)	&& (rdinp(i_READY) == 1) && (rdinp(i_STP) == 1)) 
//			position = cons[bottomf];	 // Deleted from here because of i/o race condition when sfc drops
		timers[tcablnt] = 0;
	 	timers[trcablnt] = 0;
		timers[tdo] = 0;
		estop = 1;
	}

#if ((Traction == 1) || (Tract_OL == 1))

	if ((cons[equake] != 0) && (eqf == 2))	   // collision switch is on
	{
		// Clear direction arrows
		clr_dir_arrow();
		estop = 1;
	}
	if (timers[tmotion] > 20)
	{
		if((rdinp(i_P) == 1) && (timers[tpinflt] > 3) &&
			(rdoutp(o_RUN) == 1) && (rdinp(i_RUNA) == 1) && (estop == 0))   // no potential to run
		{			  // Error if P is on during a run
			statusf |= sf_P;		// potential error
		  	record_fault(f_P_on);
			estop = 1;
		}
		else
		{
			timers[tpinflt] = 0;
			statusf &= ~sf_P;
		}
	}
	else 
		timers[tpinflt] = 0;

	if (timers[tmotion] > 40) 
	{

		if (rdinp(i_DON) == 0) 
		{
			if (timers[tdonbrkflt] > 1)
			{
				if ((rdoutp(o_RUN) == 1) && (rdinp(i_MCA) == 1) && (rdinp(i_RUNA) == 1) && (estop == 0))   // no potential to run
				{			  // No drive on after time delay
			  		record_fault(f_don_off);
					estop = 1;
				}
			}
		}
		else if (rdinp(i_BRK) == 0)
		{
			if (timers[tdonbrkflt] > 1)
			{
				if((rdoutp(o_RUN) == 1) && (rdinp(i_MCA) == 1) && (rdinp(i_RUNA) == 1) && (estop == 0))   // no potential to run
				{			  // No brake on after time delay
				  	record_fault(f_brk_off);
					estop = 1;
				}
			}
		}
		else
			timers[tdonbrkflt] = 0;
	}
	else
		timers[tdonbrkflt] = 0;
#endif

#if (Traction == 1)
	if((rdinp(i_DEL) == 0) && (estop == 0))   // no potential to run
	{									 // aLL other drives				
		if (timers[tpatdly] > (fvars[fvpat_del] + don_delay + 200)) 
		{
			if ((cons[EM_BKS] == 0) && (cons[EM_BRK] != 0) && (cons[EM_BRK] != 3) && (cons[EM_BRK] != 7))	// seperate check for ebks input
				record_fault(f_em_brk_sw_off);
			else
		  		record_fault(f_delta_off);
			if (fault_run == 0)
				fault_run_cnt++;
			fault_run = 1;
			estop = 1;
		}
	}
	
	if((rdinp(i_DEL) == 0) && (estop == 0) && (Drive_Type[cons[carnmb]] == 4) )   // no potential to run
	{														//  4 = MG set
		if (timers[tmotion] > (10 + fvars[fvydel]))
		{
		  	record_fault(f_delta_off);
			estop = 1;
		}
	}

#endif

	if ((rdinp(i_STP) == 0) && ((rdinp(i_FFS) == 1) || (cons[firesv] != 2) || (cons[ansi] < 2004)))       // stop switch pulled
	{
		if (estop == 0)
		{
			if ((rdinp(i_SS) == 1) && (rdinp(i_GTS) == 1))
				record_fault(f_DRV_SP_flt);
		  	record_fault(f_stop_sw);
		}
		estop = 1;
		timers[tmotion] = 0;		// car is not moving
	}

	if (((cons[firesv] == 2) && (cons[ansi] >= 2004)) && 
		(((rdinp(i_SS) == 1) && (rdinp(i_FFS) == 0)) || (fire_stopsw_hold == 1)))        // stop switch pulled
	{
		estops_1_run = 0;
		if (estop == 0)
		  	record_fault(f_FF_stop_sw);
		estop = 1;
		timers[tmotion] = 0;		// car is not moving
	}

#if (Traction == 1)
	if ((Velocity != 0) || (adv_pre_trq_run == 0) || (fvars[fvadvpretrq] == 0))
  	{
		if (safe() == 0)
		{
			if (timers[tsafe] > 1)
			{		// delay for 100 msec
				if (predof == 0)
				{
					if (estop == 0)
				  		record_fault(f_car_safe);
					estop = 1;
					set_safe_fault();
				}
				if((predof == 1) && (rdinp(i_DZ) == 0))
				{
					if (estop == 0)
			  			record_fault(f_car_safe_preop);
					estop = 1;
					set_safe_fault();
				}
			}
		}
		else
		{
			timers[tsafe] = 0;
			safe_fault_latch = 0;
		}
	}
	else
	{
		if ((rdinp(i_DPM) == 0) &&
					((cons[rear] == 0) || (rdinp(i_RPM) == 0)))
		{
			if (timers[tsafe] > 1)
			{		// delay for 100 msec
				if (estop == 0)
			  		record_fault(f_car_safe);
				estop = 1;
				set_safe_fault();
			}
		}
		else
		{
			timers[tsafe] = 0;
			safe_fault_latch = 0;
		}

		if ((adv_pre_trq_run == 1) && (safe() == 0))
		{
		    doors();
		    if(cons[rear] != 0)
				rdoors();
		    else
				rdoorf = 0;

			if ((timers[tadvptrq] > 50) || (doorf == 1) || (rdoorf == 1))
			{
				if ((estop == 0) /* && (timers[tadvptrq] > 50) */ )
					record_fault(f_advpt_start);
				adv_pre_trq_fault = 1;
				estop = 1;
				set_safe_fault();
			}
		}
	}
#else
	if (safe() == 0)
	{
		if (timers[tsafe] > 1)
		{		// delay for 100 msec
			if (predof == 0)
			{
				if (estop == 0)
			  		record_fault(f_car_safe);
				estop = 1;
				set_safe_fault();
			}
			if((predof == 1) && (rdinp(i_DZ) == 0))
			{
				if (estop == 0)
		  			record_fault(f_car_safe_preop);
				estop = 1;
				set_safe_fault();
			}
		}
	}
	else
	{
		timers[tsafe] = 0;
		safe_fault_latch = 0;
	}
#endif

#if((Traction == 0) && (Tract_OL == 0))
	if ((cons[Low_Press] == 1) &&
		(((rdinp(i_LPS) == 1) && (fvars[fvlps] == 0)) || 
		((rdinp(i_LPS) == 0) && (fvars[fvlps] == 1))))
	{
		if (dirf == 2)
		{		  // stop the car from going down
			if (estop == 0)
			{
				if ((hsf == 0) || ((hsf == 1) && (stepf == 0)))		// had already decremented position but we are changing direction and going up
					position++;
				if (position > cons[topf])
					position = cons[topf];
			}
			hsf = 0;
			estop = 1;
		}
	}
#endif

#if((Traction == 0) && (Tract_OL == 0))
	if ( (estop == 0) && 
		((timers[tmotion] >= fvars[fvstall]) || 
			((cons[Low_Oil] == 1) && (stallf == 0) &&
				(((rdinp(i_LOS) == 1) && (fvars[fvlos] == 0)) || 
				 ((rdinp(i_LOS) == 0) && (fvars[fvlos] == 1))) ) ) )
#else
	if ((estop == 0) && (timers[tmotion] >= fvars[fvstall])) 
#endif
	{
		if (fault_run == 0)
			fault_run_cnt++;
		fault_run = 1;
		// Clear direction arrows
		clr_dir_arrow();
		clrcc(0);		// clear car calls  (This will cancel the calls on a Phase 2 car)
#if((Traction == 0) && (Tract_OL == 0))
		if ((cons[Low_Press] == 1) &&
			(((rdinp(i_LPS) == 1) && (fvars[fvlps] == 0)) || 
			((rdinp(i_LPS) == 0) && (fvars[fvlps] == 1))))
		{
			lps_stall = 1;
			hsf = 0;
		}
		else
		{
			if ((cons[Low_Oil] == 1) &&
				(((rdinp(i_LOS) == 1) && (fvars[fvlos] == 0)) || 
			 	 ((rdinp(i_LOS) == 0) && (fvars[fvlos] == 1))) ) 
		  		record_fault(f_lowoil_switch);
			else
		  		record_fault(f_stall_fault);
			stallf = 1;			// take out anti stall
			servf = 14;			// take out anti stall
			dirf = 2;		
			dpref = 2;		// force a down run
			if (rdinp(i_DT)==0)		// on the down terminal limit
				hsf = 0;			  // level to the floor
			else
				hsf = 1;			  // else run high speed to the floor
		}
#else
  		record_fault(f_stall_fault);
		stallf = 1;
		servf = 14;			// take out anti stall
#endif
		estop = 1;
	}

#if((Traction == 0) && (Tract_OL == 0))
	if ((cons[EMPop] & 0x02) == 0)
	{
		if((empf == ep_recall) && (dirf == 1)) 
		{	// Emergency Power has been initiated while car was moving so stop (Hydro)
			if (estop == 1)
			{
				dirf = 2;		// this code should only execute once
				dpref = 2;		// force a down run
				// Clear direction arrows
				clr_dir_arrow();
				if (rdinp(i_DT)==0)		// on the down terminal limit
					hsf = 0;			  // level to the floor
				else
					hsf = 1;			  // else run high speed to the floor
			}

			estop = 1;
	 	}
	}
#else
	if (cons[Emp_Recover] == 2)
	{
		if ((rdoutp(o_NPD) == 0) && (rdoutp(o_EPD) == 0))
		{	// Controller not enabling power to drive so stop car
			if (estop == 0)
	  			record_fault(f_epr_pwr_mov_flt);
			estop = 1;	
		}
	}
#endif
#if(Traction == 1)
	if (cons[speed] <= 25)
		pulse_dist = 0.2;
	else if (cons[speed] <= 75)
		pulse_dist = 1;
	else
		pulse_dist = 3;

	if( (Dmd_Velocity > (.75 * Vel_Max)) &&
		(labs(DPP_Count - (DPP_Floor_Pos[start_floor] + DPP_Fl_Offset[start_floor])) < (pulse_dist * Pulses_per_Inch)) )
	{
		running = 1;
		if (fault_run == 0)
			fault_run_cnt++;
		fault_run = 1;
  		record_fault(f_pulse_75speed);
		estop = 1;
	}
#endif
	if(estop == 1)
	{
		gripper_test = 0;
		DZ_ON_Fault = 0;
		DZA_ON_Fault = 0;
		UL_ON_Fault = 0;
		DL_ON_Fault = 0;
		BRK_Pick_Test = 0;
		no_fault = 0;
		clroutp(o_UP);
		clroutp(o_DNR);
		clroutp(o_DF);
		clroutp(o_UPF);
		clroutp(o_RUN);
		clroutp(o_RUNA);
#if(Traction == 1)
		Velocity = 0;
		Dmd_Velocity = 0;
		Vel_Step = 0;
		timers[tvpat] = 0;
#endif
#if ((Traction == 1) || (Tract_OL == 1))
		if (hold_brake_overspeed == 0)
			drop_brake(c_drop_brake_estop);
		if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
		{
			setoutp(o_LE);
			setoutp(o_LE1);
		}
		timers[tdppflt] = 0;
#else
		setoutp(o_LE);        // set the leveling enable output
		setoutp(o_LE1);
#endif
		timers[tdodly] = 0;
		timers[trdodly] = 0;

#if((Traction == 0)	&& (Tract_OL == 0))
		if((timers[tsoftstp] > fvars[fvsst]) || (dirf == 2))	  // change from tfault to tsoftstp 1/8/08 mhd
#else
		if(timers[tsoftstp] > fvars[fvsst]) 
#endif
		{
			clroutp(o_MCC);
			clroutp(o_MCA);
#if(Traction == 0)
			if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
				clroutp(o_MST);
#endif
		}

#if(Traction == 1)
	    if(timers[tff] <= 40)
			setoutp(o_FF);
	    else
			clroutp(o_FF);
//		clroutp(o_FW);
#endif
		if ((safe() == 0) || (fire_stopsw_hold == 1) ||  	
			((empf != no_ep) && (empf != ep_select) && (empf != ep_recall)))
		{
			timers[tmotion] = 0;	// Don't want a stall fault if the gate or locks are open.
//			timers[tfault] = 0;
			if (timers[tfault] > fvars[fvfltt]) 
			{
				if ((rdinp(i_DZ) == 1) && (rset == 0) && (fire_stopsw_hold == 0) && 
					((eqf == 0) || (empf == ep_select)) )
				{				   // if on door zone then relevel to the floor
					procf = 15;               // end of the run go to the floor procedure
					eexit = 1;
				}	  

				servf = 0;
			}
		}
		else if (timers[tfault] >= fvars[fvfltt])
		{		 // Can't run until fault timer expires	and stop condition is cleared

			if ((cons[Emp_Recover] == 2) && (rdinp(i_EMP) == 1))
			{
		  		eexit = 1;
				procf = 0;		// go into reset mode
				break;
			}
			
			if ((Buffer_Test != 0) || (Overspeed_Test != 0))
			{		  
				Overspeed_Test = 0;
				Buffer_Test = 0;
		  		eexit = 1;
				procf = 0;		// go into reset mode
				break;
			}
			else
			{
				Overspeed_Test = 0;
				Buffer_Test = 0;
		    }

		    estops_1_run++;
			if (estops_1_run > 3)
			{		  
		  		eexit = 1;
			  	record_fault(f_estop);
		  		procf = 12;
				break;
			}

#if(Traction == 1)
			else
			{		   // recover to floor at recovery speed
				Vel_Max_Set = Recovery_Vel;		// Recovery Speed
				estop_recovery = 1;
				procf = 4;	//start pattern from mode 1
				hsf = 0;
				lev_to =0;
			}
#endif
#if((Traction == 0)	&& (Tract_OL == 0))
			if ((cons[Low_Press] == 1) && 
				(((rdinp(i_LPS) == 1) && (fvars[fvlps] == 0)) || 
				((rdinp(i_LPS) == 0) && (fvars[fvlps] == 1))))
			{
		  		eexit = 1;
				procf = 19;
				return;
			}
#endif

#if ((Traction == 1) || (Tract_OL == 1))
			if ((cons[ansi] > 2000) && (gripper_fault == 1))
			{
		  		eexit = 1;		// exit to safety string mode  (gts should have dropped)
		  		procf = 12;
				break;			// exit do while loop
			}
#endif

			if(running == 1)
			{
//				timers[tgroup_hcc]  = 0;
				timers[ccct] = 0;
				running = 0;
			}
			estop = 0;
			timers[tfault] = 0;
			timers[tsafe] = 0;
			safe_fault_latch = 0;
			timers[tlevto] = 0;

			dirsel();		// dirf flag can get changed in this routine

			preset_pos = 1;		// Correct the position if it is incorrect

#if(Traction == 1)

			set_position(dirf);
			hsf	= 1;
			nstopf = 0;

			if (dirf == 0)
			{						// incase dirf gets cleared
				if (prev_dirf != 0)
					dirf = prev_dirf;
				else
					dirf = 2;
			}

			if (dirf == 1)
			{	 // going up
				if (position < cons[topf])
					DPP_Target = DPP_Floor_Pos[position + 1] + DPP_Fl_Offset[position + 1];
				else
					DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
			}
			else if (dirf == 2) // going down
			{
				if (position > cons[bottomf])
					DPP_Target = DPP_Floor_Pos[position - 1] + DPP_Fl_Offset[position - 1];
				else
					DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
			}

			timers[tmotion] = 0;            // stall
			timers[tpatdly] = 0;
			old_dpp = DPP_Count;
#else
			if ((pass_fl == 1) && (rev_stepf == 1))
				stepf = 0;

			if (prev_dirf != dirf)
			{			  // Change in direction

				if (pass_fl == 1)
				{
					if (dirf == 1)
						position++;
					else if (dirf == 2)
						position--;
					pass_fl = 0;
				}

				if ((cons[equake] != 0) && (eqf != 0))	   // collision switch is on
				{		  // on earthquake operation so run at low speed
					if ((stepf == 0) && (eq_pos_reset == 0))
					{		 // position is not going to change when the slowdown is hit.
						if (dirf == 1)
							position++;
						else if (dirf == 2)
							position--;
						eq_pos_reset = 1;
					}
				}
				else 
	 			{
					if ((stepf == 1) && (rev_stepf == 1))
					{		// need to correct position
						if ((dirf == 2) && (rdinp(i_DT) == 1))
							position++;
						else if ((dirf == 1) && (rdinp(i_UT) == 1))
							position--;
					}
					else 
					{
						if (stepf == 0)
							stepf = 1;
					}
				}

				if ((cons[shortfl] != 0) || (cons[shortflmid] != 0))
				{
					if (((dirf == 1) && (position == cons[shortfl])) ||
						((dirf == 2) && (position == (cons[shortfl] + 1))) ||
						((dirf == 1) && (position == cons[shortflmid])) ||
						((dirf == 2) && (position == (cons[shortflmid] + 1))))
					{
						timers[tshortfl] = 0;
						short_fl_run = 1;
					}
				}
			}
			else 
			{
				if ((cons[equake] != 0) && (eqf != 0))	   // collision switch is on
				{		  // on earthquake operation so run at low speed
					if ((stepf == 1) && (eq_pos_reset == 0))
					{		 // position is not going to change when the slowdown is hit.
						if (dirf == 1)
							position++;
						else if (dirf == 2)
							position--;
						eq_pos_reset = 1;
					}
				}
			}
			if (position > cons[topf])
				position = cons[topf];
			if (position < cons[bottomf])
				position = cons[bottomf];
			dirsel();		// dirf flag can get changed in this routine

			if (dirf == 0)
			{						// incase dirf gets cleared
				if (prev_dirf != 0)
					dirf = prev_dirf;
				else
					dirf = 2;
			}

			if ((cons[equake] != 0) && (eqf != 0))	   // collision switch is on
			{		  // on earthquake operation so run at low speed
				nstopf = 1;
				hsf = 0;
			}
			else
			{
				front_slowdown = 0;
				rear_slowdown = 0;
				nstopf = needstop();
				if (nstopf != 0)
				{
					if ((stepf == 1) && (rev_stepf == 1))
						hsf = 1;				  // we will hit the slowdown before the next floor
					else
						hsf = 0;				// Must recover at less than 150 fpm to the next floor
				}
				else
					hsf = 1;
			}

			timers[tpatdly] = 0;
			timers[tmotion] = 0;
#endif
			if((cons[frghtd] == 1) || (cons[mand] != 0))
			{
				setoutp(o_DC);
				clroutp(o_DO);
				setoutp(o_DCR);
				clroutp(o_DOR);
			}
			else
			{
				clroutp(o_DC);
				clroutp(o_DO);
				clroutp(o_DCR);
				clroutp(o_DOR);
			}

			if(rdinp(i_UN) == 0)
			{                                   // hit the up directional stop
				if ((safeties() == 1) && (rdinp(i_GTS) == 1)	&& (rdinp(i_READY) == 1) && (rdinp(i_STP) == 1)) 
					position = cons[topf];
				procf = 15;               // end of the run go to the floor procedure
				eexit = 1;
			}
			if(rdinp(i_DN) == 0)
			{                                   // hit the up directional stop
				if ((safeties() == 1) && (rdinp(i_GTS) == 1)	&& (rdinp(i_READY) == 1) && (rdinp(i_STP) == 1)) 
					position = cons[bottomf];
				procf = 15;               // end of the run go to the floor procedure
				eexit = 1;
			}

#if (Traction == 0)

			if (((rdinp(i_DZ) == 1) || (rdinp(i_UL) == 1) || (rdinp(i_DL) == 1)) &&
				(pass_fl == 0) && (hsf == 0) && (rset == 0) && (eqf == 0))
			{				   // if on door zone then relevel to the floor
				procf = 15;               // end of the run go to the floor procedure
				eexit = 1;
			}	  
#endif
		}
		else
		{
			setoutp(o_DC);
			clroutp(o_DO);
			setoutp(o_DCR);
			clroutp(o_DOR);
		}

		if (timers[tfault] >= fvars[fvfltt])
		{			// allow soft stop to occur and the level into floor
			if ((rdinp(i_DZ) == 1) && (rdinp(i_GS) == 0))
			{					 // Car is stopped in the door zone and the gate is open
				if ((cons[BinPiIn] == 1) || (cons[sel_type] != 0))
				{
					preset_pos = 1;		// Correct the position if it is incorrect
					procf = 15;
					eexit = 1;
				}
			}
		}

	}
	else                // everything is safe to run
	{


		prev_dirf = dirf;

#if ((Traction == 1) || (Tract_OL == 1))

		verify_limit_seq(0);		// parameter == 0 to run limit check

		if (fvars[fvdon] != 0)
		{
			if ((rdinp(i_DON) == 0) && (timers[tpatdly] < 400))
			{
				don_delay = timers[tpatdly];
				if (don_delay == 0)
					don_delay = 1;
			}
		}
		else
			don_delay = 0;

		if((position != cons[vshort_tfl]) && (position != cons[vshort_tfl] - 1))
			verify_uldl_seq(0);		// parameter == 0 to run ul/dl check 

#endif

#if(Traction == 1)
		setoutp(o_FF);
		timers[tff] = 0;

/*		if (Dmd_Velocity > (((float)fvars[fvfweak] * Vel_Max)/100.0))
			setoutp(o_FW);	 // Weaken the motor field
		else
			clroutp(o_FW);
*/
#endif

		if(hsf == 1)
		{
			clroutp(o_LE);
			clroutp(o_LE1);
		}

		if(timers[tmotion] >= 20)
			running = 1;
		if ((servf == 0) && (rdinp(i_AD) == 1) && 
			((rhjackf < 2) || (cons[Reset_Jack] == 0)) && 
			((cons[ids] == 0) || (ids_ad_off[cons[carnmb]] == 1)) &&
			((cons[Galileo] == 0) || (ui_ad_off[cons[carnmb]] == 1)))
				servf = 1;
		timers[tfault] = 0;
		if (((fvars[fvpredo] & 0x01) != 0) && ((short_fl_run == 0) || ((fvars[fvpredo] & 0x02) == 0)))
		{
#if(Traction == 1)
		    if((hsf == 1) || (rdinp(i_DZ) == 0) ||	((rdinp(i_UL) == 0) && (rdinp(i_DL) == 0)) ||
		       (rdoutp(o_LE) == 0) || (rdinp(i_AD) == 0) || 
		       (((cons[ids] & 1) != 0) && (ids_ad_off[cons[carnmb]] == 1)) ||
		       (((cons[Galileo] & 1) != 0) && (ui_ad_off[cons[carnmb]] == 1)) )
#else
		    if((hsf == 1) || (rdinp(i_DZ) == 0) ||	((rdinp(i_UL) == 0) && (rdinp(i_DL) == 0)) ||
		       (rdinp(i_AD) == 0) || 
		       (((cons[ids] & 1) != 0) && (ids_ad_off[cons[carnmb]] == 1)) ||
		       (((cons[Galileo] & 1) != 0) && (ui_ad_off[cons[carnmb]] == 1)))
#endif
		    {
				predof = 0;
				timers[tpredo] = 0;
		    }
		    else
		    {
				if(timers[tpredo] > fvars[fvpred])
				{
					if (predof == 0)
						preopen_time = timers[tmotion];
				    predof = 1;
				}
		    }
		    if ((rdinp(i_DZ) == 1) && (predof == 1) && ((rdinp(i_UL) == 1) || (rdinp(i_DL) == 1)) && 
		    		(DZ_ON_Fault == 0) && (UL_ON_Fault == 0) && (DL_ON_Fault == 0))
		    {
				doorsel();
				if (fdoor_en == 1)
				{
					if( ((carcb[position] == 1) && (firef == 0)) ||
					    ((dpref == 1) && (upcb[position] == 1) && (firef == 0)) ||
					    ((dpref == 2) && (downcb[position] == 1) && (firef == 0)) )
					{
						if(ccmsk[cons[carnmb]][position] == 1)
						{
							if (timers[tdodly] >= fvars[fvdrdly])
								setoutp(o_DO);
						}
						clroutp(o_DC);
					}
				}
				else clroutp(o_DO);

				if ((cons[rear] != 0) && (rdoor_en == 1))
				{
					if( ((rcarcb[position] == 1) && (firef == 0)) ||
						((dpref == 1) && (rupcb[position] == 1) && (firef == 0)) ||
						((dpref == 2) && (rdowncb[position] == 1) && (firef == 0)) )
					{
						if(rccmsk[cons[carnmb]][position] == 1)
						{
							if (timers[trdodly] >= fvars[fvdrdly])
								setoutp(o_DOR);
						}
						clroutp(o_DCR);
					}
				}
				else
					clroutp(o_DOR);
		    }
		    else
		    {
				timers[tdodly] = 0;
				timers[trdodly] = 0;
				if ((cons[dcpo] == 0) && ((adv_pre_trq_run == 0) || (fvars[fvadvpretrq] == 0)))
				{
					clroutp(o_DC);
					clroutp(o_DCR);
				}
				else
				{
					setoutp(o_DC);
					setoutp(o_DCR);
				}
		    }
		}
		else
		{
 			timers[tdodly] = 0;
 			timers[trdodly] = 0;
			if ((cons[dcpo] == 0) && ((adv_pre_trq_run == 0) || (fvars[fvadvpretrq] == 0)))
			{
				clroutp(o_DC);
				clroutp(o_DCR);
			}
			else
			{
				setoutp(o_DC);
				setoutp(o_DCR);
			}
			clroutp(o_DO);
			clroutp(o_DOR);
		}

		if (rdinp(i_DZ) == 1)
		{
			stepf = 1;
			rev_stepf = 0;
			timers[tshortfl] = 0;	// keep zeroing timer until it leavs dz (should make timer more consistant)
		}

		if ((dirf == 1) && (rdinp(i_DS) == 1))
			rev_stepf = 1;		// going up and past the down slowdown
		if ((dirf == 2) && (rdinp(i_US) == 1))
			rev_stepf = 1;		// going down and pasted the up slowdown

		timers[tdo] = 0;
		timers[trdo] = 0;
		timers[tgen] = 0;
		timers[tebkdrop] = 0;
		timers[tsoftstp] = 0;
		if (timers[tbep] >= fvars[fvhbept])
			handicap_buz = 0;
		if(hsf == 0)
		{
#if(Traction == 1)
			if((dirf == 1) && (rset == 0) && (procf != 11) )
			{
				if( (DPP_Count>=((DPP_Floor_Pos[position] + DPP_Fl_Offset[position]) - (int32)(18.0*Pulses_per_Inch))) &&
					(nstopf != 0) )
				{
					if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
					{
						setoutp(o_LE);
						setoutp(o_LE1);
					}
				}
				else
				{
					clroutp(o_LE);
					clroutp(o_LE1);
				}
			}
			if((dirf == 2) && (rset == 0) && (procf != 11) )
			{
				if( (DPP_Count<=((DPP_Floor_Pos[position] + DPP_Fl_Offset[position]) + (int32)(18.0*Pulses_per_Inch))) &&
					(nstopf != 0) )
				{
					if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
					{
						setoutp(o_LE);
						setoutp(o_LE1);
					}
				}
				else
				{
					clroutp(o_LE);
					clroutp(o_LE1);
				}
			}
#endif

#if (Tract_OL == 1)
			if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
			{
				setoutp(o_LE);
				setoutp(o_LE1);
			}
#endif			  
#if((Traction == 0) && (Tract_OL == 0))   
			setoutp(o_LE);
			setoutp(o_LE1);
#endif 
			if (dpref == 0)
			{
				dirsel();
				timers[tlant] = 0;
				timers[trlant] = 0;
			}
			needstop();			// called here to set the slowdown flag
			if (front_slowdown == 0)
				timers[tlant] = 0;
			if (rear_slowdown == 0)
				timers[trlant] = 0;
			hlants();
			set_dir_arrow();
#if (Traction == 1)

			if (procf == 10)
			{
				if (timers[tlevto] > 100)		// leveling for more than 10 seconds
				{
					lev_to = 1;
					if (estop == 0)
						record_fault(f_levto);
					estop = 1;
				}
			}
			else
				timers[tlevto] = 0;


			if( (Dmd_Velocity < (Pulses_per_Inch * 15.0)) &&   	// less than 75 fpm.
				(rdoutp(o_LE) == 1) && 				// leveling is enabled
				((procf == 10) || (short_fl_run == 0)) )		// in leveling mode
				set_ul_dl();  // sets up_level and dn_level
			else
			{
				dn_level = rdinp(i_DL);
				up_level = rdinp(i_UL);
			}

			// Added velocity check and leveling enable check to prevent premature stop
			if( (Dmd_Velocity < (Pulses_per_Inch * 15.0)) &&   // less than 75 fpm.
				(rdoutp(o_LE) == 1) && 		// leveling is enabled
				((short_fl_run == 0) || (procf == 10) || (procf == 11)) &&
			  ( ((up_level == 1) && (dn_level == 1) && ((rdinp(i_DZ) == 1) || (rdinp(i_DZA) == 1)))
				|| ((rdinp(i_DZ) == 1) && (rdinp(i_DZA) == 1) && (rdinp(i_UL) == 0) && (rdinp(i_DL) == 0))
				|| ((rdinp(i_DZ) == 1) && (rdinp(i_DZA) == 1) && (fvars[fvppstop] == 1) && (cons[dpp_upd] != 0) && (level_stop_fault == 1)) ) )
#else

			if ((pass_fl == 1) && ((cons[shortfl] != 0) || (cons[shortflmid] != 0)))
			{
				if (rdinp(i_DZ) == 1)
					stepf = 1;
				else if (stepf == 1)
				{
					stepf = 0;
					pass_fl = 0;
				}
			}
			else if  ( ((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1) && ((rdinp(i_DZ) == 1) || (rdinp(i_DZA) == 1)))
				|| ((rdinp(i_DZ) == 1) && (rdinp(i_DZA) == 1) && (rdinp(i_UL) == 0) && (rdinp(i_DL) == 0)) ) 
#endif
			{
				initial_stop();			// clear timers and record flight times
				procf = 15;           // end of the run go to the floor procedure
			}
		}
		else
		{
			front_slowdown = 0;
			rear_slowdown = 0;
			timers[tlevto] = 0;
			clrlant();
			if (((fvars[fvsabben2] & 0x02) != 0) && (servf == 25)) 
			{
				if ((dirf == 1) || ((dirf == 0) && (dpref == 1)))
				{
					setoutp(o_CUL);
					cab_lant_up = 1;
					if (cons[rear] != 0)
					{
						setoutp(o_CULR);
						cab_rlant_up = 1;
					}
				}
				else if ((dirf == 2) || ((dirf == 0) && (dpref == 2)))
				{
					setoutp(o_CDL);
					cab_lant_dn = 1;
					if (cons[rear] != 0)
					{
						setoutp(o_CDLR);
						cab_rlant_dn = 1;
					}
				}
			}
		}
		
		
		if(dirf == 1)             // going up
		{
#if (Traction == 1)
			if(rset == 0)           // dont check fault when reseting
			{
				if( (cons[speed] > 1300) &&      // check if switch opens or
					( (rdinp(i_UT6)==0) ||   // DPP 42" above it's open point
					(DPP_Count > (DPP_UT[6] + (int32)(42.0*Pulses_per_Inch))) ) )
				{
					if(UT_Open[6] == 0)               // checking to see if the 4 slowdown
					{                             // is within 32 inches of the table
					    if( (DPP_Count < (DPP_UT[6] - (int32)(42.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_UT[6] + (int32)(42.0*Pulses_per_Inch))) )
					    {
						  	record_fault(f_UT6_count);
							procf = 11;           // UT5 not in right spot Emergency
					    }                           // Slowdown Initiated
					    UT_Speed[6] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_UT6)==0) && (DPP_Target < DPP_Count) && (UT_Open[6] == 0) && (procf != 10)) 
					{
					  	record_fault(f_UT6_Target);
						DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
					    procf = 11;           // UT5 not in right spot Emergency
					}                           // Slowdown Initiated
					UT_Open[6] = 1;
				}
				else
					UT_Open[6] = 0;
				if( (cons[speed] > 1100) &&      // check if switch opens or
					( (rdinp(i_UT5)==0) ||   // DPP 32" above it's open point
					(DPP_Count > (DPP_UT[5] + (int32)(32.0*Pulses_per_Inch))) ) )
				{
					if(UT_Open[5] == 0)               // checking to see if the 4 slowdown
					{                             // is within 32 inches of the table
					    if( (DPP_Count < (DPP_UT[5] - (int32)(32.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_UT[5] + (int32)(32.0*Pulses_per_Inch))) )
					    {
						  	record_fault(f_UT5_count);
							procf = 11;           // UT5 not in right spot Emergency
					    }                           // Slowdown Initiated
					    UT_Speed[5] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_UT5)==0) && (DPP_Target < DPP_Count) && (UT_Open[5] == 0) && (procf != 10)) 
					{
					  	record_fault(f_UT5_Target);
						DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
					    procf = 11;           // UT5 not in right spot Emergency
					}                           // Slowdown Initiated
					UT_Open[5] = 1;
				}
				else
					UT_Open[5] = 0;
				if( (cons[speed] > 900) &&      // check if switch opens or
					( (rdinp(i_UT4)==0) ||   // DPP 24" above it's open point
					(DPP_Count > (DPP_UT[4] + (int32)(24.0*Pulses_per_Inch))) ) )
				{
					if(UT_Open[4] == 0)               // checking to see if the 4 slowdown
					{                             // is within 24 inches of the table
					    if( (DPP_Count < (DPP_UT[4] - (int32)(24.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_UT[4] + (int32)(24.0*Pulses_per_Inch))) )
					    {
						  	record_fault(f_UT4_count);
							procf = 11;           // UT4 not in right spot Emergency
					    }                           // Slowdown Initiated
					    UT_Speed[4] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_UT4)==0) && (DPP_Target < DPP_Count) && (UT_Open[4] == 0) && (procf != 10)) 
					{
					  	record_fault(f_UT4_Target);
						DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
					    procf = 11;           // UT4 not in right spot Emergency
					}                           // Slowdown Initiated
					UT_Open[4] = 1;
				}
				else
					UT_Open[4] = 0;
				if( (cons[speed] > 700) &&      // check if switch opens or
					( (rdinp(i_UT3)==0) ||   // DPP 18" above it's open point
					(DPP_Count > (DPP_UT[3] + (int32)(18.0*Pulses_per_Inch))) ) )
				{
					if(UT_Open[3] == 0)               // checking to see if the 4 slowdown
					{                             // is within 18 inches of the table
					    if( (DPP_Count < (DPP_UT[3] - (int32)(18.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_UT[3] + (int32)(18.0*Pulses_per_Inch))) )
					    {
						  	record_fault(f_UT3_count);
							procf = 11;           // UT3 not in right spot Emergency
					    }                           // Slowdown Initiated
					    UT_Speed[3] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_UT3)==0) && (DPP_Target < DPP_Count) && (UT_Open[3] == 0) && (procf != 10)) 
					{
					  	record_fault(f_UT3_Target);
						DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
					    procf = 11;           // UT3 not in right spot Emergency
					}                           // Slowdown Initiated
					UT_Open[3] = 1;
				}
				else
					UT_Open[3] = 0;
				if( (cons[speed] > 500) &&      // check if switch opens or
				( (rdinp(i_UT2)==0) ||   // DPP 14" above it's open point
				(DPP_Count > (DPP_UT[2] + (int32)(14.0*Pulses_per_Inch))) ) )
				{
				    if(UT_Open[2] == 0)               // checking to see if the 3 slowdown
				    {                             // is within 14 inches of the table
						if( (DPP_Count < (DPP_UT[2] - (int32)(14.0*Pulses_per_Inch))) ||
						    (DPP_Count > (DPP_UT[2] + (int32)(14.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_UT2_count);
						    procf = 11;           // UT2 not in right spot Emergency
						}                           // Slowdown Initiated
						UT_Speed[2] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
				    }
					if ((rdinp(i_UT2)==0) && (DPP_Target < DPP_Count) && (UT_Open[2] == 0) && (procf != 10)) 
					{
					  	record_fault(f_UT2_Target);
						DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
					    procf = 11;           // UT2 not in right spot Emergency
					}                           // Slowdown Initiated
				    UT_Open[2] = 1;
				}
				else
				    UT_Open[2] = 0;
				if( (cons[speed] > 250) &&      // check if switch opens or
				( (rdinp(i_UT1)==0) ||   // DPP 10" above it's open point
				(DPP_Count > (DPP_UT[1] + (int32)(10.0*Pulses_per_Inch))) ) )
				{
				    if(UT_Open[1] == 0)               // checking to see if the 2 slowdown
				    {                             // is within 6 inches of the table
						if( (DPP_Count < (DPP_UT[1] - (int32)(10.0*Pulses_per_Inch))) ||
						    (DPP_Count > (DPP_UT[1] + (int32)(10.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_UT1_count);
						    procf = 11;           // UT1 not in right spot Emergency
						}                           // Slowdown Initiated
						UT_Speed[1] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
				    }
					if ((rdinp(i_UT1)==0) && (DPP_Target < DPP_Count) && (UT_Open[1] == 0)) 
					{
					  	record_fault(f_UT1_Target);
						DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
					    procf = 11;           // UT1 not in right spot Emergency
					}                           // Slowdown Initiated
				    UT_Open[1] = 1;
				}
				else
					UT_Open[1] = 0;
				if( ((cons[speed] > 200) || (cons[rsbuffer] == 1)) &&      // check if switch opens or
				( (rdinp(i_UTS)==0) ||   // DPP 10" above it's open point
				(DPP_Count > (DPP_UTS + (int32)(ETS_Dist*Pulses_per_Inch))) ) )
				{
				    if(UTS_Open == 0)               // checking to see if the 2 slowdown
				    {                             // is within 6 inches of the table
						if( (DPP_Count < (DPP_UTS - (int32)(ETS_Dist*Pulses_per_Inch))) ||
						    (DPP_Count > (DPP_UTS + (int32)(ETS_Dist*Pulses_per_Inch))) )
						{
						  	record_fault(f_UTS_count);
						    procf = 11;           // UTS not in right spot Emergency
						}                           // Slowdown Initiated
						UTS_Speed = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
				    }
					if ((rdinp(i_UTS)==0) && (DPP_Target < DPP_Count) && (UTS_Open == 0) && (procf != 10)) 
					{
					  	record_fault(f_UTS_Target);
						DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
					    procf = 11;           // UTS not in right spot Emergency
					}                           // Slowdown Initiated
				    UTS_Open = 1;
				}
				else
					UTS_Open = 0;
				if( (rdinp(i_UT)==0) ||
					(DPP_Count > (DPP_UT[0] + (int32)(10.0*Pulses_per_Inch))) )
				{
				    if(UT_Open[0] == 0)               // checking to see if the slowdown
				    {                             // is within 6 inches of the table
						if( (DPP_Count < (DPP_UT[0] - (int32)(10.0*Pulses_per_Inch))) ||
						    (DPP_Count > (DPP_UT[0] + (int32)(10.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_UT_count);
						    procf = 11;           // UT not in right spot Emergency
						}                           // Slowdown Initiated
						UT_Speed[0] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
				    }
					if ((rdinp(i_UT)==0) && (DPP_Target < DPP_Count) && (UT_Open[0] == 0) && (procf != 10)) 
					{
					  	record_fault(f_UT_Target);
						DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
					    procf = 11;           // UT not in right spot Emergency
					}                           // Slowdown Initiated
				    UT_Open[0] = 1;
				}
				else
					UT_Open[0] = 0;

			}
			if((rset != 0) && (rdinp(i_UT) == 0) && (procf != 15))
			{		// Car is lost
				procf = 11;
				hsf = 0;
				if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
				{
					setoutp(o_LE);
					setoutp(o_LE1);
				}
				if ((safeties() == 1) && (rdinp(i_GTS) == 1)	&& (rdinp(i_READY) == 1) && (rdinp(i_STP) == 1)) 
					position = cons[topf];
			}
			if (  ( (rset == 1) && ((cons[BinPiIn] == 1) || (cons[sel_type] != 0)) )	&&
			   (rdinp(i_UL) == 1) && (procf != 15) )
			{
				procf = 11;
				hsf = 0;
				if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
				{
					setoutp(o_LE);
					setoutp(o_LE1);
				}
			}

  			if ((estop_recovery == 1) && (procf != 15) && ((rdinp(i_UL) == 1) || (rdinp(i_UT)==0)))
			{				  // make sure car can stop at floor level during recovery
				procf = 11;
				hsf = 0;
			}

			if( (Dmd_Velocity < (Pulses_per_Inch * 15.0)) &&   	// less than 75 fpm.
				(fvars[fvbkdroplev] == 1) &&					// early drop selected
				(rdoutp(o_LE) == 1) && 				// leveling is enabled
				(rdinp(i_DZ) == 1) &&						// on door zone
				(hsf == 0) &&									// slowdown
				((procf == 10) || (procf == 15)) )	  			// in leveling mode
			{
				drop_brake(c_drop_brake_timed);
			}
			else
			{
				pick_brake(c_pick_brake_run);
			}
#endif
#if (Tract_OL == 1) 
#endif
#if((Traction == 0) && (Tract_OL == 0))
			if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
			{
				if(timers[tmotion] >= fvars[fvydel])
					setoutp(o_MST);
				else
					clroutp(o_MST);
			}
			if(rdinp(i_DEL) == 0)
				clroutp(o_UP);
			else
				setoutp(o_UP);
#else
			setoutp(o_UP);

#endif

			setoutp(o_RUN);
			setoutp(o_RUNA);
			setoutp(o_MCC);
			setoutp(o_MCA);
			clroutp(o_DNR);
#if (Tract_OL == 0)
			clroutp(o_DF);
#endif
			if(hsf == 1)
			{
				timers[tlant] = 0;
				timers[trlant] = 0;

#if (Traction == 1)
				setoutp(o_UPF);

				if(nstopf == 0)
				{
					if(stops[0] > 0)
					{
						if (((cons[att] == 1) || (cons[att] == 2)) && (servf == 4) && (rdinp(i_ATTBY) == 1) && (firef == 0))
							DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];	   // Attendant bypass
						else if (((cons[Car_Sw] & 1) != 0) && ((rdinp(i_ATTUP) == 1) || (rdinp(i_ATTDN) == 1) ) && (firef == 0))
							DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];	   // Attendant bypass
						else if ((stops[0] == lby_req[cons[carnmb]]) && (stops[0] > position) && (cc_above_lby == 1))
							DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];	   // Bypass the lobby request when above car calls
						else if((stops[0] > position) && (valid_fl[stops[0]] == 1))
							DPP_Target = DPP_Floor_Pos[stops[0]] + DPP_Fl_Offset[stops[0]];
			    	  	else if (valid_fl[position + 1] == 1)
							DPP_Target = DPP_Floor_Pos[(position + 1)] + DPP_Fl_Offset[position + 1];
						else
						{	
							pos = get_valid_fl(position+1,1);
							DPP_Target = DPP_Floor_Pos[pos] + DPP_Fl_Offset[pos];
						}
					}
				}
				if( (DPP_Count >= ((DPP_Floor_Pos[(position + 1)] + DPP_Fl_Offset[position + 1]) - Dist_To_Stop)) &&
					(nstopf == 0) )
				{
					position++;
					if(position > cons[topf])
						position = cons[topf];
//					if ((rdinp(i_UT) == 0) && (safeties() == 1) && (rdinp(i_GTS) == 1)	&& (rdinp(i_READY) == 1) && (rdinp(i_STP) == 1)) 
//						position = cons[topf];
					dirsel();
					if ((valid_fl[position] == 1) || (position >= cons[topf]))
						nstopf = needstop();
					if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
					{
						if (rdinp(i_ATT) == 0)
							nstopf = 1;
					}
					if(nstopf != 0)
						hsf = 0;
					pisout(position);
					stepf = 0;
					timers[tbep] = 0;
					if ((hb_en == 1) && ((valid_fl[position] != 0) || (fvars[fvhbz_nvfl] == 0)) && ((cons[hben] & 0x04) != 0x04))
						handicap_buz = 1;
					if (((DPP_Floor_Pos[position]  + DPP_Fl_Offset[position]) == DPP_Target) && (nstopf == 0))
						nstopf = 1;
					if(nstopf != 0)
					{
						DPP_Target = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
						hsf = 0;
					}
					if (hsf != 0)
						short_fl_run = 0;
				}
#else
#if(Tract_OL == 1)
				if ((timers[tpatdly] >= fvars[fvpat_del]) && (rdinp(i_DEL) == 1))
			    {
					if (no_high_speed == 0)
			    		setoutp(o_UPF);       // Top Speed UPF:B1,DF:B0 = 1,1
			    	setoutp(o_DF);          
				}
				else
				{
			    	clroutp(o_UPF);       // Zero Speed UPF:B1,DF:B0 = 0,0
			    	clroutp(o_DF);          
				}
#else
				if(rdinp(i_DEL) == 0)
					clroutp(o_UPF);
				else if (no_high_speed == 0)
					setoutp(o_UPF);
#endif

				if ( ( ( ((rdinp(i_US) == 1) && ((short_fl_run == 0) || ((cons[shortfl] == 0) && (cons[shortflmid] == 0)))) || 
						    ( ( ((cons[shortfl] != 0) && (position == cons[shortfl]) && (timers[tshortfl] > fvars[fvshort_usdt])) || 
							    ((cons[shortflmid] != 0) && (position == cons[shortflmid])  && (timers[tshortfl] > fvars[fvshortm_usdt]))
							   ) && (short_fl_run == 1) 
							 )
						) && (stepf ==1)
					  ) || (rdinp(i_UT) == 0) 
				    )
				{
					if (stepf ==1)
					{
						position++;
						if(position > cons[topf])
							position = cons[topf];
					}
					if (rdinp(i_UT) == 0)
							hsf = 0;
					dirsel();
					nstopf = needstop();
					if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
					{
						if (rdinp(i_ATT) == 0)
							nstopf = 1;
					}
					pass_fl = 0;
					if(nstopf != 0)
						hsf = 0;
					if ( ( ((position == (cons[shortfl]+1)) && ((fvars[fvshrtflctl] & 0x02) == 0) && (cons[vshort_tfl] == 0))  || 
							((position == (cons[shortflmid]+1)) && ((fvars[fvshrtflctl] & 0x04) == 0)) ) && 
							(hsf == 0) && (short_fl_run == 0))
						pass_fl = 1;					  // very short floor do not pass floor because DTR will change and you won't see the first DZ
					pisout(position);
					stepf = 0;
					timers[tbep] = 0;
					if ((hb_en == 1) && ((valid_fl[position] != 0) || (fvars[fvhbz_nvfl] == 0)) && ((cons[hben] & 0x04) != 0x04))
						handicap_buz = 1;
					timers[tlant] = 0;
					timers[trlant] = 0;
					if (hsf != 0)
						short_fl_run = 0;
				}
				else if ((rdinp(i_US) == 0) && (stepf ==0) && 
					( ((position == cons[shortfl]) && (((fvars[fvshrtflctl] & 0x02) == 0) || (cons[vshort_tfl] != 0))) || 
					  ((position == cons[shortflmid]) && ((fvars[fvshrtflctl] & 0x04) == 0))))
					stepf = 1;
#endif
			}
			else
			{
#if (Tract_OL == 1)
				if ((timers[tpatdly] >= fvars[fvpat_del]) && (rdinp(i_DEL) == 1))
			    {
					clroutp(o_UPF);			// Leveling speed UPF:B1,DF:B0 = 0,1
					setoutp(o_DF);		
				}
				else
				{
			    	clroutp(o_UPF);       // Zero Speed UPF:B1,DF:B0 = 0,0
			    	clroutp(o_DF);          
				}
#else
				clroutp(o_UPF);
#endif
			}
		}
		if(dirf == 2)             // going down
		{
#if (Traction == 1)
			if(rset == 0)           // dont check fault when reseting
			{
				if( (cons[speed] > 1300) &&      // check if switch opens or
				  ( (rdinp(i_DT6)==0) ||   // DPP 42" below it's open point
				  (DPP_Count < (DPP_DT[6] - (int32)(42.0*Pulses_per_Inch))) ) )
				{
					if(DT_Open[6] == 0)               // checking to see if the 4 slowdown
					{                             // is within 42 inches of the table
						if( (DPP_Count < (DPP_DT[6] - (int32)(42.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_DT[6] + (int32)(42.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_DT6_count);
							procf = 11;           // DT5 not in right spot Emergency
						}                           // Slowdown Initiated
						DT_Speed[6] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_DT6)==0) && (DPP_Target > DPP_Count) && (DT_Open[6] == 0) && (procf != 10)) 
					{
					  	record_fault(f_DT6_Target);
						DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    procf = 11;           // DT5 not in right spot Emergency
					}                           // Slowdown Initiated
					DT_Open[6] = 1;
				}
				else
					DT_Open[6] = 0;
				if( (cons[speed] > 1100) &&      // check if switch opens or
				  ( (rdinp(i_DT5)==0) ||   // DPP 32" below it's open point
				  (DPP_Count < (DPP_DT[5] - (int32)(32.0*Pulses_per_Inch))) ) )
				{
					if(DT_Open[5] == 0)               // checking to see if the 4 slowdown
					{                             // is within 32 inches of the table
						if( (DPP_Count < (DPP_DT[5] - (int32)(32.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_DT[5] + (int32)(32.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_DT5_count);
							procf = 11;           // DT5 not in right spot Emergency
						}                           // Slowdown Initiated
						DT_Speed[5] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_DT5)==0) && (DPP_Target > DPP_Count) && (DT_Open[5] == 0) && (procf != 10)) 
					{
					  	record_fault(f_DT5_Target);
						DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    procf = 11;           // DT5 not in right spot Emergency
					}                           // Slowdown Initiated
					DT_Open[5] = 1;
				}
				else
					DT_Open[5] = 0;
				if( (cons[speed] > 900) &&      // check if switch opens or
				  ( (rdinp(i_DT4)==0) ||   // DPP 24" below it's open point
				  (DPP_Count < (DPP_DT[4] - (int32)(24.0*Pulses_per_Inch))) ) )
				{
					if(DT_Open[4] == 0)               // checking to see if the 4 slowdown
					{                             // is within 24 inches of the table
						if( (DPP_Count < (DPP_DT[4] - (int32)(24.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_DT[4] + (int32)(24.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_DT4_count);
							procf = 11;           // DT4 not in right spot Emergency
						}                           // Slowdown Initiated
						DT_Speed[4] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_DT4)==0) && (DPP_Target > DPP_Count) && (DT_Open[4] == 0) && (procf != 10)) 
					{
					  	record_fault(f_DT4_Target);
						DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    procf = 11;           // DT4 not in right spot Emergency
					}                           // Slowdown Initiated
					DT_Open[4] = 1;
				}
				else
					DT_Open[4] = 0;
				if( (cons[speed] > 700) &&      // check if switch opens or
				  ( (rdinp(i_DT3)==0) ||   // DPP 18" below it's open point
				  (DPP_Count < (DPP_DT[3] - (int32)(18.0*Pulses_per_Inch))) ) )
				{
					if(DT_Open[3] == 0)               // checking to see if the 4 slowdown
					{                             // is within 18 inches of the table
						if( (DPP_Count < (DPP_DT[3] - (int32)(18.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_DT[3] + (int32)(18.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_DT3_count);
							procf = 11;           // DT3 not in right spot Emergency
						}                           // Slowdown Initiated
						DT_Speed[3] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_DT3)==0) && (DPP_Target > DPP_Count) && (DT_Open[3] == 0) && (procf != 10)) 
					{
					  	record_fault(f_DT3_Target);
						DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    procf = 11;           // DT3 not in right spot Emergency
					}                           // Slowdown Initiated
					DT_Open[3] = 1;
				}
				else
					DT_Open[3] = 0;
				if( (cons[speed] > 500) &&      // check if switch opens or
				( (rdinp(i_DT2)==0) ||   // DPP 8" below it's open point
				  (DPP_Count < (DPP_DT[2] - (int32)(14.0*Pulses_per_Inch))) ) )
				{
					if(DT_Open[2] == 0)               // checking to see if the 3 slowdown
					{                             // is within 8 inches of the table
						if( (DPP_Count < (DPP_DT[2] - (int32)(14.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_DT[2] + (int32)(14.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_DT2_count);
							procf = 11;           // DT2 not in right spot Emergency
						}                           // Slowdown Initiated
						DT_Speed[2] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_DT2)==0) && (DPP_Target > DPP_Count) && (DT_Open[2] == 0) && (procf != 10)) 
					{
					  	record_fault(f_DT2_Target);
						DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    procf = 11;           // DT2 not in right spot Emergency
					}                           // Slowdown Initiated
					DT_Open[2] = 1;
				}
				else
					DT_Open[2] = 0;
				if( (cons[speed] > 250) &&      // check if switch opens or
				( (rdinp(i_DT1)==0) ||   // DPP 6" below it's open point
				  (DPP_Count < (DPP_DT[1] - (int32)(10.0*Pulses_per_Inch))) ) )
				{
					if(DT_Open[1] == 0)               // checking to see if the 2 slowdown
					{                             // is within 6 inches of the table
						if( (DPP_Count < (DPP_DT[1] - (int32)(10.0*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_DT[1] + (int32)(10.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_DT1_count);
							procf = 11;           // DT1 not in right spot Emergency
						}                           // Slowdown Initiated
						DT_Speed[1] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_DT1)==0) && (DPP_Target > DPP_Count) && (DT_Open[1] == 0) && (procf != 10)) 
					{
					  	record_fault(f_DT1_Target);
						DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    procf = 11;           // DT1 not in right spot Emergency
					}                           // Slowdown Initiated
					DT_Open[1] = 1;
			    }
			    else
				    DT_Open[1] = 0;
				if( ((cons[speed] > 200) || (cons[rsbuffer] == 1)) &&      // check if switch opens or
				( (rdinp(i_DTS)==0) ||   // DPP 6" below it's open point
				  (DPP_Count < (DPP_DTS - (int32)(ETS_Dist*Pulses_per_Inch))) ) )
				{
					if(DTS_Open == 0)               // checking to see if the 2 slowdown
					{                             // is within 6 inches of the table
						if( (DPP_Count < (DPP_DTS - (int32)(ETS_Dist*Pulses_per_Inch))) ||
						(DPP_Count > (DPP_DTS + (int32)(ETS_Dist*Pulses_per_Inch))) )
						{
						  	record_fault(f_DTS_count);
							procf = 11;           // DTS not in right spot Emergency
						}                           // Slowdown Initiated
						DTS_Speed = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
					}
					if ((rdinp(i_DTS)==0) && (DPP_Target > DPP_Count) && (DTS_Open == 0) && (procf != 10)) 
					{
					  	record_fault(f_DTS_Target);
						DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    procf = 11;           // DTS not in right spot Emergency
					}                           // Slowdown Initiated
					DTS_Open = 1;
			    }
			    else
				    DTS_Open = 0;
			    if( (rdinp(i_DT)==0) ||
				(DPP_Count < (DPP_DT[0] - (int32)(10.0*Pulses_per_Inch))) )
			    {
				    if(DT_Open[0] == 0)               // checking to see if the slowdown
				    {                             // is within 4 inches of the table
						if( (DPP_Count < (DPP_DT[0] - (int32)(10.0*Pulses_per_Inch))) ||
						    (DPP_Count > (DPP_DT[0] + (int32)(10.0*Pulses_per_Inch))) )
						{
						  	record_fault(f_DT_count);
							procf = 11;           // DT not in right spot Emergency
						}                           // Slowdown Initiated
						DT_Speed[0] = (int16)((Dmd_Velocity/Vel_Max)*(float)cons[speed]);
				    }
					if ((rdinp(i_DT)==0) && (DPP_Target > DPP_Count) && (DT_Open[0] == 0) && (procf != 10)) 
					{
					  	record_fault(f_DT_Target);
						DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
					    procf = 11;           // DT not in right spot Emergency
					}                           // Slowdown Initiated
				    DT_Open[0] = 1;
			    }
			    else
				    DT_Open[0] = 0;

			}

			if((rset != 0) && (rdinp(i_DT) == 0) && (procf != 15))
			{		  // Car is lost
				procf = 11;
				hsf = 0;
				if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
				{
					setoutp(o_LE);
					setoutp(o_LE1);
				}
				if ((safeties() == 1) && (rdinp(i_GTS) == 1)	&& (rdinp(i_READY) == 1) && (rdinp(i_STP) == 1)) 
					position = cons[bottomf];
			}
			if (  ( (rset == 1) && ((cons[BinPiIn] == 1) || (cons[sel_type] != 0)) )	&&
			   (rdinp(i_DL) == 1) && (procf != 15) )
			{
				procf = 11;
				hsf = 0;
				if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
				{
					setoutp(o_LE);
					setoutp(o_LE1);
				}
			}

			if ((estop_recovery == 1) && (procf != 15) && ((rdinp(i_DL) == 1) || (rdinp(i_DT)==0)))
			{			// make sure car can stop at floor level during recovery
				procf = 11;
				hsf = 0;
			}

			if( (Dmd_Velocity < (Pulses_per_Inch * 15.0)) &&   	// less than 75 fpm.
				(fvars[fvbkdroplev] == 1) &&					// early drop selected
				(rdoutp(o_LE) == 1) && 				// leveling is enabled
				(rdinp(i_DZ) == 1) &&						// on door zone
				(hsf == 0) &&									// slowdown
				((procf == 10) || (procf == 15)) )	  			// in leveling mode
			{
				drop_brake(c_drop_brake_timed);
			}
			else
			{
				pick_brake(c_pick_brake_run);
			}
#endif

#if (Tract_OL == 1) 
			pick_brake(c_pick_brake_run);
#endif

			setoutp(o_RUN);
			setoutp(o_RUNA);

#if((Traction == 0)	&& (Tract_OL == 0))

			setoutp(o_DNR);
			clroutp(o_MCC);
			clroutp(o_MCA);
			if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
				clroutp(o_MST);
			
#else
			setoutp(o_DNR);

		  	setoutp(o_MCC);    // Turn on motor starter output
			setoutp(o_MCA);
#endif
			clroutp(o_UP);
#if(Tract_OL == 0)
			clroutp(o_UPF);
#endif
			if(hsf == 1)
			{
		     	timers[tlant] = 0;
		     	timers[trlant] = 0;
#if (Traction == 1)
			  	setoutp(o_DF);
			  	
			  	if(nstopf == 0)
			  	{
			  	  	if(stops[0] > 0)
			  	  	{
						if (((cons[att] == 1) || (cons[att] == 2)) && (servf == 4) && (rdinp(i_ATTBY) == 1) && (firef == 0))
							DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];	   // Attendant bypass
						else if (((cons[Car_Sw] & 1) != 0) && ((rdinp(i_ATTUP) == 1) || (rdinp(i_ATTDN) == 1) ) && (firef == 0))
							DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];	   // Attendant bypass
			    	  	else if((stops[0] < position) && (valid_fl[stops[0]] == 1))
							DPP_Target = DPP_Floor_Pos[stops[0]] + DPP_Fl_Offset[stops[0]];
			    	  	else if (valid_fl[position - 1] == 1)
							DPP_Target = DPP_Floor_Pos[(position - 1)] + DPP_Fl_Offset[(position - 1)];
						else
						{
							pos = get_valid_fl(position-1,2); 
							DPP_Target = DPP_Floor_Pos[pos] + DPP_Fl_Offset[pos];
						}	   
			  	  	}
			  	}
			  	if( (DPP_Count <= ((DPP_Floor_Pos[(position - 1)] + DPP_Fl_Offset[position - 1]) + Dist_To_Stop)) &&
			      (nstopf == 0) )
			  	{
			     	position--;
			     	if(position < cons[bottomf])
			     	  	position = cons[bottomf];
//					if ((rdinp(i_DT) == 0) && (safeties() == 1) && (rdinp(i_GTS) == 1)	&& (rdinp(i_READY) == 1) && (rdinp(i_STP) == 1)) 
//			     	  	position = cons[bottomf];
			     	dirsel();
				 	if ((valid_fl[position] == 1) || (position <= cons[bottomf]))
			     		nstopf = needstop();
					if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
					{
						if (rdinp(i_ATT) == 0)
							nstopf = 1;
					}
			     	if(nstopf != 0)
			     	  	hsf = 0;
			     	pisout(position);
			     	stepf = 0;
			     	timers[tbep] = 0;
			     	if ((hb_en == 1) && ((valid_fl[position] != 0) || (fvars[fvhbz_nvfl] == 0)) && ((cons[hben] & 0x04) != 0x04))
						handicap_buz = 1;
			     	if (((DPP_Floor_Pos[position] + DPP_Fl_Offset[position]) == DPP_Target) && (nstopf == 0))
			     	  	nstopf = 1;
			     	if(nstopf != 0)
			     	{
			     	  	DPP_Target = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
			     	  	hsf = 0;
			     	}
					if (hsf != 0)
						short_fl_run = 0;
			  	}
#else
#if(Tract_OL == 1)
				if ((timers[tpatdly] >= fvars[fvpat_del]) && (rdinp(i_DEL) == 1))
			    {
					if (no_high_speed == 0)
			    		setoutp(o_UPF);       // Top Speed UPF:B1,DF:B0 = 1,1
			    	setoutp(o_DF);          
				}
				else
				{
			    	clroutp(o_UPF);       // Zero Speed UPF:B1,DF:B0 = 0,0
			    	clroutp(o_DF);          
				}
#else
				if (no_high_speed == 0)
			  		setoutp(o_DF);
#endif
				if ( ( ( ((rdinp(i_DS) == 1) && ((short_fl_run == 0) || ((cons[shortfl] == 0) && (cons[shortflmid] == 0)))) || 
						    ( ( ((cons[shortfl] != 0) && (position == (cons[shortfl]+1)) && (timers[tshortfl] > fvars[fvshort_dsdt])) || 
							    ((cons[shortflmid] != 0) && (position == (cons[shortflmid]+1)) && (timers[tshortfl] > fvars[fvshortm_dsdt]))
							   ) && (short_fl_run == 1) 
							 )
						) && (stepf ==1)
					  ) || (rdinp(i_DT) == 0) 
				    )
			  	{
				 	if (stepf ==1)
			     	{
			     		position--;
			     		if(position < cons[bottomf])
			     	  		position = cons[bottomf];
			     	}
					if (rdinp(i_DT) == 0) 
			     	  	hsf = 0;
			     	dirsel();
			     	nstopf = needstop();
					if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
					{
						if (rdinp(i_ATT) == 0)
							nstopf = 1;
					}
					pass_fl = 0;
			     	if(nstopf != 0)
			     	  	hsf = 0;
					if (( ((position == cons[shortfl]) && ((fvars[fvshrtflctl] & 0x02) == 0) && (cons[vshort_tfl] == 0)) || 
							((position == cons[shortflmid]) && ((fvars[fvshrtflctl] & 0x04) == 0))) && 
							(hsf == 0) && (short_fl_run == 0))
						pass_fl = 1;						// very short floor do not pass floor because DTR will change and you won't see the first DZ
			     	pisout(position);
			     	stepf = 0;
			     	timers[tbep] = 0;
			     	if ((hb_en == 1) && ((valid_fl[position] != 0) || (fvars[fvhbz_nvfl] == 0)) && ((cons[hben] & 0x04) != 0x04))
						handicap_buz = 1;
			     	timers[tlant] = 0;
			     	timers[trlant] = 0;
					if (hsf != 0)
						short_fl_run = 0;
			  	}
				else if ((rdinp(i_DS) == 0) && (stepf ==0) && 
					(((position == (cons[shortfl]+1)) && (((fvars[fvshrtflctl] & 0x02) == 0) || (cons[vshort_tfl] != 0))) || 
					 ((position == (cons[shortflmid]+1)) && ((fvars[fvshrtflctl] & 0x04) == 0)) ))
					stepf = 1;
#endif
			}
			else
			{
#if (Tract_OL == 1)
				if ((timers[tpatdly] >= fvars[fvpat_del]) && (rdinp(i_DEL) == 1))
			    {
					clroutp(o_UPF);			// Leveling speed UPF:B1,DF:B0 = 0,1
					setoutp(o_DF);		
				}
				else
				{
			    	clroutp(o_UPF);       // Zero Speed UPF:B1,DF:B0 = 0,0
			    	clroutp(o_DF);          
				}
#else
			  	clroutp(o_DF);
#endif
			}
      	}
    }
  }
  up_peak_trigger = 0;		 // This flag is set only while the car is moving
  return;
}

// *******************************************************
// This procedure checks to see if there is a need to stop
// *******************************************************
int16 needstop()
{
	int16 fl_ix;

	fl_ix = (position-1)/32;

//	front_slowdown = 0;
//	rear_slowdown = 0;
	allow_run = 0;

	if (((fvars[fvstplby] & 0x04) != 0) && (position == lobby_fl))
	{
		if (((dirf == 2) && ((fvars[fvstplby] & 0x02) != 0)) ||
			((dirf == 1) && ((fvars[fvstplby] & 0x01) != 0)))
			front_slowdown |= (cc_sd | cc_do);
	}

  	if((carcb[position] == 1) && ((((firef == 0) || (hsvf == 1)) && (( empf == no_ep) || (empf == ep_select))) || (firef >= 4)) )
		front_slowdown |= (cc_sd | cc_do);

  	if(cons[rear] != 0)
  	{
	  	if((rcarcb[position] == 1) && ((((firef == 0) || (hsvf == 1)) && (( empf == no_ep) || (empf == ep_select))) || (rfiref >= 4)) )
	    	rear_slowdown |= (cc_sd | cc_do);
	}

	if (((cons[att] == 1) || (cons[att] == 2)) && (servf == 4) && (rdinp(i_ATTBY) == 1) && (firef == 0))
		bypass_hc = 1;		// Okay to bypass hall calls
	else
		bypass_hc = 0;

	if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
	{
		bypass_hc = 1;		// Okay to bypass hall calls
		if ((rdinp(i_ATTUP) == 0) &&
			(rdinp(i_ATTDN) == 0))
			front_slowdown = (cc_sd | cc_do);
	}

  	if( (dpref == 1) && (upcb[position] == 1) && (firef == 0) && (bypass_hc == 0) && (( empf == no_ep) || (empf == ep_select)))
	{
    	front_slowdown |= (uc_sd | uc_do);
		if ((g_irup_hall_call[fl_ix][cons[carnmb]] & fl_mask[position]) != 0)
			front_slowdown |= iruc_sd;
  	}
  	if( (dpref == 2) && (downcb[position] == 1) && (firef == 0) && (bypass_hc == 0) && (( empf == no_ep) || (empf == ep_select)))
	{
    	front_slowdown |= (dc_sd | dc_do);
		if ((g_irdn_hall_call[fl_ix][cons[carnmb]] & fl_mask[position]) != 0)
			front_slowdown |= irdc_sd;
	}
  	if(cons[rear] != 0)
  	{
	  	if( (dpref == 1) && (rupcb[position] == 1) && (firef == 0) && (bypass_hc == 0) && (( empf == no_ep) || (empf == ep_select)))
		{
	    	rear_slowdown |= (uc_sd | uc_do);
			if ((g_rirup_hall_call[fl_ix][cons[carnmb]] & fl_mask[position]) != 0)
				rear_slowdown |= iruc_sd;
	  	}
	  	if( (dpref == 2) && (rdowncb[position] == 1) && (firef == 0) && (bypass_hc == 0) && (( empf == no_ep) || (empf == ep_select)))
		{
	    	rear_slowdown = (dc_sd | dc_do);
			if ((g_rirdn_hall_call[fl_ix][cons[carnmb]] & fl_mask[position]) != 0)
				rear_slowdown |= irdc_sd;
	  	}
  	}

  	if((rdinp(i_UT) == 0) && (dirf == 1) && ((cons[shortfl] < (cons[topf]-1)) || (hsf != 0)))
    	return(1);
  	if((rdinp(i_DT) == 0) && (dirf == 2) && ((cons[shortfl] != cons[bottomf]) || (hsf != 0)))
    	return(1);
	if ((toc_can_error == 1) || (spb_can_error == 1) || (BKS_Run_Fault == 1) ||
		((brk_can_error == 1) && ((cons[brake] == 2) || (cons[brake] == 3))) ||
		((ebrk_can_error == 1) && ((cons[brake] == 2) || (cons[brake] == 3)) && ((cons[EM_BRK] == 6) || (cons[Aux_Brake] == 1) || (cons[EM_BRK] == 7))) || 
		((sel_can_error == 1) && (cons[sel_type] == 2)) ||
		(((can_enc_com_err == 1) || (can_enc_init == 0) || (EncCan_Upd == 1)) && (cons[sel_type] == 3)) || 
		((cons[Voltage_Sensor] == 1) && (voltf != 0)) )
		return(1);					// Stop at next floor if toc comm error
  	if((position == cons[topf]) && (dirf == 1))
    	return(1);
  	if((position == cons[bottomf]) && (dirf == 2))
    	return(1);
  	if(rset != 0)
    	return(0);
  	if(dirf == 0)
    	return(1);

  	if(cons[equake] != 0)                 // is earth quake feature enabled
	{
		if ((eqf != 0) || (servf == 8))
			return (1);
	}

#if ((Traction == 0) && (Tract_OL == 0))
	// Hydro
	if (empf != no_ep)
	{
		if ((cons[EMPop] & 0x02) == 0)
		{
			if (dirf == 1)
				return(1);		// cannot run up on emergency power loweriing
			else if (firef == 0)
				return(0);		// not on fire so continue running down
		}
	}
#endif
	if (medf != 0)
	{
		if (medf == 1)
		{
      		if( ((dirf == 1) && (fvars[fvmedfl] <= position)) ||
	  		((dirf == 2) && (fvars[fvmedfl] >= position)) )
	  			return(1);
		}
  	}
  	else if ((firef == 1) && (hsvf == 0))                // On fireservice phase 1 return to main
  	{	
      	if( ((dirf == 1) && (fvars[fvfs1f] <= position)) ||
	  	((dirf == 2) && (fvars[fvfs1f] >= position)) )
	  		return(1);
  	}
  	else if ((firef == 2) && (hsvf == 0))                // On fireservice phase 1 return to alternate
  	{
      	if( ((dirf == 1) && (fvars[fvfs1af] <= position)) ||
	  	((dirf == 2) && (fvars[fvfs1af] >= position)) )
	  		return(1);
  	}
#if ((Traction == 1) || (Tract_OL == 1))
  	else if (empf == ep_recall) 	// First on Emergency power or during EP recall
	{
      	if( ((dirf == 1) && (fvars[fvepfl] <= position)) ||
	  	((dirf == 2) && (fvars[fvepfl] >= position)) )
	  		return(1);
	}
	else if ((empf != no_ep) && (empf != ep_select))
		return(1);		// if not selected to run the stop the car
#else
	if ((cons[EMPop] & 0x02) != 0)
  	{
  		if (empf == ep_recall) 	// First on Emergency power or during EP recall
		{
	      	if( ((dirf == 1) && (fvars[fvepfl] <= position)) ||
		  	((dirf == 2) && (fvars[fvepfl] >= position)) )
		  		return(1);
		}
		else if ((empf != no_ep) && (empf != ep_select))
			return(1);		// if not selected to run the stop the car
	}
#endif

	if ((front_slowdown != 0) || (rear_slowdown != 0))
		return(1);

  	if( (position == lby_req[cons[carnmb]]) && (servf == 1) && (dpref == 1) && (firef == 0) )
	{		// at the lobby request floor
		if ((cc_above_lby == 0) || (dirf == 2))
    		return(1);		// allow to stop if no car call above the lobby or moving down
	}
  	if( (position == g_park[cons[carnmb]]) && (servf == 11) )
    	return(1);
  	if( (position == zone_fl) && (servf == 18) )		// Calibrate load weigher
    	return(1);
  	if((dirf == 1) && ((dcalls & 0x01) == 0))
    	return(1);          //absence of a call going up
  	if((dirf == 2) && ((dcalls & 0x02) == 0))
    	return(1);          //absence of a call going down
  	return(0);
}
// *****************************************
// This is the position indicator procedure
// *****************************************
void pisout(int16 pos)
{
	int16 pi_pos = 1;

	if ((valid_fl[pos] == 0) && (fvars[fvhbz_nvfl] == 1))
		return;

	if ((cons[F1_CT] == 1) && ((cons[sercom] & 0x04) != 0) && ((cons[loadw] !=0) || (cons[equake] == 1) || (cons[medEm] == 1) || (cons[F1_ML_AL] == 1) || (cons[cblue] == 1)|| (cons[hugs] != 0))) 
		return;

	if (cons[Xref_PI_Pos] == 1)
		pi_pos = xpi_pos[pos];
	else
		pi_pos = pos;

	if ((cons[dispis] & 0x01) != 0)
	{
	  	if (pi_pos == 1)
			setoutp(o_DPI1);
	  	else
			clroutp(o_DPI1);

	  	if (pi_pos == 2)
			setoutp(o_DPI2);
	  	else
			clroutp(o_DPI2);

	  	if (pi_pos == 3)
			setoutp(o_DPI3);
	  	else
			clroutp(o_DPI3);

	  	if (pi_pos == 4)
			setoutp(o_DPI4);
	  	else
			clroutp(o_DPI4);

		if ((cons[exDHwL] == 1) || ((cons[vshort_tfl] != 0) && (cons[StagRear] == 1)))
			return;		// Dont use P5 and P6 if P5 is being used for EDL

	  	if (pi_pos == 5)
			setoutp(o_DPI5);
	  	else
			clroutp(o_DPI5);

		if (cons[StagRear] == 1)
			return;

	  	if (pi_pos == 6)
			setoutp(o_DPI6);
	  	else
			clroutp(o_DPI6);
	}
	else
	{
	  	if((pi_pos & 0x01) != 0)
			setoutp(o_DPI1);
	  	else
			clroutp(o_DPI1);

	  	if((pi_pos & 0x02) != 0)
			setoutp(o_DPI2);
	  	else
			clroutp(o_DPI2);

	  	if((pi_pos & 0x04) != 0)
			setoutp(o_DPI3);
	  	else
			clroutp(o_DPI3);

	  	if((pi_pos & 0x08) != 0)
			setoutp(o_DPI4);
	  	else
			clroutp(o_DPI4);

		if ((cons[exDHwL] == 1) || ((cons[vshort_tfl] != 0) && (cons[StagRear] == 1)))
			return;		// Dont use P5 and P6 if P5 is being used for EDL

      	if((pi_pos & 0x10) != 0)
			setoutp(o_DPI5);
	  	else
			clroutp(o_DPI5);

		if (cons[StagRear] == 1)
			return;

      	if((pi_pos & 0x20) != 0)
			setoutp(o_DPI6);
	  	else
			clroutp(o_DPI6);
	}
		
		
	return;
}

//*********************************************
// Print screen dummy routine
//*********************************************

void prt_scr(void)
{
	ps_int_cnt++;
//  	outp(0x20,0x20);      	// Send EOI since old int 9 was not called
}


#if (debug_io_enable == 1)

//*********************************************
// write dbg info to FC
//*********************************************

int writedbgtoFC(uint32 value)
{

	static char mystring[51];
	static int index;
	static int file_created;
	static int file_size;
	
	FILE *fp1 = NULL;
	local_gettime();
	local_getdate(cpu_Z6);

	if(file_created == 0)
	{
		index++;
		file_created = 1;
		fp1 = fopen("c:debug.txt","wb");
		fputs("DEBUG INFO",fp1);
		fputc(CR,fp1);
		fputc(LF,fp1);
		fputc(CR,fp1);
		fputc(LF,fp1);
		sprintf(mystring,"hex %06x   flt %03d  Time %02d-%02d %02d:%02d:%02d",value,index,d.month,d.day,t.hour,t.minute,t.second);
		fputs(mystring,fp1);
		fputc(CR,fp1);
		fputc(LF,fp1);
		fclose(fp1);
	}
	else
	{
		if(file_size == 0)
		{
			fp1 = fopen("c:debug.txt","a");
			fseek(fp1,0,SEEK_END);
			file_size = (unsigned int) ftell(fp1);
			fclose(fp1);			
			return 1;
		}
		if(file_size>65535)
		{
			return 2;
			file_size = 0;
		}
		index++;
		fp1 = fopen("c:debug.txt","a");
		fputc(CR,fp1);
		fputc(LF,fp1);
		sprintf(mystring,"hex %06x   flt %03d  Time %02d-%02d %02d:%02d:%02d fsize %d",value,index,d.month,d.day,t.hour,t.minute,t.second,file_size);
		file_size = 0;
		fputs(mystring,fp1);
		fputc(CR,fp1);
		fputc(LF,fp1);
		fclose(fp1);

	}
	return 0;

}

#endif


//*********************************************
// Record fault routine
//*********************************************

void record_fault (uint16 code)
{
/*
#if ((TS5300 == 1) || (TS3300 == 1))
	outp(DIO2_port,DIO2_out |= 0x10);
#endif
*/
	if (code > max_nmbflts)
		return;
	if ((code == fvars[fvexcflt1]) || (code == fvars[fvexcflt2])|| (code == fvars[fvexcflt3])
		|| (code == fvars[fvexcflt4])|| (code == fvars[fvexcflt5])|| (code == fvars[fvexcflt6]))
	{
		return;
	}
	
#if (debug_io_enable == 1)

	if(code == fvars[fvexcflt1])
	{
	 debug_io_4 = debug_io_3;
	 debug_io_3 = debug_io_2;
	 debug_io_2 = debug_io_1; 
	 lb[0] = iodata[1][18];
	 lb[1] = iodata[1][19];
	 lb[2] = iodata[1][20];
	 lb[3] = 0;
	 debug_io_1 = ll;
	 rqst_dbgtoFC = 1;
	}
#endif

	
	Current_Fault = code;
   	timers[tfltled] = 0;
	local_getdate(cpu_Z6);
	local_gettime();
	if (f.Flts[Flt_ix].code == code) 
		f.Flts[Flt_ix].count++;
	else
	{
		if (Flt_ix >= (max_flt_ix-1))
			Flt_ix = 0;
		else
			Flt_ix++;

		f.Flts[Flt_ix].count = 1;
		f.Flts[Flt_ix].code = code;
		f.Flts[Flt_ix].day = d.day;
		f.Flts[Flt_ix].mon = d.month;
		f.Flts[Flt_ix].year = d.year;
		f.Flts[Flt_ix].min = t.minute;
		f.Flts[Flt_ix].hour = t.hour;
		f.Flts[Flt_ix].sec = t.second;
		f.Flts[Flt_ix].pos = (uint8)position;
		f.Flts[Flt_ix].servf = (uint8)servf;
		f.Flts[Flt_ix].procf = (uint8)procf;
		f.Flts[Flt_ix].doorf = (uint8)doorf;
		f.Flts[Flt_ix].rdoorf = (uint8)rdoorf;
		f.Flts[Flt_ix].dpref = (uint8)dpref;
		f.Flts[Flt_ix].dirf = (uint8)dirf;
		f.Flts[Flt_ix].empf = (uint8)empf;
		f.Flts[Flt_ix].medf = (uint8)medf;
		f.Flts[Flt_ix].codebf = (uint8)codebf;
		f.Flts[Flt_ix].eqf = (uint8)eqf;
		f.Flts[Flt_ix].firef = (uint8)firef;
		f.Flts[Flt_ix].rfiref = (uint8)rfiref;
		f.Flts[Flt_ix].hsf = (uint8)hsf;
		f.Flts[Flt_ix].startf = (uint8)startf;
		f.Flts[Flt_ix].dcalls = (uint8)dcalls;
		f.Flts[Flt_ix].estop = (uint8)estop;
		f.Flts[Flt_ix].nstopf = (uint8)nstopf;
		f.Flts[Flt_ix].relevel = (uint8)relevel;
		f.Flts[Flt_ix].stepf = (uint8)stepf;
		f.Flts[Flt_ix].predof = (uint8)predof;
		f.Flts[Flt_ix].stops0 = (uint8)stops[0];
		f.Flts[Flt_ix].ins_status = (uint8)ins_status;
		f.Flts[Flt_ix].ncu_door_seq = (uint8)ncu_door_seq;

		if (fault_device != 0)
		{
			f.Flts[Flt_ix].device = (uint8)fault_device;
			fault_device = 0;
		}
		else
			f.Flts[Flt_ix].device = 0;

		if (fault_prog_flag1 != 0)
		{
			f.Flts[Flt_ix].prog_flag1 = (uint8)fault_prog_flag1;
			fault_prog_flag1 = 0;
		}
		else
			f.Flts[Flt_ix].prog_flag1 = 0;

		if (fault_prog_flag2 != 0)
		{
			f.Flts[Flt_ix].prog_flag2 = (uint8)fault_prog_flag2;
			fault_prog_flag2 = 0;
		}
		else
			f.Flts[Flt_ix].prog_flag2 = 0;

		if (fault_device_2 != 0)
		{
			f.Flts[Flt_ix].device_2 = (uint8)fault_device_2;
			fault_device_2 = 0;
		}
		else
			f.Flts[Flt_ix].device_2 = 0;

		f.Flts[Flt_ix].iodata[0] = iodata[1][0];
		f.Flts[Flt_ix].iodata[1] = iodata[1][1];
		f.Flts[Flt_ix].iodata[2] = iodata[1][2];
		f.Flts[Flt_ix].iodata[3] = iodata[1][4];
		f.Flts[Flt_ix].iodata[4] = iodata[1][5];
		f.Flts[Flt_ix].iodata[5] = iodata[1][6];
		f.Flts[Flt_ix].iodata[6] = iodata[1][7];
		f.Flts[Flt_ix].iodata[7] = iodata[1][9];
		f.Flts[Flt_ix].iodata[8] = iodata[1][10];
		f.Flts[Flt_ix].iodata[9] = iodata[1][12];
		f.Flts[Flt_ix].iodata[10] = iodata[1][13];
		f.Flts[Flt_ix].iodata[11] = iodata[1][72];
		f.Flts[Flt_ix].iodata[12] = iodata[1][73];
		f.Flts[Flt_ix].iodata[13] = iodata[1][74];
		f.Flts[Flt_ix].statusf = statusf;
	#if (Traction == 1)
		f.Flts[Flt_ix].dpp_count = DPP_Count;
		f.Flts[Flt_ix].dpp_target = DPP_Target;
		f.Flts[Flt_ix].velocity = Dmd_Velocity;
		f.Flts[Flt_ix].enc_vel = Enc_vel;
		f.Flts[Flt_ix].SPB_service = SPB_can.service;
		f.Flts[Flt_ix].SPB_status = SPB_can.status;
		f.Flts[Flt_ix].SPB_vel = SPB_can.velocity;
		f.Flts[Flt_ix].SPB_poscnt = SPB_can.poscnt;
	#endif
		Up_Date_Flt(0, cpu_Z6);
		Up_Date_LT_Flt(cpu_Z6);
	}
/*
#if ((TS5300 == 1) || (TS3300 == 1))
	outp(DIO2_port,DIO2_out &= (~0x10));
#endif
*/
}


//***************************
// Elevator is in Reset Mode
//***************************
void reset()
{
	int16 start_time;
  	int16 tmppos = 0;
	int16 call_at_fl = 0;

	int16 recover_dir = 2;
  	if(rset != 3)
	  	rset = 1;
// Wait in reset until treset tim has expired
  	doorf = 0;
	rdoorf = 0;
	clr_door_vars();
	preset = 0;
	in_pfc_sfc_test = 0;
	SPB_can.command &= ~spbc_GR1_test;			// Clear GR1 test
	SPB_can.command &= ~spbc_SFC_test;			// Clear SFC test
	pfc_sfc_test = 0;
	timers[trelev] = 0;
	timers[tebrkio] = 0;

#if(Traction == 0)
  	timers[trst] = 0;
#endif
#if ((Traction == 1) || (Tract_OL == 1))
	if (cons[ansi] >= 2000)
	{
		if (rdinp(i_GTS) == 1)
			start_time = 0;		  // Gripper is already picked
		else
			start_time = fvars[fvgriprst];
	}
	else
		start_time = 0;

	if ((Drive_Type[cons[carnmb]] == 4) || (Drive_Type[cons[carnmb]] == 7))
		start_time += (cons[carnmb] - 1) * 20;		// add 2 seconds for each car
#else
	start_time = 0;		// not a generator job
	if (Drive_Type[cons[carnmb]] == 9)
		setoutp(o_MST);
#endif
	timers[tydel] = 0;			// reset timer for y-deta start

	start_time += power_up_start_time;		// power up start time is non zero only on power up
	power_up_start_time = 0;

#if ((Traction == 1) || (Tract_OL == 1))

	if (cons[ansi] >= 2000)
	{
		if (gripper_fault != 0)
		{
			clroutp(o_GR1R);
			clroutp(o_GR2R);
			clroutp(o_LE);
			clroutp(o_LE1);
			if ((cons[EM_BRK] == 3) || (cons[EM_BRK] == 5))
				clroutp(o_UTM);
			SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
		}
		else
		{
			// Pick the rope gripper
			setoutp(o_GR1R);
			setoutp(o_GR2R);
			if ((cons[EM_BRK] == 3) || (cons[EM_BRK] == 5))
				setoutp(o_UTM);
 			SPB_can.command |= spbc_reset_umotion;			// reset unintended motion fault
			gripper_test = 0;
		}
	}
	else

	{
		setoutp(o_GR1R);
		setoutp(o_GR2R);
		if ((cons[EM_BRK] == 3) || (cons[EM_BRK] == 5))
			setoutp(o_UTM);
 		SPB_can.command |= spbc_reset_umotion;			// reset unintended motion fault
		gripper_test = 0;
	}
#endif		
	
	if (cons[Cycle_Run] == 1) 
	{
		day_st = (int16)(rt_day + (rt_hour + fvars[fvcycrun]) / 24);
		if (day_st > 364)
			day_st -= 364;
		hour_st = (int16)((rt_hour + fvars[fvcycrun]) % 24);
		minute_st = rt_minute;
		prev_minute = rt_minute;
	}

	if ((manual_door == 2) && (man_dcc() == 1))
	{			// clear the protection time to allow the car door to close
		timers[tdc] = 0;
	}
	if ((manual_rdoor == 2) && (man_dcc() == 1))
	{			// clear the protection time to allow the car door to close
		timers[trdc] = 0;
	}

	timers[thyreset] = 0;

	SPB_can.command |= spbc_imm_pos_upd;  // Request immidiate read so that SEL_Count_Valid gets set

	while(timers[treset] <= (fvars[fvrst] + start_time))
  	{
#if((Traction == 0) && (Tract_OL == 0))
    	if((timers[trst] < 15) && (cons[arst] != 0))
			setoutp(o_RST);
    	else
			clroutp(o_RST);
#endif


		if (rdinp(i_GOV) == 1)
			gov_flt_timer = 0;		// prevent gripper trip during reset.
//			gripper_flt_timer = 0;		// prevent gripper trip during reset.

		if (cons[Australia] == 1)
		{
			fs2_on = (rdinp(i_FS2) == 0) || (rdinp(i_FS2H) == 1);
			fs2_hold = 0;
			fs2_start = (rdinp(i_FS2H) == 1);
		}
		else
		{
			if (cons[FS2_SW] == 1)	// New logic FS2 = NOT FS2 and NOT FS2H, HOLD = FS2H, OFF = FS2
				fs2_on = (rdinp(i_FS2) == 0) && (rdinp(i_FS2H) == 0);
			else					// Original logic FS2 = FS2 input, HOLD = FS2H, OFF = NOT FS2 and NOT FS2H
				fs2_on = (rdinp(i_FS2) == 1);
			fs2_hold = (rdinp(i_FS2H) == 1);
			fs2_start =0;
		}
    	inctime(0);
    	clrall();
		if (procf == 20)
			return;
  	}

	statusf &= ~sf_POS;

#if((Traction == 0) && (Tract_OL == 0))
  	clroutp(o_RST);
#endif

	closetry = 0;
	rclosetry = 0;
	safe_closetry = 0;
	safe_rclosetry = 0;
	Door_Lock_Fault = 0;
	Overspeed_Test = 0;
	Buffer_Test = 0;
	estop = 0;
    estops_1_run = 0;
	timers[tgripper] = 0;
	ins_fault = 0;

#if((Traction == 1) || (Tract_OL == 1))
	if (cons[ansi] >= 2000)
	{
		if ((rdinp(i_GTS) == 0) && (safeties() == 1) && (gripper_fault == 0))
		{
//			gripper_fault = 1;
			if (cons[EM_BRK] != 0)
	  			record_fault(f_utm_gts_flt);
			else
	  			record_fault(f_gts_pick);
			setoutp(o_GR1R);		// try again to pick the gripper
			setoutp(o_GR2R);
			if ((cons[EM_BRK] == 3) || (cons[EM_BRK] == 5))
				setoutp(o_UTM);
	 		SPB_can.command |= spbc_reset_umotion;			// reset unintended motion fault
			procf = 0;		// cause another reset delay
			
		}
	}

#endif


#if ((Traction == 0) && (Tract_OL == 0))
	if (cons[Low_Press] == 1)
	{
		if (((rdinp(i_LPS) == 1) && 
			(fvars[fvlps] == 0)) || ((rdinp(i_LPS) == 0) && (fvars[fvlps] == 1)))
		{
			procf = 19;
			return;
		}
	}
#endif

	// Testing to see if saftey string is open
    if(safeties() == 0)
    {
		if ((statusf & sf_SS) == 0)
	  		record_fault(f_sstring);
		statusf |= sf_SS;
      	procf = 12;       // go to saftey string open mode
      	timers[tmotion] = 0;
		timers[tpatdly] = 0;
      	return;
    }
	else
		statusf &= ~sf_SS;

	// Testing to see if LC fuse is blown
	if(rdinp(i_LC) == 0)
    {
		if ((statusf & sf_LC) == 0)
		  	record_fault(f_LC_fuse);
		statusf |= sf_LC;
		procf = 12;
		timers[tmotion] = 0;
		timers[tpatdly] = 0;
		return;
    }
	else
		statusf &= ~sf_LC;

#if((Traction == 1) || (Tract_OL == 1))

	// Testing to see if the ready from the Drive is open
	if((rdinp(i_READY) == 0) && (rdinp(i_GTS) == 1))
    {
		if ((statusf & sf_READY) == 0)
	  		record_fault(f_drive_rdy);
		statusf |= sf_READY;
      	procf = 12;       // go to saftey string open mode
      	timers[tmotion] = 0;
		timers[tpatdly] = 0;
      	return;
    }
	else
		statusf &= ~sf_READY;
#endif

	// Testing to see if on inspection
    if(chk_ins() == 1)
    {
      	procf = 2;        // go to inspection mode
      	timers[tmotion] = 0;
		timers[tpatdly] = 0;
      	return;
    }

	if (rset_error_cnt < 5)
	{
		rset_error_cnt++;
		record_fault(f_reset);
	}
	

#if(Traction == 1)
	// Make sure the motor field is not at full field
    if(timers[tff] > 40)
		clroutp(o_FF);
//	clroutp(o_FW);
#endif

	if (rdinp(i_STP) == 0)
	{
		statusf |= sf_STP;
		rset_run_cnt = 0;
		return;		// cannot do anything until stop switch is set to run
	}
	else
		statusf &= ~sf_STP;


#if (Traction == 1)
	if (((cons[sel_type] == 1) || (cons[sel_type] == 2)) && (spb_can_error == 0))
	{
		if (Hoistway_Learned == 1)
		{
			if (SEL_Count_Valid == 0)
			{
				record_fault(f_SEL_Cnt_fault);
				procf = 0;		// cause another reset delay
	    	}
	    	if((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))      // dead level
			{
				if (rdinp(i_UT) == 0)
				{
					SPB_can.command |= spbc_init_pos;
					SEL_Preset_Count = SEL_Top_Count;
				}
				else if (rdinp(i_DT) == 0)
				{
					SPB_can.command |= spbc_init_pos;
					SEL_Preset_Count = SEL_Bottom_Count;
				}
			}
		}			
	}
#endif


//	if ((((firef == 1) && (position == fvars[fvfs1f])) ||
//	     ((firef == 2) && (position == fvars[fvfs1af])) ||
//	      (firef == 3) ) &&  )
//		;	// skip door close section
	if ((rdinp(i_DZ) == 0) || ((rset == 3) && (eqf == 0)))
	{						  // Not on the door zone so Close the doors
		close_doors_during_reset(0);
	}


	if (((manual_door == 2) || (manual_rdoor == 2)) && (man_dcc() == 0))
	{
		statusf |= sf_DCC;
		rset_run_cnt = 0;
		return;		// cannot do anything until the outside swing door is closed and not in door zone
	}
	else
		statusf &= ~sf_DCC;

  	timers[tmotion] = 0;
	timers[tpatdly] = 0;
	timers[tfault] = 0;


#if(Traction == 1)
	if ((drive_online == 0) && ((cons[sercom] & 8) != 0))
	{
		rset_run_cnt = 0;
		procf = 0;		// cause another reset delay
		return;
	}
#endif

	// Make sure elevator not lost
  	if ( (rdinp(i_DT) == 0) && (cons[shortfl] != cons[bottomf]))
  	{     // elevator at bottom but position does not match
    	position = cons[bottomf];
    	if((rdinp(i_UL) == 1) || (rdinp(i_DL) == 1))
     	// at the bottom floor on a door zone
    	{
#if(Traction == 1)
      		DPP_Count = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
			old_dpp = DPP_Count;
			init_encoder_count(DPP_Count);	   // Only occurs during a reset at the top or bottom floor
      		Velocity = 0;
			Dmd_Velocity = 0;
#endif
			set_door_close_during_reset();
      		procf = 15;
      		return;
    	}
  	}

  	if ( (rdinp(i_UT) == 0) && (cons[shortfl] < (cons[topf]-1)))
  	{	  // Car is at the top 
    	position = cons[topf];
    	if((rdinp(i_UL) == 1) || (rdinp(i_DL) == 1)) // at the top floor on a door zone
    	{	   
#if(Traction == 1)
      		DPP_Count = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
			old_dpp = DPP_Count;
			init_encoder_count(DPP_Count);	   // Only occurs during a reset at the top or bottom floor
      		Velocity = 0;
			Dmd_Velocity = 0;
#endif
			set_door_close_during_reset();
      		procf = 15;
      		return;
    	}
  	}

  	if ((cons[BinPiIn] == 1) || (cons[sel_type] != 0))       // binary position inputs floor confirm
  	{
    	if((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))      // dead level
    	{
#if (Traction == 1)
			if (cons[sel_type] == 3)
			{
				if (set_position_from_encoder() == 1)
				{
					preset = 1;
					preset_encoder_count(DPP_Count);
				}
				else					
				{
					record_fault(f_encoder_preset);
		      		procf = 0;        // reset elevator lost
					rset = 3;						
				}
			}
			else if ((cons[sel_type] == 1) || (cons[sel_type] == 2))
			{
				if (set_position_from_selector() == 1)
				{
					preset = 1;
					preset_selector_position();
				}
				else
				{
					rset = 3;					
					record_fault(f_sel_preset);
					procf = 0;		// cause another reset delay
				}
			}
			else
#endif
			{
	  	   		tmppos = 0;
	      		if(rdinp(i_BP1) == 1)
					tmppos = (tmppos + 1);
	      		if(rdinp(i_BP2) == 1)
					tmppos = (tmppos + 2);
	      		if((cons[topf] > 3) && (rdinp(i_BP4) == 1))
					tmppos = (tmppos + 4);
	      		if((cons[topf] > 7) && (rdinp(i_BP8) == 1))
					tmppos = (tmppos + 8);
	      		if((cons[topf] > 15) && (rdinp(i_BP16) == 1))
					tmppos = (tmppos + 16);
#if (Tract_HR == 1)
				if((cons[topf] > 31) && (rdinp(i_BP32) == 1))
	  				tmppos = (tmppos + 32);
#endif
				if ((tmppos > 0) && (tmppos <= cons[topf]))
		    		position = tmppos;
				preset = 1;
	    	}
		}
    	if ((rdinp(i_DZ) == 1) && (preset == 1) && (rset != 3))
    	{		  // Within 3 inches of dead level
#if(Traction == 1)
      		DPP_Count = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
			old_dpp = DPP_Count;
			preset_encoder_count(DPP_Count);
      		Velocity = 0;
			Dmd_Velocity = 0;
#endif
			preset = 0;
			set_door_close_during_reset();
      		procf = 15;
      		return;
    	}
  	}

  	if( (rdinp(i_UL) == 1) && (rdinp(i_DL) == 1) &&
    	  (rdinp(i_UT) == 1) && (rdinp(i_DT) == 1) && (rset != 3) )
  	{				// car is dead level
#if(Traction == 1)
      	DPP_Count = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
		old_dpp = DPP_Count;
		preset_encoder_count(DPP_Count);
      	Velocity = 0;
		Dmd_Velocity = 0;
#endif
		set_door_close_during_reset();
    	procf = 15;
    	return;
  	}

	if ( ((cons[BinPiIn] == 1) || (cons[sel_type] != 0)) && (rset != 3) && ((rdinp(i_UL) == 1) || (rdinp(i_DL) == 1)) )
	{	// With binary presets just relevel the car

#if(Traction == 1)
      	Velocity = 0;
		Dmd_Velocity = 0;
#endif
		set_door_close_during_reset();
		if ((cons[equake] == 0) || (eqf <= 1) || (eqf == 4))
    	{				  // Relevel if not on counterweight derailment
    		procf = 15;
    		return;
		}
	}

	if ((DBR_Temp_Fault == 1) && (leveling_fault == 0))
	{
		rset_run_cnt = 0;
		procf = 0;		// cause another reset delay
		return;
	}

	if (((cons[Car_Sw] & 1) != 0) && (cons[att] == 0))
	{	
		if ((rdinp(i_UL) == 1) || (rdinp(i_DL) == 1) || (rdinp(i_DZ) == 1))
		{	
    		procf = 15;
    		return;
		}
		else
		{
			if ((rdinp(i_ATTUP) == 0) && 
				(rdinp(i_ATTDN) == 0))
			{
				rset_run_cnt = 0;
				return;
			}
			if (rdinp(i_ATTUP) == 1)
				position = cons[bottomf];

			if (rdinp(i_ATTDN) == 1)
				position = cons[topf];
		}
	}

#if((Traction == 1) || (Tract_OL == 1))

#if (Tract_OL == 1)
	if ((cons[Emp_Recover] != 0) && (cons[loadw] == 2))		// Traction open loop must have load weigher
#else
	if (cons[Emp_Recover] != 0)
#endif
	{				
		if ((rdinp(i_EMP) == 1) && (rdinp(i_DZ) == 0))
		{
			procf = 21; 	// emergency power recovery mode
			return;
		}
	}
#endif

	if (((firef != 0) || ((cons[rear] != 0) && (rfiref != 0))) && 
		((cons[ansi] >= 2007) || ((pwr_up_reset == 0) && (cons[ansi] >= 2004))))
	{
		if (cons[Australia] == 1)
		{
			fs2_on = (rdinp(i_FS2) == 0) || (rdinp(i_FS2H) == 1);
			fs2_hold = 0;
			fs2_start = (rdinp(i_FS2H) == 1);
		}
		else
		{
			if (cons[FS2_SW] == 1)	// New logic FS2 = NOT FS2 and NOT FS2H, HOLD = FS2H, OFF = FS2
				fs2_on = (rdinp(i_FS2) == 0) && (rdinp(i_FS2H) == 0);
			else					// Original logic FS2 = FS2 input, HOLD = FS2H, OFF = NOT FS2 and NOT FS2H
				fs2_on = (rdinp(i_FS2) == 1);
			fs2_hold = (rdinp(i_FS2H) == 1);
			fs2_start =0;
		}

		if ((firef > 3) || ((cons[rear] != 0) && (rfiref > 3)))	// car on phase 2
		{
			carcall();
			dirsel();
			if ((rdinp(i_CC(position)) == 1) ||
					((cons[rear] == 1) && (rdinp(i_CCR(position)) == 1)))
				call_at_fl = 1;
			else
				call_at_fl = 0;

			if ((fs2_hold == 1) || ((cons[Australia] == 1) && (fs2_start == 0)) ||
				((fs2_on == 1) && (dcalls == 0) && (call_at_fl == 0)))
			{
				rset_run_cnt = 0;
				return;			// do not move
			}
		}
#if (Traction == 1)
		if (position >= fire_floor)
#else
		if (scnd_pos >= fire_floor)
#endif
			recover_dir = 2;
		else
			recover_dir = 1;
	}
	else if (((position != cons[bottomf]) && (cons[shortfl] != cons[bottomf])) ||
  		(cons[shortfl] >= (cons[topf] - 1))) // go down and establish floor position
		recover_dir = 2;
	else
		recover_dir = 1;
  	
  	if (recover_dir == 2)
  	{		 // go down and establish floor position
    	servf = 13;
    	dirf = 2;
#if(Traction == 1)
    	if (((cons[BinPiIn] == 1) || (cons[sel_type] == 3) || (((cons[sel_type] == 1) || (cons[sel_type] == 2)) && (SEL_Count_Valid == 1))) && (rset != 3))
			Vel_Max_Set = Recovery_Vel;		// Recovery Speed
    	else 
		{
			if (cons[speed] >= 500)
				Vel_Max_Set = (float)(30.0 * Pulses_per_Inch);     // 150 feet minute
			else if (cons[speed] >= 200)
				Vel_Max_Set = (float)(20.0 * Pulses_per_Inch);     // 100 feet minute
			else
				Vel_Max_Set = (float)(10.0 * Pulses_per_Inch);     // 50 feet minute

			if (Vel_Max_Set >= Vel_Max)
				Vel_Max_Set = Recovery_Vel;
		}
    	Velocity = 0;
		Dmd_Velocity = 0;
    	timers[tvpat] = 0;
		if(cons[sel_type] == 3)
		{
			set_position_from_encoder();
			DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
		}
		else
		{
			set_position(1);	 // reset position to what we think is correct
    		DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
    		DPP_Count = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
			old_dpp = DPP_Count;
			preset_encoder_count(DPP_Count);
		}

    	if ((cons[BinPiIn] == 1) || (cons[sel_type] != 0))
		{
			if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
			{
				setoutp(o_LE);
				setoutp(o_LE1);
    		}
    	}
    	else
		{
			clroutp(o_LE);
			clroutp(o_LE1);
    	}
    	timers[tdppflt] = 0;
    	Lev_Mode=0;
    	Vel_Step = 0;
#else
		position = cons[topf];
#endif
  	}
  	else                          // go up and establish floor position
  	{
		servf = 12;
		dirf = 1;
#if(Traction == 1)
    	if (((cons[BinPiIn] == 1) || (cons[sel_type] == 3) || (((cons[sel_type] == 1) || (cons[sel_type] == 2)) && (SEL_Count_Valid == 1))) && (rset != 3))
			Vel_Max_Set = Recovery_Vel;		// Recovery Speed
		else
		{
			if (cons[speed] >= 500)
				Vel_Max_Set = (float)(30.0 * Pulses_per_Inch);     // 150 feet minute
			else if (cons[speed] >= 200)
				Vel_Max_Set = (float)(20.0 * Pulses_per_Inch);     // 100 feet minute
			else
				Vel_Max_Set = (float)(10.0 * Pulses_per_Inch);     // 50 feet minute

			if (Vel_Max_Set >= Vel_Max)
				Vel_Max_Set = Recovery_Vel;
		}
		Velocity = 0;
		Dmd_Velocity = 0;
		timers[tvpat] = 0;
		if(cons[sel_type] == 3)
		{
			set_position_from_encoder();
			DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
		}
		else
		{
			set_position(2);	 // reset position to what we think is correct
			DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
			DPP_Count = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
			old_dpp = DPP_Count;
			preset_encoder_count(DPP_Count);
		}

		
    	if ((cons[BinPiIn] == 1) || (cons[sel_type] != 0))
	    {
			if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
			{
		    	setoutp(o_LE);
				setoutp(o_LE1);
			}
		}
		else
		{
	    	clroutp(o_LE);
			clroutp(o_LE1);
		}
		timers[tdppflt] = 0;
		Lev_Mode=0;
		Vel_Step = 0;
#else
		position = cons[bottomf];
#endif
  	}

#if ((Traction == 1) || (Tract_OL == 1))
	if (cons[equake] != 0)
	{	
		seteqf();
		setempf();
		if (eqf >= 2)
		{			// power up on earthquake mode : run away from the cwt if not on DZ at the floor 
			dirf = 0;
			dirsel();
#if(Traction == 1)
   			Vel_Max_Set = Recovery_Vel;		// Recovery Speed
			if (above_cwt == 1)
			{			// going to run up
				DPP_Target = DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]];
				if(cons[sel_type] != 3)
				{
					DPP_Count = mid_hoistway + 10;
					old_dpp = DPP_Count;
					preset_encoder_count(DPP_Count);
				}
			}
			else
			{
		    	DPP_Target = DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]];
				if(cons[sel_type] != 3)
				{
			    	DPP_Count = mid_hoistway - 10;
					old_dpp = DPP_Count;
					preset_encoder_count(DPP_Count);
				}
			}
  		  	if ((cons[BinPiIn] == 1) || (cons[sel_type] != 0))
		    {
				if (((cons[ansi] < 2000) || (gripper_fault == 0)) && (rdinp(i_GOV) == 1))
				{
			    	setoutp(o_LE);
					setoutp(o_LE1);
				}
			}
			else
			{
		    	clroutp(o_LE);
				clroutp(o_LE1);
			}
#endif
			if (dirf == 0)
			{
				procf = 0;		// cause another reset delay
				return;
			}
		}
	}
#endif

#if(Traction == 1)
	old_dpp = DPP_Count;
	Prev_DPP_Count = DPP_Count;
	prev_Enc_Count = DPP_Count;	
#endif

	setempf();
	if ((empf != no_ep)  && (empf != ep_recall) && (empf != ep_select))
	{			 // cannot run unless selected to run
		servf = 7;
		dirf = 0;
#if(Traction == 1)
		Velocity = 0;
		Dmd_Velocity = 0;
		timers[tvpat] = 0;
		Lev_Mode=0;
		Vel_Step = 0;
#endif
		procf = 0;		// cause another reset delay
		return;
	}
#if ((Traction == 0) && (Tract_OL == 0))
	else
	{
		if ((empf == ep_recall) && (dirf == 1))
		{
		 	dirf = 2;		// this code should only execute once
		 	dpref = 2;		// force a down run
		 	// Clear direction arrows
			clr_dir_arrow();
			if (rdinp(i_DT)==0)		// on the down terminal limit
				hsf = 0;			  // level to the floor
			else
				hsf = 1;			  // else run high speed to the floor
		}
	}
#endif

    if((firef != 0) && (rset != 3) && (rdinp(i_DZ) == 1))
    {
		timers[tnudge] = 0;
		timers[trnudge] = 0;
  		timers[teeto] = 0;
  		timers[treeto] = 0;
 		procf = 15;
#if(Traction == 1)
		if(cons[sel_type] != 3)
		{
			DPP_Count = DPP_Floor_Pos[position] + DPP_Fl_Offset[position];
			old_dpp = DPP_Count;
			preset_encoder_count(DPP_Count);
		}
		Velocity = 0;
		Dmd_Velocity = 0;
#endif
		timers[tmotion] = 0;
		timers[tpatdly] = 0;
		return;
    }

	if (eqf == 0)
	{
#if(Traction == 1)
    	if (((cons[BinPiIn] == 1) || (cons[sel_type] == 3) || (((cons[sel_type] == 1) || (cons[sel_type] == 2)) && (SEL_Count_Valid == 1))) && (rset != 3))
#else
    	if ((cons[BinPiIn] == 1) && (rset != 3)) 
#endif
	      	hsf = 0;
	  	else
	      	hsf = 1;
	}
	else
		hsf = 0;

  	timers[tmotion] = 0;
	timers[tpatdly] = 0;
	timers[tsafe] = 0;
	safe_fault_latch = 0;
	timers[tadvptrq] = 0;
	adv_pre_trq_run = 0;
	adv_pre_trq_fault = 0;

#if ((Traction == 1) || (Tract_OL == 1))
	verify_limit_seq(1);		// parameter == 1 for initialization
	verify_uldl_seq(1);		// parameter == 1 for initialization
#endif

	if ((safe() == 1) && ((cons[ansi] < 2000) || (gripper_fault == 0)))
	{
		hold_brake_overspeed = 0;
		if (rset_run_cnt < 5)		// give up after five tries
		{
			rset_run_cnt++;
#if ((Traction == 1) || (Tract_OL == 1))
			if ((stallf == 0) && (dirf != 0))
				procf = 3;          // go into motion
			else
			{
				dirf = 0;
				procf = 0;		// cause another reset delay
			}
#else
			if (((stallf == 0) || (dirf == 2)) && (dirf != 0))
				procf = 3;          // go into motion
			else
				procf = 0;		// cause another reset delay
#endif
		}
		else
		{
			if (rset_run_cnt == 5)
			{
				rset_run_cnt++;
				record_fault(f_reset_run_inhibit);
			}
			dirf = 0;
			procf = 0;		// cause another reset delay
		}			
	}
	else if ((door_locks() == 0) || (car_gate() == 0))
	{		// we reached this point so we need to run to recover so shut the door
		close_doors_during_reset(1);
	}
  	return;
}	
//***********************************
// Close Elevator Doors in Reset Mode
//***********************************

void close_doors_during_reset (int16 force_close)
{
	timers[tdc] = 0;
  	timers[trdc] = 0;
	while ( ((rdinp(i_DCL) == 1) && (timers[tdc] <= fvars[fvdpt])) || 
		    ((rdinp(i_DCLR) == 1) && (timers[trdc] <= fvars[fvdpt])) ||
		    ((force_close == 1) && (timers[tdc] <= fvars[fvdpt]) && ((door_locks() == 0) || (car_gate() == 0))) )
	{
		inctime(0);
		nudg_buz = 0;
		rnudg_buz = 0;
		// Testing to see if on inspection
		if(chk_ins() == 1)
		{
	  		procf = 2;        // go to inspection mode
	  		return;
		}
		if(firef >= 4)      // On Fire Service Phase 2
		{
	  		timers[tdc] = 0;
	  		if (((rdinp(i_DCB) == 1) || ((cons[RGB_CC] == 1) && (rdinp(i_FiDCB) == 1))) && 
	  			(fs2_hold == 0))
	  		{
				if (timers[tdcdly] >= fvars[fvdrdly])
				{
					setoutp(o_DC);
	 				timers[tdodly] = 0;
				}

				if (cons[door_type] == 1)	 // otis ovl door operator
		  			clroutp(o_DO);
	  		}
	  		else
	  		{
				clroutp(o_DC);
				if (cons[door_type] == 1)	 // otis ovl door operator
		  		{
					if (timers[tdodly] >= fvars[fvdrdly])
					{
			  			setoutp(o_DO);
		 				timers[tdcdly] = 0;
					}
				}
				else
				{
					if(rdinp(i_DOL) == 1)
					{
						if (timers[tdodly] >= fvars[fvdrdly])
						{
				  			setoutp(o_DO);
			 				timers[tdcdly] = 0;
						}
					}
					else
			  			clroutp(o_DO);
				}
	  		}
		}
		else 
		{
	  		clroutp(o_DO);
	  		if ((rdinp(i_SE) == 1) || (rdinp(i_DOB) == 1) ||
	  			((cons[RGB_CC] == 1) && (rdinp(i_FiDOB) == 1)))
	  		{
				clroutp(o_DC);
	  		}
	  		else
	  		{
				if (timers[tdcdly] >= fvars[fvdrdly])
				{
					if (rdinp(i_EE) == 1)
					{
						nudg_buz = 1;
						setoutp(o_NUD);
					}
					setoutp(o_DC);
	 				timers[tdodly] = 0;
				}
	  		}
		}
		if (cons[door_type] == 1)
		{
			if (cons[equake] == 0)
			{
		  	  	if ((rdinp(i_SE) == 1) && (firef <= 3))    // saftey edge
					setoutp(o_RVD);
				else
					clroutp(o_RVD);
			}

			if  ((cons[medEm] == 0) && (cons[cblue] == 0))
			{
				if ((rdoutp(o_DO) == 1) && (rdinp(i_DOL) == 1))
					setoutp(o_REV);
				else
					clroutp(o_REV);
			}
		}
		// Close The Rear Doors
		if(cons[rear] != 0)
		{
		  	if(rfiref >= 4)      // On Fire Service Phase 2
		  	{
		      	timers[trdc] = 0;
		      	if (((rdinp(i_DCBR) == 1) || 
		      		((cons[RGB_CC] == 1) && (rdinp(i_FiDCBR) == 1))) && 
		      			(fs2_hold == 0))
		      	{
					if (cons[door_type] == 1)	 // otis ovl door operator
			  			clroutp(o_DOR);

					if (timers[trdcdly] >= fvars[fvdrdly])
					{
					  	setoutp(o_DCR);
		 				timers[trdodly] = 0;
					}

		      	}
		      	else
		      	{
				  	clroutp(o_DCR);
					if (cons[door_type] == 1)
					{	// otis ovl door operator
						if (timers[trdodly] >= fvars[fvdrdly])
						{
					      	setoutp(o_DOR);
			 				timers[trdcdly] = 0;
						}
					}
					else
					{
					  	if(rdinp(i_DOLR) == 1)
						{
							if (timers[trdodly] >= fvars[fvdrdly])
							{
						      	setoutp(o_DOR);
				 				timers[trdcdly] = 0;
							}
					  	}
					  	else
						  	clroutp(o_DOR);
					}
		      	}
		  	}
		  	else
		  	{
		      	clroutp(o_DOR);
		      	if ((rdinp(i_SER) == 1) || 
		      		(rdinp(i_DOBR) == 1) ||
		      		((cons[RGB_CC] == 1) && (rdinp(i_FiDOBR) == 1)))
		      	{
				  	clroutp(o_DCR);
		      	}
		     	else
		      	{
					if (timers[trdcdly] >= fvars[fvdrdly])
					{
						if (rdinp(i_EER) == 1)
						{
							rnudg_buz = 1;
						  	setoutp(o_NUDR);
						}
					  	setoutp(o_DCR);
		 				timers[trdodly] = 0;
					}
		      	}
		  	}
			if (cons[door_type] == 1)
			{
		    	if ((rdinp(i_SER) == 1) && (rfiref <= 3))   // saftey edge
					setoutp(o_RVDR);
				else
					clroutp(o_RVDR);

				if ((rdoutp(o_DOR) == 1) && (rdinp(i_DOLR) == 1))
					setoutp(o_REVR);
				else
					clroutp(o_REVR);
			}

	  	}
	}
	if (cons[door_type] == 1)
	{
		clroutp(o_DO);
		if (cons[equake] == 0)
			clroutp(o_RVD);
		if ((cons[medEm] == 0) && (cons[cblue] == 0))
			clroutp(o_REV);
	}
	clroutp(o_DC);
	clroutp(o_NUD);
	nudg_buz = 0;

	if (cons[door_type] == 1)
	{
      	clroutp(o_DOR);
		clroutp(o_RVDR);
		clroutp(o_REVR);
	}
	clroutp(o_DCR);
  	clroutp(o_NUDR);
	nudg_buz = 0;
}
//**************************************
//**** Command to close doors
//**************************************
void set_door_close_during_reset(void)
{
	
	timers[tdc] = 0;
	timers[trdc] = 0;
   	timers[tnudge] = 0;
   	timers[trnudge] = 0;
    timers[teeto] = 0;
    timers[treeto] = 0;
	if ((firef == 0) && (empf == 0) && (eqf == 0) && (in_att == 0))
	{
		doorf = 3;			// Close the door if open
		if (cons[rear] != 0)
			rdoorf = 3;
	}
}
//*************************************
// ** Reset Hydro Jack Operation
//*************************************

#if ((Traction == 0) && (Tract_OL == 0))

void reset_jack (void)
{
	if ((cons[home] >= 100) || (cons[Reset_Jack] == 1))
	{
		timers[trhjack] = 0;
		rhjackf = 2;
		while (procf == 18)
		{
			servf = 0;
			inctime(0);
			setoutp(o_DC);		// Keep the door closed
			if ((safe() == 1) && (rdinp(i_DCL) == 0))
			{
				if (rhjackf == 2)
				{
					// Run the car all the way down
					setoutp(o_RUN);
					setoutp(o_RUNA);
					setoutp(o_DNR);
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
						clroutp(o_MST);
					clroutp(o_UP);
					clroutp(o_UPF);
					clroutp(o_MCC);
					clroutp(o_MCA);
					if (cons[GOV_Reset] == 0)
						setoutp(o_DNO);  // use GEN output to override normal limit (normally not used for hydro car)
					if (timers[trhjack] > 600)
					{
						rhjackf = 3;
						timers[trhjack] = 0;
					}
				}
				if (rhjackf == 3)
				{	// Turn off everything for 2 seconds
					clroutp(o_DNR);
					clroutp(o_DF);
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
						clroutp(o_MST);
					clroutp(o_UP);
					clroutp(o_UPF);
					clroutp(o_MCC);
					clroutp(o_MCA);
					clroutp(o_RUN);
					clroutp(o_RUNA);
					if (cons[GOV_Reset] == 0)
						setoutp(o_DNO);  // use GEN output to override normal limit (normally not used for hydro car)
					if (timers[trhjack] > 20)
					{	  // Time to run back up
						rhjackf = 4;
						timers[tmotion] = 0;
						timers[trhjack] = 0;
					}
				}
				if (rhjackf == 4)
				{	   // Run car back up to floor level
					clroutp(o_DNR);
					clroutp(o_DF);
					if ((Drive_Type[cons[carnmb]] != 9)	&& (cons[GOV_Reset] == 0))
					{
						if(timers[tmotion] >= fvars[fvydel])
							setoutp(o_MST);
						else
							clroutp(o_MST);
					}
					if(rdinp(i_DEL) == 0)
						clroutp(o_UP);
					else
						setoutp(o_UP);
					setoutp(o_RUN);
					setoutp(o_RUNA);
					setoutp(o_MCC);
					setoutp(o_MCA);
					if (cons[GOV_Reset] == 0)
						setoutp(o_DNO);  // use GEN output to override normal limit (normally not used for hydro car)

					if (((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1)) || (timers[trhjack] > 1200))
					{		// Level to the floor or timed out
						rhjackf = 5;
						timers[trhjack] = 0;
					}
				}
				if (rhjackf == 5)
				{	  // Jack reset complete
					clroutp(o_DNR);
					clroutp(o_DF);
					if ((Drive_Type[cons[carnmb]] != 9) && (cons[GOV_Reset] == 0))
						clroutp(o_MST);
					clroutp(o_UP);
					clroutp(o_UPF);
					clroutp(o_MCC);
					clroutp(o_MCA);
					clroutp(o_RUN);
					clroutp(o_RUNA);
					if (cons[GOV_Reset] == 0)
						clroutp(o_DNO);	// use GEN output to override normal limit (normally not used for hydro car)
					rhjackf = 0;
					procf = 0;			// go to reset mode
				}
			}
			else if (timers[trhjack] > 200)
			{
				clroutp(o_DNR);
				clroutp(o_DF);
				if ((Drive_Type[cons[carnmb]] != 9)	&& (cons[GOV_Reset] == 0))
					clroutp(o_MST);
				clroutp(o_UP);
				clroutp(o_UPF);
				clroutp(o_MCC);
				clroutp(o_MCA);
				clroutp(o_RUN);
				clroutp(o_RUNA);
				if (cons[GOV_Reset] == 0)
					clroutp(o_DNO);	// use GEN output to override normal limit (normally not used for hydro car)
				rhjackf = 0;
				procf = 0;			// go back to reset mode
			}
		}
	}
	else
		procf = 0;
}
#endif


// ************************************
// ** Set a car call to return to lobby
// ************************************

void return_to_lobby(void)
{
	int16 fl;
  	// out of service return to lobby
  	if ((cons[otslbp] != 0) || ((cons[ids] & 1) != 0))
	{
	 	if ((firef == 0) && (rfiref == 0) && (codebf == 0) && (vipf == 0) && (eqf == 0) && (medf == 0))
 		{
		
#if ((Traction == 1) || (Tract_OL == 1))
  			if (((rdinp(i_RTL) == 1) && (cons[otslbp] != 0)) || 
  				(((cons[ids] & 1) != 0) && (ids_rtl[cons[carnmb]] == 1)) ||
  				(((cons[Galileo] & 1) != 0) && (ui_rtl[cons[carnmb]] == 1)) ||
  				((rdinp(i_RTLDC) == 1) && ((cons[otslbp] & 0x04) != 0)))
#else
  			if (((rdinp(i_RTLH) == 1) && (cons[otslbp] != 0)) || 
  				(((cons[ids] & 1) != 0) && (ids_rtl[cons[carnmb]] == 1)) || 
  				(((cons[Galileo] & 1) != 0) && (ui_rtl[cons[carnmb]] == 1)) || 
  				((rdinp(i_RTLDC) == 1) && ((cons[otslbp] & 0x04) != 0)))
#endif
			{
				
				fl = lobby_fl;
					 
				if ((fl < cons[bottomf]) || (lobby_fl > cons[topf]))
					fl = cons[bottomf];

				if ((position != fl) && ((servf == 1) || (servf == 15)))
		  		{
					if ((fvars[fvrtl] & 0x02) != 0)
					{
						clrcc(0);
						if ((fvars[fvrtl] & 0x04) != 0)
						{
							if ((hsf == 0) && (procf >= 3) && (procf <= 11))
							{			   // car is in slowdown
								if (ccmsk[cons[carnmb]][position] != 0)
									front_slowdown |= cc_do;
								else if ((cons[rear] != 0) && (rccmsk[cons[carnmb]][position] != 0))
									rear_slowdown |= cc_do;
							}
						}
						else
						{
							rear_slowdown &= ~cc_do;
							front_slowdown &= ~cc_do;
						}
					} 
					zone_fl = fl;
					if ((cons[otslbp] & 0x04) == 0)
					{
						set_carcall(cons[carnmb],fl);
						if((cons[rear] == 1) && (ccmsk[cons[carnmb]][fl] == 0)) // Added to allow RTL to work on rear openings
							set_rcarcall(cons[carnmb],fl);
					}
				}
			}
			else if (servf == 15)
				servf = 1;
		}
		else if (servf == 15)
			servf = 1;
  	}
}

//****************************
// Car is Safe to move
//****************************
int16 safe(void)
{
	statusf &= ~sf_INS;

	if ( (rdinp(i_GTS) == 1) || (gripper_test < 4))
		timers[tgts] = 0;

	if ((rdinp(i_FFS) == 0) && (rdinp(i_SS) == 1) && (cons[firesv] == 2) && (cons[ansi] >= 2004))
	{
		statusf &= ~(sf_STP | sf_GTS);
		statusf |= sf_FSTP;
		timers[tgts] = 0;
		timers[tins_flt] = 0;
		return 0;					// NOT Safe without fire stop switch
	}
	else
	{
		statusf &= ~sf_FSTP;
		if ((rdinp(i_STP) == 0) || (rdinp(i_GTS) == 0))
		{
			if ((rdinp(i_GTS) == 0) && (rdinp(i_SS) == 1))
			{
				statusf &= ~sf_STP;
				statusf |= sf_GTS;
#if ((Traction == 1) || (Tract_OL == 1))
				if ((cons[ansi] >= 2000) && (gripper_fault == 0) && (timers[tgts] > 2) && ((in_pfc_sfc_test == 0) || (cons[EM_BRK] == 0)))
				{
//					gripper_fault = 1;
					if (cons[EM_BRK] != 0)
			  			record_fault(f_utm_gts_flt);
					else
					  	record_fault(f_gts_pick);
				}
#endif
			}
			else
			{
				statusf &= ~sf_GTS;

				if ((rdinp(i_STP) == 0) && (rdinp(i_READY) == 1) && (rdoutp(o_PFC) == 1))
					statusf |= sf_STP;
				else
					statusf &= ~sf_STP;
			}

			return 0;		// not safe without stop switch or GTS
		}
		else
			statusf &= ~(sf_STP | sf_GTS);
	}

	if (ins_fault == 1)
	{	// previously had an inspectionn error
		if (timers[tins_flt] > 5)
      	{
			statusf |= sf_INS;
			if (ins_fault_latch == 0)
			{
				ins_fault_latch = 1;
			  	record_fault(f_ins_err);
			}
		}
	}
	else
	{
		ins_fault_latch = 0;
		timers[tins_flt] = 0;
	}

	ins_fault = 0;		// This flag will be set below before next time through
		
	if (byp_fault == 1)
	{	// previously had an inspectionn error
		if (timers[tbyp_flt] > 5)
      	{
			statusf |= sf_INS;
			if (byp_fault_latch == 0)
			{
				byp_fault_latch = 1;
			  	record_fault(f_byp_err);
			}
		}
	}
	else
	{
		byp_fault_latch = 0;
		timers[tbyp_flt] = 0;
	}

	byp_fault = 0;		// This flag will be set below before next time through

	if (rdinp(i_AUTO) == 1)
	{	  // ON AUTOMATIC
		if ((rdinp(i_INS) == 1) || (rdinp(i_MRIN) == 1) ||
				(rdinp(i_ACC) == 1) || (rdinp(i_ICI) == 1))
		{
			ins_fault = 1;
			return 0;		// not safe from input failure  
		}
		
		if ((rdinp(i_GBP) == 1) || (rdinp(i_LBP) == 1))
		{
			byp_fault = 1;
			return 0;
		} 
	
		if ((door_locks() == 1) && (car_gate() == 1))
			return 1;
		else
			return 0;
	}
	else if (rdinp(i_INS) == 1)
	{	// Top of Car Inspection
		if ( (rdinp(i_AUTO) == 1) || (rdinp(i_MRIN) == 1) ||
				(rdinp(i_ACC) == 1) || (rdinp(i_ICI) == 1) )
		{
			ins_fault = 1;
			return 0;		// not safe from input failure
		}

		if ((rdinp(i_LBP) == 1) && (rdinp(i_GBP) == 1))
		{		// Bypassing both the gate and lock
			return 1;
		}
		else if ((rdinp(i_LBP) == 1) && (rdinp(i_GBP) == 0)) 
		{	  // Locks are bypassed but not the gate
			if (car_gate() == 1)
				return 1;		// gates are locked
			else
				return 0;
		}
		else if ((rdinp(i_LBP) == 0) && (rdinp(i_GBP) == 1))
		{	  // Gates are bypassed but not the locks
			if (door_locks() == 1)
				return 1;
			else
				return 0;
		}
		else 	
		{	 // No Gate or Lock Bypass
			if ((door_locks() == 1) && (car_gate() == 1))
				return 1;
			else
				return 0;
		}
	}
	else if (rdinp(i_ACC) == 1)
	{		  // Access operation
		if ( (rdinp(i_AUTO) == 1) || (rdinp(i_MRIN) == 1) ||
				(rdinp(i_INS) == 1) || (rdinp(i_ICI) == 1) )
		{
			ins_fault = 1;
			return 0;		// not safe from input failure
		}

		if ((rdinp(i_GBP) == 1) || (rdinp(i_LBP) == 1))
		{
			byp_fault = 1;
			return 0;
		} 

		if ((rdinp(i_TAU) == 0) && (rdinp(i_TAD) == 0) &&
					(rdinp(i_BAU) == 0) && (rdinp(i_BAD) == 0))
			return 1;

		if (cons[topf] > 2)
		{
			if ((rdinp(i_DLM) == 0) || (rdinp(i_DLM_1) == 0))
				return 0;
				
			if (((cons[mand] != 0) || (cons[Australia] == 1)) && (rdinp(i_MDC) == 0))
				return 0;	  // if manual door then middle aux lock must be made

			if (cons[rear] == 1)
			{
				if ((rdinp(i_RLM) == 0) || (rdinp(i_RLM_1) == 0))
					return 0;		// middle door locks must always be	on
				if (((cons[mand] != 0) || (cons[Australia] == 1)) && (rdinp(i_MDCR) == 0))
					return 0;		 // if manual door then middle aux lock must be made
			}
		}				

		if (((rdinp(i_TAU) == 1) || (rdinp(i_TAD) == 1)) && 
			(rdinp(i_BAU) == 0) && (rdinp(i_BAD) == 0))
		{		// Top access
			if (((cons[access_type] & 1) != 0) && (cons[rear] != 0)) 
			{
				if ((rdinp(i_RGS) == 0) || (rdinp(i_RGS_1) == 0))
					return 0;	// front top access but rear gate is open
				if ((rdinp(i_RLM) == 0) || (rdinp(i_RLM_1) == 0))
					return 0;	// front top access but rear middle lock is open (even if only two floors)
				if (((cons[mand] != 0) || (cons[Australia] == 1)) && (rdinp(i_MDCR) == 0))
					return 0;
			}
			if ((cons[access_type] & 4) != 0)
			{
				if ((rdinp(i_GS) == 0) || (rdinp(i_GS_1) == 0))
					return 0; 	// rear top access but front gate is open
				if ((rdinp(i_DLM) == 0) || (rdinp(i_DLM_1) == 0))
					return 0;	// rear top access but middle door lock open (even if only two floors)
				if (((cons[mand] != 0) || (cons[Australia] == 1)) && (rdinp(i_MDC) == 0))
					return 0;
			}
			if (((cons[mand] != 0) || (cons[Australia] == 1)) && (rdinp(i_BDC) == 0))
				return 0;

			if (((rdinp(i_DLB) == 1) && (rdinp(i_DLB_1) == 1)) && ((fvars[fvaccdoorcl] == 0) || (car_gate() == 1)))
				return 1;	 // Must have the bottom door lock
			else
				return 0;
		}
		else if (((rdinp(i_BAU) == 1) || (rdinp(i_BAD) == 1)) && 
			(rdinp(i_TAU) == 0) && (rdinp(i_TAD) == 0))
		{		// Bottom Access
			if (((cons[access_type] & 2) != 0) && (cons[rear] != 0))
			{
				if ((rdinp(i_RGS) == 0) || (rdinp(i_RGS_1) == 0))
					return 0;	// front bottom access but rear gate is open
				if ((rdinp(i_RLM) == 0) || (rdinp(i_RLM_1) == 0))
					return 0;	// front bottom access but rear middle lock is open	(even if only two floors)
				if (((cons[mand] != 0) || (cons[Australia] == 1)) && (rdinp(i_MDCR) == 0))
					return 0;
			}
			if ((cons[access_type] & 8) != 0) 
			{
				if ((rdinp(i_GS) == 0) || (rdinp(i_GS_1) == 0))
					return 0; 	// rear bottom access but front gate is open
				if ((rdinp(i_DLM) == 0) || (rdinp(i_DLM_1) == 0))
					return 0;	// rear bottom access but middle door lock open	(even if only two floors)
				if (((cons[mand] != 0) || (cons[Australia] == 1)) && (rdinp(i_MDC) == 0))
					return 0;
			}
			if (((cons[mand] != 0) || (cons[Australia] == 1)) && (rdinp(i_TDC) == 0)) 
				return 0;

			if (((rdinp(i_DLT) == 1) && (rdinp(i_DLT_1) == 1)) && ((fvars[fvaccdoorcl] == 0) || (car_gate() == 1)))
				return 1;	 // Must have the top door lock
			else
				return 0;
		}
	}
	else if (rdinp(i_ICI) == 1)
	{			// In-car Inspection
		if ( (rdinp(i_AUTO) == 1) || (rdinp(i_MRIN) == 1) ||
				(rdinp(i_INS) == 1) || (rdinp(i_ACC) == 1) )
		{
			ins_fault = 1;
			return 0;		// not safe from input failure
		}

		if ((rdinp(i_GBP) == 1) || (rdinp(i_LBP) == 1))
		{
			byp_fault = 1;
			return 0;
		} 

		if ((door_locks() == 1) && (car_gate() == 1))
			return 1;	  // Doors must be closed on in car inspection
		else
			return 0;
	}
	else if (rdinp(i_MRIN) == 1)
	{			// In-car Inspection
		if ( (rdinp(i_AUTO) == 1) || (rdinp(i_ICI) == 1) ||
				(rdinp(i_INS) == 1) || (rdinp(i_ACC) == 1) )
		{
			ins_fault = 1;
			return 0;		// not safe from input failure
		}

		if ((rdinp(i_GBP) == 1) || (rdinp(i_LBP) == 1))
		{
			byp_fault = 1;
			return 0;
		} 

		if ((door_locks() == 1) && (car_gate() == 1))
			return 1;	  // Doors must be closed on in car inspection
		else
			return 0;
	}

	ins_fault = 1;
	return 0;		// must have one input on
}

void set_safe_fault(void)
{
	if (door_locks() == 0)
	{
		if ((safe_fault_latch & 0x01) == 0)
			record_fault(f_dl_safe_flt);
		safe_fault_latch |= 0x01;
	}
	
	if (car_gate() == 0)
	{
		if ((safe_fault_latch & 0x02) == 0)
			record_fault(f_cg_safe_flt);
		safe_fault_latch |= 0x02;
	}

	if (manual_door != 0)
	{
		if (man_fdcc() == 0)
		{
			if ((safe_fault_latch & 0x04) == 0)
				record_fault(f_fdcc_safe_flt);
			safe_fault_latch |= 0x04;
		}
	}

	if (manual_rdoor != 0)
	{
		if ((man_rdcc() == 0) && (cons[rear] != 0))
		{
			if ((safe_fault_latch & 0x08) == 0)
				record_fault(f_rdcc_safe_flt);
			safe_fault_latch |= 0x08;
		}
	}
}



int16 access_door_safe(void)
{
	if (rdinp(i_ACC) == 1)
	{		  // Access operation
		if ( (rdinp(i_AUTO) == 1) || (rdinp(i_MRIN) == 1) ||
				(rdinp(i_INS) == 1) || (rdinp(i_ICI) == 1) )
			return 0;		// not safe from input failure

		if ((rdinp(i_GBP) == 1) || (rdinp(i_LBP) == 1))
			return 0;

		if ((rdinp(i_TAU) == 0) && (rdinp(i_TAD) == 0) &&
					(rdinp(i_BAU) == 0) && (rdinp(i_BAD) == 0))
			return 1;

		if (cons[topf] > 2)
		{
			if (((cons[mand] == 0)&&(cons[frghtd] == 0)) && ((rdinp(i_DLM) == 0) || (rdinp(i_DLM_1) == 0)))
 				return 0;						
				
			if (((cons[mand] != 0)||(cons[frghtd] != 0)) && (rdinp(i_MDC) == 0))
				return 0;	  // if manual door then middle aux lock must be made

			if (cons[rear] == 1)
			{
				if (((cons[mand] == 0)&&(cons[frghtd] == 0)) && ((rdinp(i_RLM) == 0) || (rdinp(i_RLM_1) == 0)))
					return 0;		// middle door locks must always be	on
				if (((cons[mand] != 0)||(cons[frghtd] != 0)) && (rdinp(i_MDCR) == 0))
					return 0;		 // if manual door then middle aux lock must be made
			}
		}				

		if (((rdinp(i_TAU) == 1) || (rdinp(i_TAD) == 1)) && 
			(rdinp(i_BAU) == 0) && (rdinp(i_BAD) == 0))
		{		// Top access
			if (((cons[access_type] & 1) != 0) && (cons[rear] != 0)) 
			{
				if ((rdinp(i_RGS) == 0) || (rdinp(i_RGS_1) == 0))
					return 0;	// front top access but rear gate is open
			}
			if ((cons[access_type] & 4) != 0)
			{
				if ((rdinp(i_GS) == 0) || (rdinp(i_GS_1) == 0))
					return 0; 	// rear top access but front gate is open
			}
			if (((cons[mand] != 0)||(cons[frghtd] != 0)) && (rdinp(i_BDC) == 0))
				return 0;

			if ((rdinp(i_DLB) == 1) && (rdinp(i_DLB_1) == 1))
				return 1;	 // Must have the bottom door lock
			else
				return 0;
		}
		else if (((rdinp(i_BAU) == 1) || (rdinp(i_BAD) == 1)) && 
			(rdinp(i_TAU) == 0) && (rdinp(i_TAD) == 0))
		{		// Bottom Access
			if (((cons[access_type] & 2) != 0) && (cons[rear] != 0))
			{
				if ((rdinp(i_RGS) == 0) || (rdinp(i_RGS_1) == 0))
					return 0;	// front bottom access but rear gate is open
			}
			if ((cons[access_type] & 8) != 0) 
			{
				if ((rdinp(i_GS) == 0) || (rdinp(i_GS_1) == 0))
					return 0; 	// rear bottom access but front gate is open
			}
			if (((cons[mand] != 0)||(cons[frghtd] != 0)) && (rdinp(i_TDC) == 0))
				return 0;

			if ((rdinp(i_DLT) == 1) && (rdinp(i_DLT_1) == 1))
				return 1;	 // Must have the top door lock
			else
				return 0;
		}
	}
	return 0;
}
//****************************
// Saftey String is Open Mode
//****************************
void sstring()
{
	int16 ss_fault_latch = 0;

	if ((enable_cc_test == 1) || (continue_cc_test == 1))
	{
		cancel_cc_test = 1;
		enable_cc_test = 0;
		continue_cc_test = 0;
	}

	SPB_can.command &= ~spbc_GR1_test;			// Clear GR1 test
	SPB_can.command &= ~spbc_SFC_test;			// Clear SFC test
	Overspeed_Test = 0;
   	Buffer_Test = 0;
   	timers[trst] = 0;
	timers[tpwl_pwr_off] = 0;
	rset_error_cnt = 0;		// made it out of reset

   	while(procf == 12)
   	{

     	servf = 0;
     	inctime(0);
		setfsf();		// set fire service flags
     	clrall();
     	doorf = 0;
#if(Traction == 1)
     	Velocity = 0;
		Dmd_Velocity = 0;
		if ((cons[sercom] & 8) == 0)
	     	DAC_Out();

		// Make sure the motor field is not at full field
    	if(timers[tff] > 40)
			clroutp(o_FF);
//		clroutp(o_FW);
#endif

#if((Traction == 1) || (Tract_OL == 1))
		if((rdinp(i_READY) == 0) && (rdinp(i_GTS) == 1) && (gripper_fault == 0))
     	{
			if (timers[tdrvrdy] > 1)
			{
				if ((statusf & sf_READY) == 0)
				  	record_fault(f_drive_rdy);
				statusf |= sf_READY;
				if (drv_rst_cnt <= fvars[fvdrvrst])
				{
				 	if(timers[trst] < 15)
					{
						if (rdoutp(o_RST) == 0)
							drv_soft_reset = 1;				// set once each time on timer start
							
						setoutp(o_RST);
				 	}
				 	else
						clroutp(o_RST);
				}
				else
					clroutp(o_RST);
				
				if (timers[trst] > 150)
					timers[trst] = 0;
			}
     	}
     	else
		{
			statusf &= ~sf_READY;
			clroutp(o_RST);
			timers[tdrvrdy] = 0;
		}
#endif
    	if(safeties() == 1)
			timers[tsst] = 0;
    	else if (timers[tsst] > 10)
     	{
			if (ss_fault_latch == 0)
				set_ss_fault();
			ss_fault_latch = 1;

			if ((statusf & sf_SS) == 0)
		  		record_fault(f_sstring);
			statusf |= sf_SS;
     	}
		else
			statusf &= ~sf_SS;

		// Testing to see if LC fuse is blown
    	if(rdinp(i_LC) == 1)
			timers[tlct] = 0;
    	if((rdinp(i_LC) == 0) && (timers[tlct] > 10))
    	{
			if ((statusf & sf_LC) == 0)
			  	record_fault(f_LC_fuse);
			statusf |= sf_LC;
    	}
		else
			statusf &= ~sf_LC;

#if((Traction == 1) || (Tract_OL == 1))
		if (cons[PWL_Brake] == 1)
		{
			if ((safeties() == 0) && (timers[tsst] > 10) &&  
				(rdinp(i_LC) == 0) && (timers[tlct] > 10))
			{		// Check to pick power loss manual brake
				if (pwl_brakef == 0)
				{
					clroutp(o_MB1);
					clroutp(o_MB2);
					clroutp(o_MBC);
					if (timers[tpwl_pwr_off] > 3000)
						clroutp(o_MBP);
					else
						setoutp(o_MBP);
					
					timers[tpwl_brk_on] = 0;
					timers[tpwl_brk_off] = 0;
				}
				else if (pwl_brakef == 1)
				{
					setoutp(o_MBP);
					if ((timers[tpwl_brk_on] < fvars[fvpwlbkon]) || (fvars[fvpwlbkoff] == 0) || (fvars[fvpwlbkon] == 0))
					{
						setoutp(o_MB1);
						setoutp(o_MB2);
						timers[tpwl_brk_off] = 0;
					}
					else 
					{
   						clroutp(o_MB1);
   						clroutp(o_MB2);
						if (timers[tpwl_brk_off] > fvars[fvpwlbkoff])
							timers[tpwl_brk_on] = 0;
					}
					setoutp(o_MBC);
					timers[tpwl_pwr_off] = 0;
				}
				else 
				{
					timers[tpwl_brk_on] = 0;
					timers[tpwl_brk_off] = 0;
					clroutp(o_MB1);
					clroutp(o_MB2);
					clroutp(o_MBC);
					if (timers[tpwl_pwr_off] > 600)
						clroutp(o_MBP);
				}
			}
			else
			{	// Drop pwr loss manual brake
				timers[tpwl_brk_on] = 0;
				timers[tpwl_brk_off] = 0;
		   		clroutp(o_MBP);
		   		clroutp(o_MB1);
		   		clroutp(o_MB2);
		   		clroutp(o_MBC);
			}
		}
#endif
		// Testing to see if saftey string is still open
     	if((safeties() == 1) && (rdinp(i_LC) == 1))
     	{
			statusf &= ~sf_SS;
			statusf &= ~sf_LC;

#if((Traction == 1) || (Tract_OL == 1))
			if ((rdinp(i_READY) == 1) && (rdinp(i_GTS) == 1))
			{
				statusf &= ~sf_READY;
				clroutp(o_RST);

			    if(chk_ins() == 1)
			    {  // Testing to see if on inspection
			      	procf = 2;        // go to inspection mode
			      	timers[tmotion] = 0;
					timers[tpatdly] = 0;
			      	return;
			    }
				procf = 0;			// go to reset no on inspection and okay to reset
				timers[tins_flt] = 0;
			}
			else if (rdinp(i_GTS) == 0)
			{					  // no gripper
				if (gripper_fault == 0)
				{		   // placed here to reset gripper before running on inspection
					procf = 0;			// go to reset no on inspection and okay to reset
					timers[tins_flt] = 0;
					return;
				}
			    if(chk_ins() == 1)
			    {  // Testing to see if on inspection
			      	procf = 2;        // go to inspection mode
			      	timers[tmotion] = 0;
					timers[tpatdly] = 0;
			      	return;
			    }
			}
#else
			// Testing to see if on inspection
		    if(chk_ins() == 1)
		    {
		      	procf = 2;        // go to inspection mode
		      	timers[tmotion] = 0;
				timers[tpatdly] = 0;
		      	return;
		    }
			procf = 0;       // go to reset mode
			timers[tins_flt] = 0;
#endif
     	}
   	}
	return;
}

//***************************
// Set Safety String Status
//***************************

int16 safeties (void)
{
	safety_string_status = 0;
	if ((cons[housing] == 1) || (cons[housing] == 2))
	{
		if (rdinp(i_GOV) == 0)
			safety_string_status |= sss_GOV;
		else if (rdinp(i_TF) == 0)
			safety_string_status |= sss_TF;
		else if (rdinp(i_BF) == 0)
			safety_string_status |= sss_BF;
		else if (rdinp(i_PS) == 0)
			safety_string_status |= sss_PS;
		else if (rdinp(i_PDS) == 0)
			safety_string_status |= sss_PDS;
		else if (rdinp(i_BFS) == 0)
			safety_string_status |= sss_BS;
		else if (rdinp(i_CMP) == 0)
			safety_string_status |= sss_CMP;
		else if ((rdinp(i_HMO) == 0) && (cons[housing] == 2))
			safety_string_status |= sss_HMO;
		else if (rdinp(i_TEE) == 0)
			safety_string_status |= sss_TEE;
		else if (rdinp(i_SEE) == 0)
			safety_string_status |= sss_SEE;
		else if (rdinp(i_CSS) == 0)
			safety_string_status |= sss_CSS;
		else if (cons[SFC_2004_IO] == 0)
		{
			if (rdinp(i_SS) == 0)
				safety_string_status |= sss_SS;
		}
		else 
		{
			if (cons[firesv] == 2)
			{
				if (rdinp(i_CTS) == 0)
					safety_string_status |= sss_CTS;
			}
			else
			{
				if (rdinp(i_CTS) == 0)
					safety_string_status |= sss_CTS;
				else if (rdinp(i_SS) == 0)
					safety_string_status |= sss_SS;
			}
		}
	}
	else
	{
		if (rdinp(i_GOV) == 0)
			safety_string_status |= sss_GOV;
		else if (rdinp(i_PS) == 0)
			safety_string_status |= sss_PS;
		else if (cons[SFC_2004_IO] == 0)
		{
			if (rdinp(i_SS) == 0)
				safety_string_status |= sss_SS;
		}
		else 
		{
			if (cons[firesv] == 2)
			{
				if (rdinp(i_CTS) == 0)
					safety_string_status |= sss_CTS;
			}
			else
			{
				if (rdinp(i_CTS) == 0)
					safety_string_status |= sss_CTS;
				else if (rdinp(i_SS) == 0)
					safety_string_status |= sss_SS;
			}
		}
	}

	return (safety_string_status == 0);			
}

//********************************
// Set Safety String Status	Fault
//********************************

void set_ss_fault (void)
{
	if ((cons[housing] == 1) || (cons[housing] == 2))
	{
		if (rdinp(i_GOV) == 0)
			record_fault(f_gov);
		else if (rdinp(i_TF) == 0)
			record_fault(f_top_final);
		else if (rdinp(i_BF) == 0)
			record_fault(f_bottom_final);
		else if (rdinp(i_PS) == 0)
			record_fault(f_pit_sw);
		else if (rdinp(i_PDS) == 0)
			record_fault(f_pit_door_sw);
		else if (rdinp(i_BFS) == 0)
			record_fault(f_buffer_sw);
		else if (rdinp(i_CMP) == 0)
			record_fault(f_comp_sw);
		else if ((rdinp(i_HMO) == 0) && (cons[housing] == 2))
			record_fault(f_Hoist_Motor_OVL);
		else if (rdinp(i_TEE) == 0)
			record_fault(f_top_em_exit);
		else if (rdinp(i_SEE) == 0)
			record_fault(f_side_em_exit);
		else if (rdinp(i_CSS) == 0)
			record_fault(f_car_safety_sw);
		else if ((rdinp(i_CTS) == 0) && (cons[SFC_2004_IO] == 1))
		{
			record_fault(f_Car_Top_Stop_Sw);
		}
	}
	else
	{
		if (rdinp(i_GOV) == 0)
			record_fault(f_gov);
		else if (rdinp(i_PS) == 0)
			record_fault(f_pit_sw);
		else if ((rdinp(i_CTS) == 0) && (cons[SFC_2004_IO] == 1))
		{
			record_fault(f_Car_Top_Stop_Sw);
		}
	}			
}
// ****************************************
// Set the code blue flag
// ****************************************

void setcodebf (void)
{
	if (cons[cblue] == 1)
	{
		if (((g_cb_fl[cons[carnmb]] != 0) || (g_rcb_fl[cons[carnmb]] != 0)) && (hsvf == 0)  && (Group_Comm == 1))
		{
			servf = 5;
			in_code_blue = 1;
			if (g_cb_fl[cons[carnmb]] != 0)
				codebfl = g_cb_fl[cons[carnmb]];
			else 
				codebfl = g_rcb_fl[cons[carnmb]];

			if (position != codebfl)
			{
				codebf = 1;		// want to get to the code blue floor
				if ((rdinp(i_EMS) == 1)&&(fvars[fvhsaftercb] == 0))
				{
					codebf = 4;
					doort = 0;
					rdoort = 0;
				}
				clrcc(0);
				clrhc();
				clrlant();
			}
			else if (position == codebfl)
			{			// at the code blue floor
				if ((procf < 3) || (procf > 11))
				{			   // car is not moving
					if (g_cb_fl[cons[carnmb]] != 0)	
					{		// Front door
						if ((doorf == 2) && (codebf == 2) && (doort != 0))
							codebf = 3;	  // front door is open
						else if ((codebf == 0) || (codebf == 1))
							codebf = 2;		// command to open the door and set the doort
						if (((codebf == 3) && (timers[tdwel] >= doort) && (doort != 0)) || 
							(rdinp(i_EMS) == 1))
						{
							codebf = 4;
							timers[tdwel] = 0;
//							doort = 0;
						}
					}
					else
					{	   // Rear door
						if ((rdoorf == 2) && (codebf == 2) && (rdoort != 0))
							codebf = 3;		// rear door is open
						else if ((codebf == 0) || (codebf == 1))
							codebf = 2;		// command to open the door and set the doort
						if (((codebf == 3) && (timers[trdwel] >= rdoort) && (rdoort != 0)) ||
							(rdinp(i_EMS) == 1))
						{
							codebf = 4;
							timers[trdwel] = 0;
//							rdoort = 0;
						}
					}
				}
			}
		}
		else
		{
			if (in_code_blue == 1)
			{
				in_code_blue = 0;
				doort = 0;
				rdoort = 0;
				if (servf == 5)
					servf = 1;
				if (hsvf == 0)
					clroutp(o_EML);
				med_buz = 0;
			}
			codebf = 0;
			codebfl = 0;
		}
		if (((grp_codebf[cons[carnmb]] & 0x0001) != 0) && (in_code_blue == 0))
		{
			if (ind() == 1)
			{
				if((fvars[fvcbovrind] & 0x01) !=0)
				{
					cb_over_ind = 1;
				}
				ind_codeb_alarm = 1;
				if ((fvars[fvcblight] & 0x0001) != 0) 
				{
					if (timers[tsec] != 0)
					{
						setoutp(o_EML);
						med_buz = 1;
					}
					else
					{
						clroutp(o_EML);
						med_buz = 0;
					}
				}
				else
				{
					setoutp(o_EML);
					med_buz = 1;
				}
			}
		}
		else if (ind_codeb_alarm == 1)
		{
			ind_codeb_alarm = 0;
			if (hsvf == 0)
				clroutp(o_EML);
			med_buz = 0;
		}

		if(cb_over_ind == 1)
		{
			if(codebf == 3)
				cb_over_ind = 0;
		}
		else
		{
			timers[tcbovrind] = 0;
		}
		
		if (in_code_blue == 1)
		{		// code blue or hospital service
			if ((fvars[fvcblight] & 0x0001) != 0) 
			{
				if (timers[tsec] != 0)
				{
					setoutp(o_EML);
					if (ind() == 1)
						med_buz = 1;
				}
				else
				{
					clroutp(o_EML);
					med_buz = 0;
				}
			}
			else
			{
				setoutp(o_EML);
				if (ind() == 1)
					med_buz = 1;
				else
					med_buz = 0;
			}
		}
	}
	else
	{
		in_code_blue = 0;
		if (servf == 5) 
		{
			servf = 1;
			med_buz = 0;
		}
		codebf = 0;
		codebfl = 0;
	}
	
	if((fvars[fvcbbuz] == 1)&&(ind_codeb_alarm == 0))
	{
		if((codebf == 1)||(codebf == 2))
			med_buz = 1;
		else
			med_buz = 0;
	}
	
}

//**************************************************************************
// Set hospital service flag (part of code blue operation ******************
//**************************************************************************

void sethsvf(void)
{
	if (cons[cblue] == 1)
	{
		if (((codebf == 0) || (codebf == 4)) && ((firef == 0) || (hsvf == 1)))
		{

			if ((fvars[fvhsaftercb] == 0) || (codebf == 4) || (hsvf == 1))
			{
				if (rdinp(i_EMS) == 1)
				{
					if (hsvf == 0)
					{
						clrcc(0);
						dpref = 0;
						clr_dir_arrow();
			    	}
					hsvf = 1;
				}
				else
					hsvf = 0;
			}
			
			if (hsvf == 1)
			{
		    	servf = 22;
				if ((fvars[fvcblight] & 0x0001) != 0) 
				{
					if (timers[tsec] != 0)
					{
						setoutp(o_EML);
						if (cons[GLBP_LED] == 0)
							setoutp(o_EMLH);
					}
					else
					{
						clroutp(o_EML);
						if (cons[GLBP_LED] == 0)
							clroutp(o_EMLH);
					}
				}
				else
				{
					setoutp(o_EML);
					if (cons[GLBP_LED] == 0)
						setoutp(o_EMLH);
				}
			}
			else 
			{
				if (ind_codeb_alarm == 0)
					clroutp(o_EML);
				if (cons[GLBP_LED] == 0)
					clroutp(o_EMLH);
			}
		}
		else
		{
			if (servf == 22)
				servf = 1;
			hsvf = 0;
		}
	}
	else
	{
		if (servf == 22)
			servf = 1;
		hsvf = 0;
	}
}

// *******************************************
// This is set Earthquake flags procedure
// *******************************************

void seteqf(void)
{

#if ((Traction == 1) || (Tract_OL == 1))

  	if(cons[equake] == 1)
  	{
		if ((rdinp(i_ETH) == 0) && 
			(rdinp(i_COL) == 0))
		{
			timers[tcol] = 0;
		}

  		if ((eqf != 0) || (((rdinp(i_ETH) == 1) || 
  				(rdinp(i_COL) == 1)) 
  				&& (rdinp(i_LC) == 1) && (timers[tcol] > 1)))
  		{

			setoutp(o_EQL);
			setoutp(o_EQLC);

			if (eqf == 0)
			{
				if ((rdinp(i_COL) == 1) && (rdinp(i_LC) == 1))
					eqf = 2;			// emergency stop	
				else 
					eqf = 1;			// Stop at next landing
			}
			else
			{
				if ((eqf == 1) && (rdinp(i_COL) == 1) && (rdinp(i_LC) == 1))
					eqf = 2;			// emergency stop
				else if ((eqf == 2) && ((estop == 1) || ((procf < 3) || (procf > 11))))	// not moving
					eqf = 3;			// Recover away from the counterweight
				else if (((eqf == 1) || (eqf == 3)) && ((procf < 3) || (procf > 11)) && (rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))
					eqf = 4; 			// dead level at a floor and not moving
			}						

			if ((rdinp(i_EQR) == 1) && 
				(rdinp(i_ETH) == 0) && 
				(rdinp(i_COL) == 0) && (rdinp(i_LC) == 1))
				eqf = 0;

			if (eqf == 4)	// prevents the car call from being set on fire service
				clrcc(0);
	
			servf = 8;		 
			
		}
		else 
		{
			eq_pos_reset = 0;
			eqf = 0;
			clroutp(o_EQL);
			clroutp(o_EQLC);
			if (servf == 8)
				servf = 1;
		}
	}
	else
	{
		eq_pos_reset = 0;
		eqf = 0;
		if (servf == 8)
			servf = 1;
	}
#else
  	if(cons[equake] == 1)
  	{
  		if ((eqf != 0) || ((rdinp(i_ETH) == 1) && (rdinp(i_LC) == 1)))
  		{

			setoutp(o_EQL);
			setoutp(o_EQLC);

			if (eqf == 0)
			{
				eqf = 1;			// Stop at next landing
			}
			else
			{
				if ((eqf == 1) && ((procf < 3) || (procf > 11)) && (rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))
					eqf = 4; 			// dead level at a floor and not moving
			}						

			if ((rdinp(i_EQR) == 1) && (rdinp(i_ETH) == 0) && (rdinp(i_LC) == 1))
				eqf = 0;

			if ((eqf == 2) || (eqf == 3))		// invalid modes for a hydro
				eqf = 1;

			if (eqf == 4)	// prevents the car call from being set on fire service
				clrcc(0);

			servf = 8;		 
			
		}
		else 
		{
			eq_pos_reset = 0;
			eqf = 0;
			clroutp(o_EQL);
			clroutp(o_EQLC);
			if (servf == 8)
				servf = 1;
		}
	}
	else
	{
		eq_pos_reset = 0;
		eqf = 0;
		if (servf == 8)
			servf = 1;
	}
#endif
}

// *******************************************
// This is set Emergency Power flags procedure
// *******************************************

void setempf()
{

	// Traction Car

#if ((Traction == 1) || (Tract_OL == 1))
	if (cons[Emp_Recover] != 0)
	{
		if (rdinp(i_EMP) == 1)
		{
			if ((rdinp(i_DZ) == 1) && (rdinp(i_UL) == 1) && (rdinp(i_DL) == 1) && (rdoutp(o_RUN) == 0))
			{				   // level and not commanding a run (if run up when empf changed soft stop is dropped)
		   		if ((timers[tdwel] >= fvars[fvhcdt]) && (procf >= 14) && (procf <= 16))	// Door will open from the door routine, cloose door after dwell time
		   			empf = ep_home_close;
				else
					empf = ep_wait_door;
				if ((doorf == 1) || (rdoorf == 1))
				{
					doort = fvars[fvhcdt];
					if (empf == ep_home_close)
						empf = ep_wait_door;					// Dwell door on a reopen
				}

			}
			else
				empf = ep_select;
		}
		else
			empf = no_ep;	// no longer on emergency power
	}
	else
	{

	  	if((rdinp(i_EMP) == 1) || ((rdinp(i_EPT) == 1) && ((cons[EMPop] & 0x01) != 0)) || ((gempf != no_ep) && (Group_Comm == 1)))
	  	{				// on emergency power
			if ((rdinp(i_EPT) == 1) && ((cons[EMPop] & 0x01) != 0))	   // Must stop the car
				empf = ep_wait_door;
			else if (Group_Comm == 1)
			{
				if (gempf == ep_recall)
				{
		 			if ((medf == 1) || (medf == 2))
		 				ep_recall_fl = fvars[fvmedfl];
		 			else if(firef == 1)
		 				ep_recall_fl = fvars[fvfs1f];
		 			else if (firef == 2)
		 				ep_recall_fl = fvars[fvfs1af];
		 			else if (firef == 3)
		 				ep_recall_fl = position;	// current floor
		 			else
		 				ep_recall_fl = fvars[fvepfl];
		 
		 			if (((position == ep_recall_fl) && (procf >= 14) && (procf <= 16)) &&	 // AT the return floor
						((servf != 0) && (servf != 2) && (servf != 4) && (servf != 6) && (servf != 8) &&  // ots, ind, att, f2, eq
						 (servf != 14) && (servf != 15) && (servf != 19) && (servf != 20) && (servf != 21)) ) // stall, rtl, cse, hse, lowPres
		 				empf = ep_home;
		 			else
		 				empf = ep_recall;
				}
				else if ((gempf == ep_select) || (gempf == ep_switch))
					empf = ep_select;	// car selected to run from manual switch or after auto recall
				else if ((gempf == ep_wait) || (gempf == no_ep))
					empf = ep_wait;		// Wait	for the group to direct the car
				else if ((gempf == ep_timed_out) || (gempf == ep_out_of_svc) || (gempf == ep_wait_door))
					empf = ep_wait_door;  // Wait with doors open
				else if (gempf == ep_home)
				{
					if ((fvars[fvdenfsv] == 1) && ((firef != 0) || (rfiref != 0)))
					{				   // Special denver fire service closes the door after time-out on phase 1.
				   		if (timers[tdwel] >= fvars[fvf1dwell])	// Door will open from the door routine, cloose door after dwell time
				   			empf = ep_home_close;
						else
						{		 // fire door opened here
							fire_fdo_seq = 1;
							fire_rdo_seq = 1;
							empf = ep_wait_door;
						}

						if ((empf == ep_home_close) && ((doorf == 1) || (rdoorf == 1)))
							empf = ep_wait_door;					// Dwell door on a reopen
					}
					else
						empf = ep_home;			// group considered car a home floor
				}
				else if (position != ep_recall_fl)
					empf = ep_wait_door;  // Wait with doors open
			}
			else if (rdinp(i_EPS) == 1)
				empf = ep_select;		// car manually selected and no group comm
			else 
				empf = ep_wait_door;
	  	}
		else
		{
			empf = no_ep;	// no longer on emergency power
			ep_recall_fl = fvars[fvepfl];
		}
	}		
#else

	// Hydro Car
	if ((cons[EMPop] & 0x02) != 0)
	{
	  	if((rdinp(i_EMP) == 1) || ((rdinp(i_EPT) == 1) && ((cons[EMPop] & 0x01) != 0)) || ((gempf != no_ep) && (Group_Comm == 1)))
	  	{				// on emergency power
			hydro_on_emp = 1; 
			if ((rdinp(i_EPT) == 1) && ((cons[EMPop] & 0x01) != 0))	   // Must stop the car
			{
		   		if ((timers[tdwel] >= fvars[fvhcdt]) && (procf >= 14) && (procf <= 16))	// Door will open from the door routine, cloose door after dwell time
		   			empf = ep_home_close;
				else
					empf = ep_wait_door;
				if ((empf == ep_home_close) && ((doorf == 1) || (rdoorf == 1)))
					empf = ep_wait_door;					// Dwell door on a reopen
			}
			else if (Group_Comm == 1)
			{
				if (gempf == ep_recall)
				{
		 			if ((medf == 1) || (medf == 2))
		 				ep_recall_fl = fvars[fvmedfl];
		 			else if(firef == 1)
		 				ep_recall_fl = fvars[fvfs1f];
		 			else if (firef == 2)
		 				ep_recall_fl = fvars[fvfs1af];
		 			else if (firef == 3)
		 				ep_recall_fl = position;	// current floor
		 			else
		 				ep_recall_fl = fvars[fvepfl];
		 
		 			if (((position == ep_recall_fl) && (procf >= 14) && (procf <= 16)) &&	 // AT the return floor
						((servf != 0) && (servf != 2) && (servf != 4) && (servf != 6) && (servf != 8) &&  // ots, ind, att, f2, eq
						 (servf != 14) && (servf != 15) && (servf != 19) && (servf != 20) && (servf != 21)) ) // stall, rtl, cse, hse, lowPres
		 				empf = ep_home;
		 			else
		 				empf = ep_recall;
				}
				else if ((gempf == ep_select) || (gempf == ep_switch))
					empf = ep_select;	// car selected to run from manual switch or after auto recall
				else if ((gempf == ep_wait) || (gempf == no_ep))
					empf = ep_wait;		// Wait	for the group to direct the car
				else if (gempf == ep_home)
				{
			   		if (timers[tdwel] >= fvars[fvhcdt])	// Door will open from the door routine, cloose door after dwell time
			   			empf = ep_home_close;
					else
						empf = ep_wait_door;
					if ((empf == ep_home_close) && ((doorf == 1) || (rdoorf == 1)))
						empf = ep_wait_door;					// Dwell door on a reopen
				}
				else   
				{
					if ((empf == ep_wait) || (empf == epc_wait_close))
					{
						if ((doorf == 1) || (rdoorf == 1))
							empf = ep_wait_door;					// Dwell door on a reopen

						if ((doorf == 0) && (rdoorf == 0))
							empf = ep_wait;
					}
					else if (empf == ep_wait_door)
					{
						if (timers[tdwel] >= fvars[fvhcdt])	// Door will open from the door routine, cloose door after dwell time
			   				empf = epc_wait_close;
					}
					else
						empf = ep_wait;
						
				}

			}
			else if (rdinp(i_EPS) == 1)
				empf = ep_select;		// car manually selected and no group comm
			else 
			{
		   		if (timers[tdwel] >= fvars[fvhcdt])	// Door will open from the door routine, cloose door after dwell time
		   			empf = ep_home_close;
				else
					empf = ep_wait_door;
				if ((empf == ep_home_close) && ((doorf == 1) || (rdoorf == 1)))
					empf = ep_wait_door;					// Dwell door on a reopen
			}
	  	}
		else
		{
			hydro_on_emp = 0; 
			empf = no_ep;	// no longer on emergency power
			ep_recall_fl = fvars[fvepfl];
		}
	}
	else
	{
	  	if(rdinp(i_EMP) == 1)
	  	{				// on emergency power
			hydro_on_emp = 1; 
			if (empf == 0)
				clrcc(0);		// clear car calls on first entry (This will cancel the calls on a Phase 2 car)
			if (gempf == ep_recall)
			{
	 			if ((medf == 1) || (medf == 2))
		 			ep_recall_fl = fvars[fvmedfl];
				else if (firef == 1)
					ep_recall_fl = fvars[fvfs1f];
				else if (firef == 2) 
					ep_recall_fl = fvars[fvfs1af];
				else if (firef == 3)
					ep_recall_fl = position;	// current floor
				else
					ep_recall_fl = cons[bottomf];		// Set floor to bottom

				if ((((position == ep_recall_fl) || (rdinp(i_DT) == 0)) && (procf >= 14) && (procf <= 16)) && // AT the return floor
					((ind() == 0) && ((rdinp(i_ATT) == 0) || (cons[att] == 0)) && (stallf == 0))) // Can run on emp
						empf = ep_home;
				else
					empf = ep_recall;
		   	}
		   	else if ((gempf == ep_select) || (gempf == ep_switch))
		   		empf = ep_select;	// car selected to run from manual switch or after auto recall
		   	else if ((empf == ep_home) || (empf == ep_home_close)) // allow door to close after dwell time-out
		   	{
		   		if (timers[tdwel] >= fvars[fvhcdt])	// Door will open from the door routine, cloose door after dwell time
		   			empf = ep_home_close;
				if ((empf == ep_home_close) && ((doorf == 1) || (rdoorf == 1)))
					empf = ep_home;					// Dwell door on a reopen
		   	}
	  	}
		else
		{
			hydro_on_emp = 0; 
			empf = no_ep;	// no longer on emergency power
			ep_recall_fl = fvars[fvepfl];
		}
	}

	prev_hydro_on_emp = hydro_on_emp;

#endif

	if ((empf >= ep_wait) && (empf != ep_select))
	{
		if ((servf != 0) && (ep_recall_ok() == 1))
			servf = 7;		// Only show emergency power if automatic
	}
	else if (servf == 7)
		servf = 1;			// first time out of emergency power

}

// *********************************************
// This is set the fire service flags procedure
// *********************************************
void setfsf()
{
  	int16 A_Door_Is_Open = 0;
	int16 fire_sw_loc = 0;
	Extinguish_FSL = 0;

#if ((Traction == 0) && (Tract_OL == 0))


	switch(off_FSL_state)
	{
		case 0://firef and stallf = 0
			if (stallf != 0)
				off_FSL_state = 1;
			if(firef != 0)
				off_FSL_state = 2;
			break;
		case 1: // already LOS condition. Wait for firef to change
			if(firef != 0)		
				off_FSL_state = 3;
			break;
		case 2:
			if(firef == 3)		// successful fs recall		
				off_FSL_state = 4;
			if (stallf != 0)
				off_FSL_state = 5;
			break;
		case 3:
			if(firef == 3)		// successful fs recall		
				off_FSL_state = 6;
			if(stallf == 4)		//finished Low Oil recall
				off_FSL_state = 7;
			break;
		case 4:
			if (stallf != 0)
				off_FSL_state = 6;
			break;
		case 5:
			if(firef == 3)		// successful fs recall		
				off_FSL_state = 6;
			else if (stallf == 4)	//finished Low Oil recall
				off_FSL_state = 7;
			break;
		case 6: // Let it Flash and Check position to see if it is possible to run
			if(position == cons[bottomf])
				off_FSL_state = 7;	
			break;
		case 7:	//Extinguish the output
			break;
		default:
			break;
	}
	if ((firef == 0) && (stallf == 0))
	{
		Extinguish_FSL = 0;
		off_FSL_state = 0;
	}
	else if (off_FSL_state == 7)
		Extinguish_FSL = 1;

#endif

	if((firef == 0) || (firef == 1) || (firef == 2)) // 2007 rule only applies for when firef == 3 so clear state for variable
	{
		fire_stopsw_hold = 0;
	}


	// Fires phase 2 switch logic

	if (cons[Australia] == 1)
	{
		fs2_on = (rdinp(i_FS2) == 0) || (rdinp(i_FS2H) == 1);
		fs2_hold = 0;
		fs2_start = (rdinp(i_FS2H) == 1);
	}
	else
	{
		if (cons[FS2_SW] == 1)	// New logic FS2 = NOT FS2 and NOT FS2H, HOLD = FS2H, OFF = FS2
			fs2_on = (rdinp(i_FS2) == 0) && (rdinp(i_FS2H) == 0);
		else					// Original logic FS2 = FS2 input, HOLD = FS2H, OFF = NOT FS2 and NOT FS2H
			fs2_on = (rdinp(i_FS2) == 1);
		fs2_hold = (rdinp(i_FS2H) == 1);
		fs2_start =0;
	}
		

	// read the hall fire inputs
	if (cons[Australia] == 0)
	{
		if (rdinp(i_MES) == 1)
			mes_on = 0;
		else
			mes_on = 1;

		if (rdinp(i_ALT) == 1)
			alt_on = 0;
		else
			alt_on = 1;

		if (rdinp(i_MRS) == 1)
			mrs_on = 1;
		else
			mrs_on = 0;

		if (rdinp(i_HWS) == 1)
			hws_on = 1;
		else
      		hws_on = 0;

		if (cons[Smoke_2004] == 1)
		{
			if (rdinp(i_HWS2) == 1) 
				hws2_on = 1;
			else
				hws2_on = 0;
		}
		else
			hws2_on = 0;

		if (rdinp(i_BP) == 1)
			fs1_reset_on = 1;
		else
			fs1_reset_on = 0;
    	
	}
	else
	{
		mes_on = 0;
		alt_on = 0;
		mrs_on = 0;
		hws_on = 0;
		hws2_on = 0;
		fs1_reset_on = 0;
	}

	if (((cons[firesv] == 2) && (fvars[fvfsx] == 1)) || (cons[FSX_rear] == 1) || (cons[firesv] == 3)) 
    {
    	if (rdinp(i_FSX) == 1)
			fsx_on = 1;
		else
			fsx_on = 0;
	}
	else 
		fsx_on = 0;
	
	if (rdinp(i_FS) == 1) 
		fs_on = 1;
	else
		fs_on = 0;

  	if(firef == 0)
  	{
		fire_reset = 0;
		fire_sensor = 0;
    	fs1_effect = 0;
    	Blink_FSL = 0;
		Extinguish_FSL = 0;
		fire_status = 0;

    	if( (mes_on == 0) && (alt_on == 0) &&
			(fs_on == 0) && (hws_on == 0) && ((hws2_on == 0) || (cons[Smoke_2004] == 0)) &&
			((fsx_on == 0) || (((cons[firesv] != 2) || (fvars[fvfsx] == 0)) && (cons[FSX_rear] == 0) && (cons[firesv] != 3))) &&
			(mrs_on == 0) )
	    	timers[tfs1t] = 0;

		if( (cons[Smoke_2004] == 1) && ((g_fire_ctrl & 0x1C) != 0) && (Group_Comm == 1) && 
			((fs1_reset_on == 0) || (cons[firesv] == 2) || (cons[firesv] == 3)))
		{		   // Another car has smoke in the hoistway
	    	fs1_effect = 1;
	    	firef = 1;                // smoke detector any floor
	    	rfiref = 1;
			fire_sensor = 1;
			fire_status |= 0x80;
		}

	    if( (mes_on == 1) && ((fs1_reset_on == 0) || (cons[firesv] == 2) || (cons[firesv] == 3)) &&
			((rdinp(i_HC) == 1) || ((rdinp(i_LC) == 1) && (cons[HCP_Fuse] == 1))) && 
			(timers[tfs1t] > 20) )		 // ansi 2000 activates sensor even if reset on
	    {															 // chigaco has no reset or bypass switch
	    	fs1_effect = 1;
	    	firef = 1;                // smoke detector any floor
	    	rfiref = 1;
			fire_sensor = 1;
			fire_status |= 0x01;
	    }
		//smoke detector in elevator hoistway
	    if( (hws_on == 1) && ((fs1_reset_on == 0) || (cons[firesv] == 2) || (cons[firesv] == 3)) &&
			((rdinp(i_HC) == 1) || ((rdinp(i_LC) == 1) && (cons[HCP_Fuse] == 1))) && 
			(timers[tfs1t] > 20) )
	    {															  // ansi 2000 activates sensor even if reset on
	    	fs1_effect = 1;											  // chigaco has no reset or bypass switch
			if (fvars[fvfhwsen] == 1)
			{
	    		firef = 2;                // smoke detector in hoistway	go to alternate landing
	    		rfiref = 2;
			}
			else
			{
	    		firef = 1;                // smoke detector in hoistway
	    		rfiref = 1;
	    	}
	    	Blink_FSL = 1;
			fire_sensor = 1;
			fire_status |= 0x08;
	    }
	    if( ((cons[Smoke_2004] == 1) && (hws2_on == 1)) && ((fs1_reset_on == 0) || (cons[firesv] == 2) || (cons[firesv] == 3)) &&
			((rdinp(i_HC) == 1) || ((rdinp(i_LC) == 1) && (cons[HCP_Fuse] == 1))) && 
			(timers[tfs1t] > 20) )
	    {															  // ansi 2000 activates sensor even if reset on
	    	fs1_effect = 1;											  // chigaco has no reset or bypass switch
			if (fvars[fvfhws2en] == 1)
			{
	    		firef = 2;                // smoke detector in hoistway	go to alternate landing
	    		rfiref = 2;
			}
			else
			{
	    		firef = 1;                // smoke detector in hoistway
	    		rfiref = 1;
	    	}
			if(fvars[fvfhws2loc] == 0)
	    		Blink_FSL = 1;
			fire_sensor = 1;
			fire_status |= 0x10;
	    }
	    if( (mrs_on == 1) && ((fs1_reset_on == 0) || (cons[firesv] == 2) || (cons[firesv] == 3)) &&
			((rdinp(i_HC) == 1) || ((rdinp(i_LC) == 1) && (cons[HCP_Fuse] == 1))) && 
			(timers[tfs1t] > 20) )			  // ansi 2000 activates sensor even if reset on
	    {															  // chigaco has no reset or bypass switch
	    	fs1_effect = 1;
			if (fvars[fvfmrsen] == 1)
			{
	    		firef = 2;                // smoke detector in the machine room go to alternate landing
	    		rfiref = 2;
			}
			else
			{
	    		firef = 1;                // smoke detector in the machine room
	    		rfiref = 1;
			}
	    	Blink_FSL = 1;
			fire_sensor = 1;
			fire_status |= 0x04;
	    }
	    if( (alt_on == 1) && ((fs1_reset_on == 0) || (cons[firesv] == 2) || (cons[firesv] == 3)) &&
			((rdinp(i_HC) == 1) || ((rdinp(i_LC) == 1) && (cons[HCP_Fuse] == 1))) && 
			(timers[tfs1t] > 20) )			  // ansi 2000 activates sensor even if reset on
	    {															  // chigaco has no reset or bypass switch
	    	fs1_effect = 1;
	    	firef = 2;                // smoke detector at lobby
	    	rfiref = 2;
			fire_sensor = 2;
			fire_status |= 0x02;
	    }
		

    	if ( (fs_on == 1) && (timers[tfs1t] > 20) )
    	{
      		fs1_effect = 1;           // fire service switch in lobby
      		firef = 1;
      		rfiref = 1;
			fire_status |= 0x20;
    	}
    	
    	if ( (fsx_on == 1) && 
    			(((cons[firesv] == 2) && (fvars[fvfsx] == 1)) || (cons[FSX_rear] == 1) || (cons[firesv] == 3)) && 
    			(timers[tfs1t] > 20) )
    	{
      		fs1_effect = 1;           // fire service switch in lobby
      		firef = 1;
      		rfiref = 1;
			fire_status |= 0x20;
    	}
    	return;
  	}
	else
	{
		if (mes_on == 0)
			fire_status &= ~0x01;

		if (alt_on == 0)
			fire_status &= ~0x02;

		if (mrs_on == 0)
			fire_status &= ~0x04;
		else
      		Blink_FSL = 1;

		if (hws_on == 0)
			fire_status &= ~0x08;
		else
      		Blink_FSL = 1;

		if (cons[Smoke_2004] == 1)
		{
			if (hws2_on == 0) 
				fire_status &= ~0x10;
			else if (fvars[fvfhws2loc] == 0) // Blink the FSL if HW sensor is located in the same HW
	      		Blink_FSL = 1;
		}
		else
			fire_status &= ~0x10;

    	
		if (((cons[firesv] == 2) && (fvars[fvfsx] == 1)) || (cons[FSX_rear] == 1) || (cons[firesv] == 3)) 
    	{
    		if ((fs_on == 1) || (fsx_on == 1))
				fire_status |= 0x20;
			else
				fire_status &= ~0x20;
		}
		else 
		{
			if (fs_on == 1) 
				fire_status |= 0x20;
			else
				fire_status &= ~0x20;
		}
	}

  	if((firef != 0) || (rfiref != 0))
  	{
		// Fire service phase 1 reset

		if (cons[firesv] == 0)
		{	   // ansi 1996
			if (((fs1_reset_on == 1) && (fs_on == 0)) ||    // Smoke detector by pass
				((fire_sensor == 0) && (fs_on == 0)))
				fire_reset = 1;
			else if ((mes_on == 1) || (alt_on == 1) ||
				(fs_on == 1) || (hws_on == 1) || 
				((hws2_on == 1) && (cons[Smoke_2004] == 1)) ||
				(mrs_on == 1)) 
				fire_reset = 0;					 // fire device still active
			if ((fire_reset == 1) && (firef <= 3))
			{
				if ((firef == 3) || ((fs2_to_fs1 == 0) && ((fvars[fvfire_rst] & 0x01) != 0)) 
					|| ((servf != 0) && (servf != 6) && (servf != 9) && (servf != 10)))
				{
					fs1_effect = 0;
					fire_reset = 0;
			  		rfiref = 0;
			  		firef = 0;
					fire_buz = 0;
					fire_status = 0;
			  		clroutp(o_FL);      // Turn off the fire service light
		  		}
			}
		}
	  	else if ((cons[firesv] == 1) || (cons[firesv] == 3))   // New York or Chicago Fire service
	  	{
	      	if ((fs_on == 0)&&(mes_on == 0)&&
		 		(alt_on == 0) && (hws_on == 0) &&	 
		 		((hws2_on == 0) || (cons[Smoke_2004] == 0)) &&
		 		(mrs_on == 0) && ((fsx_on == 0) || ((cons[FSX_rear] == 0) && (cons[firesv] != 3))) )
			{				  // all fire devices are off
				if ((fire_sensor == 0) || ((firef == 3) && (fire_sensor != 0)))
					fire_reset = 1;	   // activated from the fs switch or (activated from sensor but car has returned)
			}
			else  
				fire_reset = 0;				  // fire device still active
			if ((fire_reset == 1) && (firef <= 3))
		  	{
				if ((firef == 3) || ((fs2_to_fs1 == 0) && ((fvars[fvfire_rst] & 0x01) != 0)) 
					|| ((servf != 0) && (servf != 6) && (servf != 9) && (servf != 10)))
				{
					fs1_effect = 0;
					fire_reset = 0;
			  		rfiref = 0;
			  		firef = 0;
					fire_buz = 0;
					fire_status = 0;
			  		clroutp(o_FL);      // Turn off the fire service light
		  		}
			}
	  	}
	  	else  // else ansi 2000
	  	{
		    if ((fs1_reset_on == 1) && (mrs_on == 0) && (cons[Australia] == 0) &&
			 	(mes_on == 0) && (alt_on == 0) &&
			 	(fs_on == 0) && ((fsx_on == 0) || (fvars[fvfsx] == 0)) && 
			 	(hws_on == 0) && ((hws2_on == 0) || (cons[Smoke_2004] == 0)) &&
			 	((cons[Smoke_2004] == 0) || ((g_fire_ctrl & 0x1C) == 0)) )    // Fire reset switch
				fire_reset = 1;
			else if ((cons[FSautoRST] == 1) && (fire_reset == 0) && (mrs_on == 0) &&
			 	(mes_on == 0) && (alt_on == 0) &&
			 	(fs_on == 0) && ((fsx_on == 0) || (fvars[fvfsx] == 0)) && 
			 	(hws_on == 0) && ((hws2_on == 0) || (cons[Smoke_2004] == 0)) &&
			 	((cons[Smoke_2004] == 0) || ((g_fire_ctrl & 0x1C) == 0)) )    // Fire reset switch
				fire_reset = 1;
			else if ((mes_on == 1) || (alt_on == 1) || 
				(fs_on == 1) || ((fsx_on == 1) && 
				(fvars[fvfsx] == 1)) || (hws_on == 1) ||
				(mrs_on == 1) || ((hws2_on == 1) && (cons[Smoke_2004] == 1)) ||
				((cons[Smoke_2004] == 1) && ((g_fire_ctrl & 0x1C) != 0)) ) 
				fire_reset = 0;
		    else if (((fire_reset == 1) || (cons[Australia] == 1) || ((fire_sensor == 0) && ((fvars[fvfire_rst] & 0x02) != 0))) && (firef <= 3))
		    {		 // reset then off  or sensor was not set and allowed to reset (FS only) from OFF position
				if ((firef == 3) || ((fs2_to_fs1 == 0) && ((fvars[fvfire_rst] & 0x01) != 0)) 
					|| ((servf != 0) && (servf != 6) && (servf != 9) && (servf != 10)))
				{
					if ((fs_on == 0) && ((fsx_on == 0) || (fvars[fvfsx] == 0)))
					{
						fs1_effect = 0;
						fire_reset = 0;
						rfiref = 0;
						firef = 0;
						fire_buz = 0;
						fire_status = 0;
						clroutp(o_FL);      // Turn off the fire service light
					}
				}
		    }
	  	}

		if (firef > 3)
		{		 // Determine which floor the phase 2 car sees as the fire_floor
    		if (((mes_on == 1) || (alt_on == 1) || 
				(fs_on == 1) || (hws_on == 1) || 
				((hws2_on == 1) && (cons[Smoke_2004] == 1)) ||
				((fsx_on == 1) && (((cons[firesv] == 2) && (fvars[fvfsx] == 1)) || (cons[FSX_rear] == 1) || (cons[firesv] == 3))) ||
				(mrs_on == 1)) && ((fs1_reset_on == 0) || (cons[firesv] == 2) || (cons[firesv] == 3))) 
			{
				fs1_effect = 1;
				if (cons[firesv] == 2)
				{
					if ((fs_on == 1) && ((fsx_on == 1) || (fvars[fvfsx] == 0)))
						fire_floor = fvars[fvfs1f];
					else if ((fire_sensor == 2) && (alt_on == 1) && 
						(fs_on == 0) && ((fsx_on == 0) || (fvars[fvfsx] == 0)))
						fire_floor = fvars[fvfs1af];
				}
				else if ((fs_on == 1) || ((fsx_on == 1) && ((cons[FSX_rear] == 1) || (cons[firesv] == 3))))
					fire_floor = fvars[fvfs1f];
				else if (cons[firesv] == 3)
				{			 // return to active fire floor
					if (alt_on == 1)
						fire_floor = fvars[fvfs1af];
					else if ((mes_on == 1) || (hws_on == 1) || 
						((hws2_on == 1) && (cons[Smoke_2004] == 1)) || (mrs_on == 1))
						fire_floor = fvars[fvfs1f];
				}
			}
			else if (cons[firesv] == 3)
				fs1_effect = 0;		  // chicago fire service (no fire input is on)
			else if (cons[firesv] == 2)
			{
				if ((fire_sensor != 0) || ((fvars[fvfire_rst] & 0x02) == 0)) 
				{				// Sensors were activated or must always see the reset input
					if ((fs1_reset_on == 1) && (cons[firesv] == 2))
						fs1_effect_reset = 1;
					else if ((fs1_reset_on == 0) && (fs1_effect_reset == 1))
					{
						fs1_effect = 0;
						fs1_effect_reset = 0;
					}
					else
						fs1_effect_reset = 0;
				}
				else if ((fs_on == 0) && ((fsx_on == 0)	|| (fvars[fvfsx] == 0)))
				{		// Allow reset for FS key only recall when key switch is off
					fs1_effect = 0;
					fs1_effect_reset = 0;
				}
			}
			else if ((fire_sensor == 0) && (fs_on == 0) && (cons[firesv] != 2))
				fs1_effect = 0;		// new york or ansi 96 but not ansi 2000
			else if ((fs1_reset_on == 1) && (cons[firesv] == 0))
				fs1_effect = 0;		// ansi 96 only
		}
    	if(firef == 1)       // fire service phase 1 main lobby return
    	{
			if ((empf != 0) && (empf != ep_select) && (empf != ep_recall) && (fvars[fvflemp] == 1))
	      		clroutp(o_FL);                // Turn off Fire service light
			else if (((eqf != 0) || (stallf != 0)) && (fvars[fvflots] == 1))
	      		clroutp(o_FL);                // Turn off Fire service light
			else if (Extinguish_FSL == 1)
	      		clroutp(o_FL);                // Turn off Fire service light
	  		else if (((Blink_FSL == 1) || (eqf != 0) || (stallf != 0))&& (timers[tsec] != 0))
	      		clroutp(o_FL);                // Turn off Fire service light
			else
	  			setoutp(o_FL);				  // Turn on Fire service light

			if ((eqf != 0) || (stallf != 0) || ((empf != 0) && (empf != ep_select) && (empf != ep_recall)))
				FS_DOB_DIS = 0;			// Allow door open button at the landing if the car cannot run

	    	if ((chk_ins() == 1) || (medf != 0) || (hsvf == 1) || ((safeties() == 0) && (rdinp(i_LC) == 1)))
			{
				fire_buz = 1;
      			return;
      		}
      		else if( ((position == fvars[fvfs1f]) && (rdinp(i_DOL) == 0)) ||
	  		((position == fvars[fvfs1f]) && (rdinp(i_DOLR) == 0) &&
	    	(cons[rear] != 0)) )
      		{         // At fire service main return
				fire_buz = 0;
				firef = 3;      // completed fire service phase 1
				rfiref = 3;
      		}
      		else if ((position == fvars[fvfs1f]) && ((fvars[fvfireop] & 0x02) != 0) && (procf >= 14) && (procf <= 16))
				fire_buz = 0;		   // added for chicago fire service
			else
				fire_buz = 1;
      		servf = 9;
			fire_floor = fvars[fvfs1f];
    	}
    	if(firef == 2)     // fire service phase 1 aternate floor return
    	{
			if ((empf != 0) && (empf != ep_select) && (empf != ep_recall) && (fvars[fvflemp] == 1))
	      		clroutp(o_FL);                // Turn off Fire service light
			else if (((eqf != 0) || (stallf != 0)) && (fvars[fvflots] == 1))
	      		clroutp(o_FL);                // Turn off Fire service light
			else if (Extinguish_FSL == 1)
	      		clroutp(o_FL);                // Turn off Fire service light
	  		else if (((Blink_FSL == 1) || (eqf != 0) || (stallf != 0))&& (timers[tsec] != 0))
	      		clroutp(o_FL);                // Turn off Fire service light
			else
	  			setoutp(o_FL);				  // Turn on Fire service light

			if ((eqf != 0) || (stallf != 0) || ((empf != 0) && (empf != ep_select) && (empf != ep_recall)))
				FS_DOB_DIS = 0;			// Allow door open button at the landing if the car cannot run

	    	if ((chk_ins() == 1) || (medf != 0) || (hsvf == 1) || ((safeties() == 0) && (rdinp(i_LC) == 1)))
			{
				fire_buz = 1;
      			return;
      		}
      		else if( ((position == fvars[fvfs1af]) && (rdinp(i_DOL) == 0)) ||
	  		((position == fvars[fvfs1af]) && (rdinp(i_DOLR) == 0) &&
	    	(cons[rear] != 0)) )
      		{         // At fire service alternate return
				fire_buz = 0;
				firef = 3;      // completed fire service phase 1
				rfiref = 3;
      		}
      		else if ((position == fvars[fvfs1af]) && ((fvars[fvfireop] & 0x02) != 0) && (procf >= 14) && (procf <= 16))
				fire_buz = 0;			// added for chicago fire service
      		else
				fire_buz = 1;
	  		if (((fs_on == 1) && ((cons[firesv] != 2) || (fvars[fvfsx] == 0))) || 
	  			  ((fs_on == 1) && (cons[firesv] == 2) && (fsx_on == 1) && (fvars[fvfsx] == 1)))
			{
				rfiref = 1;
				firef = 1;
			}
      		servf = 10;
			fire_floor = fvars[fvfs1af];
    	}
		if (firef == 3)       // completed fire service phase 1
		{
			fs2_to_fs1 = 0;
			FS_DOB_DIS = 0;			// Allow door open button at the designated landing

			if ((fs_on == 1) && (cons[firesv] == 3) && ((fvars[fvfireop] & 0x01) != 0))
				Blink_FSL = 0;			// added for chicago fire service
						
			if (cons[firesv] == 2)
			{
				if ((fs_on == 1) && ((fsx_on == 1) || (fvars[fvfsx] == 0) || (fvars[fvrecallfs1a] == 1)) &&
				  	(position != fvars[fvfs1f]))
		  		{
			  		firef = 1;
			  		rfiref = 1;
					if (fvars[fvaltrclfs] == 0)
						fire_sensor = 0;		// once recalled from FS stay at the main fire floor
		  		}
				else if ((fire_sensor == 2) && ((alt_on == 1) || ((fvars[fvaltrclfs] & 0x02) != 0)) &&
					 (fs_on == 0) && ((fsx_on == 0) || (fvars[fvfsx] == 0)) &&
					 (position != fvars[fvfs1af]))
				{			  // if sensor still active allow return to alternate floor for fire service
		  			firef = 2;	   // this check is here in case the car has to recover to another floor from going out of the door zone.
		  			rfiref = 2;
				}
			}
	  		else if((fs_on == 1) && (position != fvars[fvfs1f]))
	  		{
		  		firef = 1;
		  		rfiref = 1;
	  		}
			if ((cons[firesv] == 3) && (fs_on == 0) && (position != fvars[fvfs1af]) && 
					(fire_sensor == 2) && (alt_on == 1))
			{			  // if sensor still active allow return to alternate floor for chicago fire service
	  			firef = 2;
	  			rfiref = 2;
			}
			// fire service return to lobby key switch
	  		if ((fs2_on == 1) && // fire service phase 2
					(((fs_on == 1) && ((position == fvars[fvfs1f]))) || (cons[firesv] != 3)))
	  		{			   // only chicago fire srevice must have the phase 1 switch on (not just a smoke sensor)
							// and at the main fire recall landing
		  		servf = 6;
		  		if(cons[firesv] == 1)   // New York Fire service
		  		{
			 		if(rdinp(i_DCL) == 1)
						firef = 8;    // momentary presure of dcb will close doors
			 		else
						firef = 5;	// peekaboo door open
			 		if(cons[rear] != 0)
			 		{
				 		if(rdinp(i_DCLR) == 1)
					 		rfiref = 8;    // momentary presure of dcb will close doors
				 		else
					 		rfiref = 5;	// peekaboo rear door open
			 		}
		  		}
		  		else if (cons[firesv] == 3)
				{	// Chicago fire service
					firef = 5;			// fire flag will be set again in (firef == 5) section
			  		if (cons[rear] != 0) 
				  		rfiref = 5;    // fire flag will be set again in (firef == 5) section
				}
		  		else
		  		{	   // ansi 1996 or 2000
			  		if(rdinp(i_DCL) == 1)
				  		firef = 6;    // constant presure of dcb will close doors
			  		else
				  		firef = 5;    // peekaboo door open
			  		if(cons[rear] != 0)
			  		{
				  		if(rdinp(i_DCLR) == 1)
					  		rfiref = 6;    // constant presure of dcb will close rear doors
				  		else
					  		rfiref = 5;	   // peekaboo rear door open
			  		}
		  		}
		  		return;
	  		}
			else
			{
				if (((servf != 9) && (servf != 10)) && ((empf == 0) || (empf == ep_recall) || (empf == ep_select)) )
				{	  // reset the service flag if it got cleared
					if (fire_floor == fvars[fvfs1f])
					{
						if (position != fvars[fvfs1f])
							firef = 1;
						servf = 9;	  	// Main fire floor
					}
					else if (fire_floor == fvars[fvfs1af])
					{
						if (position != fvars[fvfs1af])
							firef = 2;
						servf = 10;		// Alternate fire floor
					}
					else
					{
						if (position != fvars[fvfs1f])
							firef = 1;
						servf = 9;
					}
				}
			}
#if ((Traction == 0) && (Tract_OL == 0))
			if ((cons[EMPop] & 0x02) != 0)
			{				  // Emergency power generator
				if ((empf != 0) && (empf != ep_select) && (empf != ep_recall) && (fvars[fvflemp] == 1))
		      		clroutp(o_FL);                // Turn off Fire service light
				else if (((eqf != 0) || (stallf != 0) || (servf == 21)) && (fvars[fvflots] == 1))
		      		clroutp(o_FL);                // Turn off Fire service light
		  		else if (Extinguish_FSL == 1)
					clroutp(o_FL);                // Turn off Fire service light
		  		else if (((Blink_FSL == 1) || (eqf != 0) || (stallf != 0))&& (timers[tsec] != 0))
		      		clroutp(o_FL);                // Turn off Fire service light
		  		else
		      		setoutp(o_FL);
			}
			else
			{				// Emergency power lowering
	  			if (((Blink_FSL == 1) || (empf != 0) || (eqf != 0) || (stallf != 0)) && (timers[tsec] != 0))
		      		clroutp(o_FL);                // Turn off Fire service light
		  		else if (Extinguish_FSL == 1)
					clroutp(o_FL);                // Turn off Fire service light
		  		else
		      		setoutp(o_FL);
			}
#else 
			if ((empf != 0) && (empf != ep_select) && (empf != ep_recall) && (fvars[fvflemp] == 1))
	      		clroutp(o_FL);                // Turn off Fire service light
			else if (((eqf != 0) || (stallf != 0) || (servf == 21)) && (fvars[fvflots] == 1))
	      		clroutp(o_FL);                // Turn off Fire service light
	  		else if (((Blink_FSL == 1) || (eqf != 0) || (stallf != 0))&& (timers[tsec] != 0))
	      		clroutp(o_FL);                // Turn off Fire service light
	  		else
	      		setoutp(o_FL);
#endif

	    	if(chk_ins() == 1)
				fire_buz = 1;
			else
				fire_buz = 0;
    	}

		if ((cons[firesv] == 2) && (cons[ansi] >= 2004))
		{
			if ((rdinp(i_FFS) == 1) && 
				(rdinp(i_SS) == 1) &&
				(fire_stopsw_hold == 1))
			{
				if ((procf >= 14) && (procf <= 16)) 
					fire_stopsw_hold = 0;		// stop switch not pressed and at the floor
				else if ((procf >= 3) && (procf <= 11) && (firef != 0) && (firef <= 3))
				{				  // Trying to run the car on phase 1
					dirsel();
					if ((dpref == 1) && ((dcalls == 1) || (dcalls == 3)))
						dirf = 1;
					else if ((dpref == 2) && (dcalls > 1))
						dirf = 2;
					fire_stopsw_hold = 0;
				}
			}
		}
		else
			fire_stopsw_hold = 0;


		if (firef <= 3)
			return;

		// on phase 2
		if ((cons[firesv] == 2) && (cons[ansi] >= 2004))
		{
			if ((rdinp(i_FFS) == 0) && (rdinp(i_SS) == 1))
			{
				clrcc(0);
				dpref = 0;
				dirf = 0;
				clr_dir_arrow();
				fire_stopsw_hold = 1;
			}			
			else if (fire_stopsw_hold == 1)
			{
				dirsel();
				if (((dcalls != 0) || 
					(rdinp(i_CC(position)) == 1) ||
					((cons[rear] == 1) && (rdinp(i_CCR(position)) == 1))) &&
						((cons[Australia] == 0) || (fs2_start == 1)))
				{
					if ((dcalls & 0x1) == 1)
						dirf = 1;
					else if ((dcalls & 0x2) == 2)
						dirf = 2;
					else 
					{
#if (Traction == 1)
						if (DPP_Count < (DPP_Floor_Pos[position] + DPP_Fl_Offset[position]))
							dirf = 1;
						else 
							dirf = 2;
#else
						if (prev_dirf == 1)
						{
							if ((stepf == 0) || (pass_fl == 1))
								dirf = 1;
							else
								dirf = 2;
						}
						else if (prev_dirf == 2)
						{
							if ((stepf == 0) || (pass_fl == 1))
								dirf = 2;
							else
								dirf = 1;
						}
						else  
							dirf = 2;
#endif 			
					}
					fire_stopsw_hold = 0;
				}

			}
		}
		if ((cons[firesv] == 3) && ((fvars[fvfireop2] & 0x02) != 0))   // chicago fire service (blinking disabled)
      		setoutp(o_FL);				  // Turn on Fire service light
		else
		{
	   
#if ((Traction == 0) && (Tract_OL == 0))
			if ((cons[EMPop] & 0x02) != 0)
			{
				if ((empf != 0) && (empf != ep_select) && (empf != ep_recall) && (fvars[fvflemp] == 1))
		      		clroutp(o_FL);                
				else if (((eqf != 0) || (stallf != 0)) && (fvars[fvflots] == 1))
		      		clroutp(o_FL);                
				else if (Extinguish_FSL == 1)
		      		clroutp(o_FL);                // Turn off Fire service light
		  		else if (((eqf != 0) || (stallf != 0) || ((hws2_on == 1) && (cons[Smoke_2004] == 1)) || (mrs_on == 1) || (hws_on == 1)) && (timers[tsec] != 0))
		      		clroutp(o_FL);                
		  		else
		      		setoutp(o_FL);				  // Turn on Fire service light
			}
			else
			{
		  		if (((empf != 0) || (eqf != 0) || (stallf != 0) || ((hws2_on == 1) && (cons[Smoke_2004] == 1)) ||
		  				(mrs_on == 1) || (hws_on == 1)) && (timers[tsec] != 0))
		      		clroutp(o_FL);                
		  		else
		      		setoutp(o_FL);				  // Turn on Fire service light
			}
#else
			if ((empf != 0) && (empf != ep_select) && (empf != ep_recall) && (fvars[fvflemp] == 1))
	      		clroutp(o_FL);                
			else if (((eqf != 0) || (stallf != 0)) && (fvars[fvflots] == 1))
	      		clroutp(o_FL);                
			else if (Extinguish_FSL == 1)
		      	clroutp(o_FL);                // Turn off Fire service light
  			else if (((eqf != 0) || (stallf != 0) || ((hws2_on == 1) && (cons[Smoke_2004] == 1)) || (mrs_on == 1) || (hws_on == 1)) && (timers[tsec] != 0))
	      		clroutp(o_FL);                
	  		else
	      		setoutp(o_FL);				  // Turn on Fire service light
#endif
		}

		if (fvars[fvfs1f] == position)
		{
			if (cons[FSX_rear] == 1)
			{
				if (fs_on == 1)
					fire_sw_loc = 0;	// front fire door
				else if (fsx_on == 1)
					fire_sw_loc = 1; 	// rear fire door
				else
					fire_sw_loc = ((fvars[fvfiresw] & 1) != 0);
			}
			else
				fire_sw_loc = ((fvars[fvfiresw] & 1) != 0);
		}
		else if (fvars[fvfs1af] == position)
			fire_sw_loc = ((fvars[fvfiresw] & 2) != 0);
		else 
			fire_sw_loc = 0;

    	if( (rdinp(i_DOL) == 0) ||
		((rdinp(i_DOLR) == 0) && (cons[rear] != 0)) )
			A_Door_Is_Open = 1;
    	else
			A_Door_Is_Open = 0;

    	if ((fs2_on == 1) || 
    		((fs2_hold == 1) && (cons[firesv] != 3)))
		{										// no hold switch on chicago fire service
			fs2_to_fs1 = 0;
		 	timers[tfs2t] = 0;        // clear fire service phase 2 timer
		}

    	if((fs2_on == 0) && (timers[tfs2t] >= 15) && (firef > 3))
    	{
	    	if ((ccnmsk[cons[carnmb]][position] != 0) && 							// valid front floor
				(position == fire_floor) &&										// car at the fire floor
		    	(rdinp(i_DOL) == 0) && (fs1_effect == 0) &&	 				// door open and not on phase 1
		    	((rccnmsk[cons[carnmb]][position] == 0) || (fire_sw_loc == 0)))		// valid fire floor switch in front
			{		  
				firef = 0;		// go off of fire service
				rfiref = 0;
		  		clroutp(o_FL);      // Turn off the fire service light
			}
		    else if ((rccnmsk[cons[carnmb]][position] != 0) && 						// valid rear floor
				(position == fire_floor) &&										// car at the fire floor
		    	(rdinp(i_DOLR) == 0) && (fs1_effect == 0) && 	// door open and not on phase 1
		    	((ccnmsk[cons[carnmb]][position] == 0) || (fire_sw_loc != 0)))				// valid fire floor switch in rear
			{
	   			firef = 0;		// go off of fire service
	   			rfiref = 0;
		  		clroutp(o_FL);      // Turn off the fire service light
			}
			else if ((eqf == 0) && ((empf == no_ep) || (empf == ep_recall) || (empf == ep_select) || (position == fire_floor)))
			{					// cannot revert to phase 1 if eqf != 0: The door will open and fireman will loose control of the car 
				if (cons[firesv] == 2)
				{				// Ansi 2000 - Return to the designated landing
					firef = 1;
					rfiref = 1;
					if (fire_floor == fvars[fvfs1af])
					{
						firef = 2;
						rfiref = 2;
					}
					fs2_to_fs1 = 1;
				}
				else if (cons[firesv] == 3)
				{				// Chicago fire
					if (fs1_effect == 1)
					{
						if ( (((fvars[fvfireop2] & 0x01) != 0) && 
								((A_Door_Is_Open == 1) || (((manual_door == 1) || (manual_rdoor == 1)) && (car_gate() == 0)))) ||
							 ((fvars[fvfireop2] & 0x01) == 0) )
						{
							firef = 1;
							rfiref = 1;
							if (fire_floor == fvars[fvfs1af])
							{
								firef = 2;
								rfiref = 2;
							}
							fs2_to_fs1 = 1;
						}
					}
				} 
				else if ((fs1_effect == 1) && (A_Door_Is_Open == 1))
				{		// New York fire or Ansi 1996 
					firef = 1;
					rfiref = 1;
					if (fire_floor == fvars[fvfs1af])
					{
						firef = 2;
						rfiref = 2;
					}
					fs2_to_fs1 = 1;
				}
			}
    	}
		if(firef >= 4)
			servf = 6;
    	if((firef == 4) || ((firef > 4) && ((rdinp(i_DOL) == 0) || (manual_door == 1)))) 
    	{
      		if( ((fs2_hold == 1) && (cons[firesv] != 3)) ||
	  		((fs_on == 0) && (mes_on == 0) &&
			((fsx_on == 0) || (((cons[firesv] != 2) || (fvars[fvfsx] == 0)) && (cons[FSX_rear] == 0) && (cons[firesv] != 3))) &&
	   		(alt_on == 0) && (fs2_on == 0) &&	((hws2_on == 0) || (cons[Smoke_2004] == 0)) &&
	   		(hws_on == 0) && (mrs_on == 0)) )
      		{
				if (cons[firesv] == 3)
				{
					if ((ccnmsk[cons[carnmb]][position] != 0) && ((rdinp(i_DOL) == 0) ||
								(rccnmsk[cons[carnmb]][position] == 0) || (rdinp(i_DCLR) == 0)))
					{			  // Front door already open or no valid rear or rear door closed
						firef = 4;      // fire service phase 2 door hold
						clrcc(0);
					}
				}
				else
				{
					firef = 4;      // fire service phase 2 door hold
					clrcc(0);
      			}
      		}
			if (cons[firesv] == 3)
			{		 // Chicago fire service
				if ((firef == 4) && (fs2_on == 1))
					firef = 5;
			}
      		else if((firef==4)&&(fs2_hold == 0)&&(fs2_on == 1))
      		{
				if(cons[firesv] == 1)
				{
		  			firef = 8;		// New York fire service
				}
				else
		  			firef = 6;		// Ansi 1996 or 2000
      		}
    	}
    	if(firef >= 5)      // fire service phase 2 peek a boo service
    	{
			if (cons[firesv] == 3)
			{		// Chicago fire service
				if ((position == fire_floor) && ((rccnmsk[cons[carnmb]][position] == 0) || (fire_sw_loc == 0)))
					firef = 6;
			}
      		else if(rdinp(i_DOL) == 0)
      		{
				if(cons[firesv] == 1)
				{
		  			firef = 8;	   // New York fire service
					momentary_dcb = 0;
				}
				else
		  			firef = 6;	   // Ansi 1996 or 2000
      		}
    	}
    	if(firef == 6)      // fire service phase 2 constant presure door closed
    	{
			if (cons[firesv] == 3)
			{	   // Chicago fire service
				if ((position != fire_floor) || ((rccnmsk[cons[carnmb]][position] == 1) && (fire_sw_loc != 0)) )
					firef = 5;
			}
      		else if(rdinp(i_DCL) == 0)
				firef = 5;
    	}
    	if(firef == 8)      // fire service phase 2 momentary dcb door closed
    	{
			//added logic to just the DCL == 0 because the firef is being set to 8 when it should be set to 5. Possibly noise
			//and this caused door to reopen without peekaboo
      		if((rdinp(i_DCL) == 0)||
			((rdinp(i_DOL) == 1) && (rdinp(i_DOB) == 1) && (cons[firesv] == 1)))
				firef = 5;
    	}
    	if ((rfiref == 4) || ((rfiref > 4) && ((rdinp(i_DOLR) == 0) || (manual_rdoor == 1))))
    	{
      		if( (fs2_hold == 1) ||
	  		((fs_on == 0) && (mes_on == 0) &&
			((fsx_on == 0) || (((cons[firesv] != 2) || (fvars[fvfsx] == 0)) && (cons[FSX_rear] == 0) && (cons[firesv] != 3))) &&
	   		(alt_on == 0) && (fs2_on == 0) &&	 ((hws2_on == 0) || (cons[Smoke_2004] == 0)) &&
	   		(hws_on == 0) && (mrs_on == 0)) )
      		{
				if (cons[firesv] == 3)
				{
					if ((rccnmsk[cons[carnmb]][position] != 0) && 
							((rdinp(i_DOLR) == 0) ||
							(ccnmsk[cons[carnmb]][position] == 0)) )	// rear door already open or no valid front
					{
						rfiref = 4;      // fire service phase 2 door hold
						clrcc(0);
					}
				}
				else
				{
					rfiref = 4;      // fire service phase 2 door hold
					clrcc(0);
      			}
      		}
			if (cons[firesv] == 3)
			{		 // Chicago fire service
				if ((rfiref == 4) && (fs2_on == 1))
					rfiref = 5;
			}
      		else if((rfiref==4)&&(fs2_hold == 0)&&(fs2_on == 1))
      		{
				if(cons[firesv] == 1)
				{
		  			rfiref = 8;		  // New York fire service
				}
				else
		  			rfiref = 6;		  // Ansi 1996 or 2000
      		}
    	}
    	if(rfiref >= 5)      // fire service phase 2 peek a boo service
    	{
			if (cons[firesv] == 3)
			{		// Chicago fire service
				if ((position == fire_floor) && ((ccnmsk[cons[carnmb]][position] == 0) || (fire_sw_loc != 0)))
					rfiref = 6;
			}
      		else if(rdinp(i_DOLR) == 0)
      		{
				if(cons[firesv] == 1)
				{
		  			rfiref = 8;		  // New York fire service
					momentary_rdcb = 0;
				}
				else
		  			rfiref = 6;		  // Ansi 1996 or 2000
      		}
    	}
    	if(rfiref == 6)      // fire service phase 2 constant presure door closed
    	{
			if (cons[firesv] == 3)
			{	   // Chicago fire service
				if ((position != fire_floor) || ((ccnmsk[cons[carnmb]][position] == 1) && (fire_sw_loc == 0)))
					rfiref = 5;
			}
      		else if(rdinp(i_DCLR) == 0)
				rfiref = 5;
    	}
		if(rfiref == 8)      // fire service phase 2 momentary dcb door closed
		{
	    	if(rdinp(i_DCLR) == 0)
				rfiref = 5;
		}
  	}
}

// ***********************************************
// This is the HUGS Security Service Procedure
// ***********************************************

void sethugsf(void)
{
	int16 fl_ix;
	int16 flash_hugo = 0;
	int hugs_alarm = 0;
	static int hugs_state;


	// Call fro atfloor()

	if (cons[hugs] == 1)
	{
#if (Tract_HR == 1)
			hugsec = ((gpi[0] & 1) != 0);
			uiu.b[lb] = gpi[0];
			uiu.b[mlb] = gpi[1];
			uiu.b[mhb] = gpi[2];
			uiu.b[hb] = gpi[12];

			hugs_sec[0] = (uiu.dw  >> 1);

			uiu.b[lb] = 0;
			uiu.b[mlb] = 0;
			uiu.b[mhb] = 0;
			uiu.b[hb] = gpi[13];
			hugs_sec[0] |= (uiu.dw  << 7);
			
			uiu.b[lb] = gpi[13];
			uiu.b[mlb] = gpi[14];
			uiu.b[mhb] = gpi[15];
			uiu.b[hb] = gpi[16];
			
			hugs_sec[1] = ((uiu.dw  & 0x1FFFFFFFL) >> 1);

			rhugsec = ((gpi[6] & 1) != 0);
			uiu.b[lb] = gpi[6];
			uiu.b[mlb] = gpi[7];
			uiu.b[mhb] = gpi[8];
			uiu.b[hb] = gpi[18];
			rhugs_sec[0] = (uiu.dw  >> 1);

			uiu.b[lb] = 0;
			uiu.b[mlb] = 0;
			uiu.b[mhb] = 0;
			uiu.b[hb] = gpi[19];
			rhugs_sec[0] |= (uiu.dw  << 7);

			uiu.b[lb] = gpi[19];
			uiu.b[mlb] = gpi[20];
			uiu.b[mhb] = gpi[21];
			uiu.b[hb] = gpi[22];
			
			hugs_sec[1] = ((uiu.dw  & 0x1FFFFFFFL) >> 1);
#else
			hugsec = ((gpi[0] & 1) != 0);
			uiu.b[lb] = gpi[0];
			uiu.b[mlb] = gpi[1];
			uiu.b[mhb] = gpi[2];
			uiu.b[hb] = gpi[3];

			hugs_sec[0] = (uiu.dw  >> 1);

			rhugsec = ((gpi[6] & 1) != 0);
			uiu.b[lb] = gpi[6];
			uiu.b[mlb] = gpi[7];
			uiu.b[mhb] = gpi[8];
			uiu.b[hb] = (gpi[4] << 4) || (gpi[5] >> 4);
			rhugs_sec[0] = (uiu.dw  >> 1);
#endif
		
		fl_ix = (position-1)/32;

		hugsf = 0;
		if ((hugsec == 1) && ((hugs_sec[fl_ix] & fl_mask[position]) != 0) && (doorf != 0))
		{
			hugsf |= 1;
			flash_hugo = 1;
				
		}
		if ((rhugsec == 1) && ((rhugs_sec[fl_ix] & fl_mask[position]) != 0) && (cons[rear] != 0) && (rdoorf != 0))
		{
			hugsf |= 2;
			flash_hugo = 1;
		}
	}
	else if(cons[hugs] == 2)
	{

//		   hugsf should be set here // gc_hsec = gc_sec;
//		   hugsf should be set here	// gc_rhsec = gc_rsec;		

		hugs_sec[0] = (gc_cc_sec[0] >> 1);
		rhugs_sec[0] = (gc_rcc_sec[0] >> 1);

#if (Tract_HR == 1)

		hugs_sec[0] |= (gc_cc_sec[1] << 31);
		rhugs_sec[0] |= (gc_rcc_sec[1] << 31);

		hugs_sec[1] = ((gc_cc_sec[1]  & 0x1FFFFFFFL) >> 1);
		rhugs_sec[1] = ((gc_rcc_sec[1]  & 0x1FFFFFFFL) >> 1);

#endif		


		fl_ix = (position-1)/32;
		hugsf = 0;
		if (((hugs_sec[fl_ix] & fl_mask[position]) != 0) && (doorf != 0))
		{
			hugsf |= 1;
			flash_hugo = 1;
				
		}
		if (((rhugs_sec[fl_ix] & fl_mask[position]) != 0) && (cons[rear] != 0) && (rdoorf != 0))
		{
			hugsf |= 2;
			flash_hugo = 1;
		}

	}
	else if(cons[hugs] == 3)
	{

		if(rdinp(i_HUGB) == 1)
		{	
			hugs_state = 0;
			hugsf = 0;
			timers[thugs1] = 0;
			timers[thugs2] = 0;
			flash_hugo = 0;
			hugs_alarm = 0;
		}
		else if(rdinp(i_HUGI) == 1)
		{
			if(doorf != 0)
			{
				hugsf |= 1;
			}
			if((cons[rear] != 0) && (rdoorf != 0))
			{
				hugsf |= 2;
			}			
		}
		switch(hugs_state)
		{
			case 0:				//Normal Operation. Check for input to trigger
				if ((rdinp(i_HUGI) == 1) &&(rdinp(i_HUGB) == 0))
				{
					hugs_state = 1;
				}
				timers[thugs1] = 0;
				timers[thugs2] = 0;
				break;

			case 1: 			// Input has trigger Enter Pre Alarm State
				flash_hugo = 1;				
				timers[thugs2] = 0;
				if(timers[thugs1] > 110)
				{
					hugs_state = 2;
				}
				else if(rdinp(i_HUGI) == 0)
				{
					hugs_state = 3; // reset
				}					   
				break;
			case 2:				//Latch Exit Alarm and attempt reset after 10 sec of inactivity
				if(rdinp(i_HUGI) == 1)
				{
					timers[thugs2] = 0;
				}
				else if(timers[thugs2] > 100)
				{
					hugs_state = 3; // reset
				}
				flash_hugo = 2;
				hugs_alarm = 1;
				break;
			case 3:				//Reset State
				hugs_state = 0;
				hugsf = 0;
				timers[thugs1] = 0;
				timers[thugs2] = 0;
				flash_hugo = 0;
				hugs_alarm = 0;
				break;
			default:
				hugs_state = 0;
				break;
		}

	}
	else
		hugsf = 0;

	if (flash_hugo == 2)
		setoutp(o_HUGO);
	else if ((flash_hugo == 1) && (timers[tsec] != 0))
		setoutp(o_HUGO);
	else
		clroutp(o_HUGO);

	if (hugs_alarm == 1)
	{
		setoutp(o_HUGA);
	}
	else
	{
		clroutp(o_HUGA);
	}


}

// ***********************************************
// This is the Medical Emergency Service Procedure
// ***********************************************

void setmedf(void)
{
	if (cons[medEm] == 1)
	{		// Medical emergency service option is selected

		if (medf == 0)		// Not on Medical Emergency Service
		{
			if (rdinp(i_EMSH) == 0)
				timers[tmedf] = 0;
			if (((rdinp(i_EMSH) == 1) && (timers[tmedf] > 3)) || (med_latch == 1))
			{ 
				med_latch = 1;
				setoutp(o_EMLH);
				setoutp(o_EML);
				med_buz = 1;
				if ((chk_ins() == 1) || (firef != 0) || (rfiref != 0))
				{	 // Turn off buzzzer and light if could not go to next state and switch turned off
					if (med_latch == 1)
					{
						if (((firef > 3) || (rfiref > 3)) && (position == fvars[fvmedfl]) && ((doorf != 0) || (rdoorf != 0)))
						{		// Fireman has control over the car at the medical emergency floor
							med_latch = 0;
							med_buz = 0;
							clroutp(o_EMLH);
							clroutp(o_EML);
						}
					}
				}				
				else if ((ind() == 0) || (fvars[fvmedindovr] != 2))
					medf = 1;			// Return car to Med Floor
			}
		}
		else if (medf == 1)
		{				 // Look for car at Medical Emergency Floor
			med_latch = 0;
			clrcc(0);
			setoutp(o_EMLH);
			setoutp(o_EML);
			if (chk_ins() == 1) 
				med_buz = 1;
	      	else if( ((position == fvars[fvmedfl]) && (rdinp(i_DOL) == 0) &&
	      				((fvars[fvmedloc] == 0) || (cons[rear] == 0))) ||
		  			((position == fvars[fvmedfl]) && (rdinp(i_DOLR) == 0) &&
		    			(cons[rear] != 0) && (fvars[fvmedloc] != 0)) )
	      	{         // At Medical Emergency Service return floor
				med_buz = 0;
				medf = 2;			// Car at the Medical Emergency Floor
				timers[tmedf] = 0;
	      	}
	      	else
				med_buz = 1;
		}
		else if (medf == 2)
		{				// Car at the Medical emergency floor - Place on Med Service or return to automatic
			clrcc(0);
			if (rdinp(i_EMSH) == 1)
				timers[tmedf] = 0;		// Switch is still on so don't let it time out
			if (chk_ins() == 1) 
				med_buz = 1;
			else if (rdinp(i_EMS) == 1)
			{
				medf = 3;
				med_buz = 0;
				med_latch = 0;
			}
			else if (timers[tmedf] > 610) 		// Timed out after 61 seconds
			{
				clroutp(o_EMLH);
				clroutp(o_EML);
				medf = 0;
			}
			else if (position != fvars[fvmedfl])
				medf = 1;	// must get to medical floor
		}
		else if (medf == 3)
		{		   		// On Medical Emergency Service
			if (rdinp(i_EMS) == 0)
			{ 
				if ( ((position == fvars[fvmedfl]) && (rdinp(i_DOL) == 0) && 
										((fvars[fvmedloc] == 0) || (cons[rear] == 0))) ||
		  			((position == fvars[fvmedfl]) && (rdinp(i_DOLR) == 0) &&
		    							(cons[rear] != 0) && (fvars[fvmedloc] == 0)) )
				{			  // At the Medical Emergency Floor with the door open 
					if (rdinp(i_EMSH) == 1)
						medf = 2;	 // Hall switch is still on
					else
					{
						clroutp(o_EMLH);
						clroutp(o_EML);
						medf = 0;
						med_latch = 0;
					}
				}
				else
					clrcc(0);
			}
			if ((empf != 0) && (empf != ep_select)) 
				clrcc(0);
		}
		if ((medf >= 1) && (medf <= 2) && (firef != 0) && (position == fire_floor))
			medf = 0;
		if ((medf != 0) && (firef < 3) && (eqf == 0) && ((empf == 0) || (empf == ep_select) || ((empf == ep_recall) && (medf == 3))))
			servf = 17;
		else if ((servf == 17) && (medf == 0))
			servf = 1;
	}
	else
		medf = 0;
}

// ****************************************
// Set the Vip flag
// ****************************************

void setvipf (void)
{
	if (cons[VipSvc] == 1)
	{
		if (((g_vip_fl[cons[carnmb]] != 0) || (g_rvip_fl[cons[carnmb]] != 0) || (vipf == 4) || (vipf == 5)) && (Group_Comm == 1) && (vipf != 6))
		{
			servf = 23;
			in_vip = 1;
			if (g_vip_fl[cons[carnmb]] != 0)
				vipfl = g_vip_fl[cons[carnmb]];
			else 
				vipfl = g_rvip_fl[cons[carnmb]];

			if ((position != vipfl) && (vipf < 2))
			{
				timers[tvipseqto] = 0;
				if ( ((fvars[fvvipop] & 0x02) != 0) || (vipf == 1) || 
					 ( ((onward_cc == 0) && ((front_slowdown & cc_do) == 0) && (((rear_slowdown & cc_do) == 0) || (cons[rear] == 0))) && 
						(((doorf == 0) && ((cons[rear] == 0) || (rdoorf == 0))) || (((manual_door == 2) || (manual_rdoor == 2)) && (man_dcc() == 1))) ) )
				{							 // The door is closed and no onward car calls
					if (vipf == 0)
						clr_dir_arrow();
					vipf = 1;		// want to get to the vip floor
					clrcc(0);
					clrhc();
					clrlant();
				}
			}
			else if ((position == vipfl) && (vipf < 4))
			{			// at the vip floor
				timers[tvipseqto] = 0;
				if ((procf < 3) || (procf > 11))
				{			   // car is not moving
					if (g_vip_fl[cons[carnmb]] != 0)	
					{		// Front door
						if ((doorf == 2) && (vipf == 2) && (doort != 0))
						{
							vipf = 3;	  // front door is open
						}
						else if ((vipf == 0) || (vipf == 1))
							vipf = 2;		// command to open the door and set the doort
						if ((vipf == 3) && (((timers[tdwel] >= doort) && (doort != 0)) || ((onward_cc != 0) && (timers[tdwel] >= fvars[fvccdt]))))
						{
							if (fvars[fvviplant] != 0)
								clrlant();
							vipf = 4;
							doort = 0;
						}
					}
					else
					{	   // Rear door
						if ((rdoorf == 2) && (vipf == 2) && (rdoort != 0))
						{
							vipf = 3;		// rear door is open
						}
						else if ((vipf == 0) || (vipf == 1))
							vipf = 2;		// command to open the door and set the doort
						if ((vipf == 3) && (((timers[trdwel] >= rdoort) && (rdoort != 0)) || ((onward_cc != 0) && (timers[tdwel] >= fvars[fvccdt]))))
						{
							if (fvars[fvviplant] != 0)
								clrlant();
							vipf = 4;
							rdoort = 0;
						}
					}
				}
			}
			else 
			{
				if ((procf > 3) && (procf < 11) && (vipf == 4))
				{			   // car is moving
					vipf = 5;
					timers[tvipseqto] = 0;
				}
				if (((procf < 3) || (procf > 11)) && (vipf == 5))
				{			   // car is not moving	but has moved 
					vipf = 6;
					timers[tvipseqto] = 0;
				}
				if ( (((g_vip_fl[cons[carnmb]] == 0) && (g_rvip_fl[cons[carnmb]] == 0)) || (timers[tvipseqto] > 30)) && (onward_cc == 0) && (vipf == 4))
				{		// no call so car must have timed out
					vipf = 6;
				}
			}
		}
		else
		{
			if (in_vip == 1)
			{
				in_vip = 0;
				doort = 0;
				rdoort = 0;
				if (servf == 23)
					servf = 1;
			}
			vipf = 0;
			vipfl = 0;
			timers[tvipseqto] = 0;
		}
		
	}
	else
	{
		in_vip = 0;
		if (servf == 23) 
			servf = 1;
		vipf = 0;
		vipfl = 0;
	}
}



//*********************************
//****  Set Flag for TUG systems 
//*********************************

void settugf(void) 
{


	if(cons[TUG] == 1)
	{

		if(rdinp(i_DOL) == 1)
			setoutp(o_TDOL);
		else
			clroutp(o_TDOL);

		if (rdinp(i_DCL) == 1)
			setoutp(o_TDCL);
		else
			clroutp(o_TDCL);

		if(rdinp(i_DOLR) == 1)
			setoutp(o_TDOLR);
		else
			clroutp(o_TDOLR);

		if(rdinp(i_DCLR) == 1)
			setoutp(o_TDCLR);
		else
			clroutp(o_TDCLR);

    	if ((chk_ins() == 1) || (safeties() == 0))
			clroutp(o_TAVL);		  // out of service and no door operation
		else
			setoutp(o_TAVL);		  
		
		if ((statusf2 & sf_AF_SHUTDN) != 0)
			clroutp(o_TAVL2);		  // out of service and no door operation
		else
			setoutp(o_TAVL2);

		if(ind() == 1)
			setoutp(o_TIND);
		else
			clroutp(o_TIND);

		if((codebf !=0) || (hsvf != 0))
			setoutp(o_TMED);
		else
			clroutp(o_TMED);

		if((firef != 0)||(rfiref != 0))
			setoutp(o_TFSO);
		else
			clroutp(o_TFSO);

	  	if((position & 0x01) != 0)
			setoutp(o_TP1);
		else
			clroutp(o_TP1);

	  	if((position & 0x02) != 0)
			setoutp(o_TP2);
		else
			clroutp(o_TP2);

	  	if((position & 0x04) != 0)			
			setoutp(o_TP3);
		else
			clroutp(o_TP3);

	  	if((position & 0x08) != 0)			
			setoutp(o_TP4);
		else
			clroutp(o_TP4);

	  	if((position & 0x10) != 0)			
			setoutp(o_TP5);
		else
			clroutp(o_TP5);

	  	if((position & 0x20) != 0)
			setoutp(o_TP6);
		else
			clroutp(o_TP6);				



		if((firef == 0) && (rfiref == 0) && (codebf == 0) && (hsvf == 0) && (eqf == 0) && (empf == 0))
		{
			if (rdinp(i_THDS) == 1)
			{
				if ((ind() == 0) && (servf != 0) && ((statusf2 & sf_AF_SHUTDN) == 0))
					servf = 26;
				tugf = 1;

			}
			else
			{
				if(servf == 26)
					servf = 1;
				tugf = 0;

			}
		}
		else
		{

			if(servf == 26)
				servf = 1;
			tugf = 0;

		}

	}
	
}



//*********************************
//****  Set up level and dn level 
//*********************************
	
#if (Traction == 1)

void set_ul_dl(void)
{
	dn_level = rdinp(i_DL);
	up_level = rdinp(i_UL);

	if ((fvars[fvppstop] == 1) && (cons[dpp_upd] != 0))
	{
		if ((dn_level == 1) && (up_level == 1) && (level_stop_fault == 0))
		{			   // Car is in the dead level zone

			if ((leveling == 0) && (lev_latch == 0) && ((rdoutp(o_UP) == 1) || (rdoutp(o_DNR) == 1)) && (in_pfc_sfc_test == 0))
			{
				ul_dl_offset = DPP_Count + DPP_Fl_Offset[position];
				if (rdoutp(o_UP) == 1)
					ul_dl_offset += Up_fl_level_dist;
				else if (rdoutp(o_DNR) == 1)
					ul_dl_offset -= Dn_fl_level_dist;
				lev_latch = 1;
				fs_lev_vel = Dmd_Velocity;
				fs_enc_vel = Enc_vel;
				fs_dpp_count = DPP_Count;
				fs_offset = ul_dl_offset;
			}

			if ((rdoutp(o_UP) == 1) && (in_pfc_sfc_test == 0))
			{	// Leveling so use position pulse count
				leveling = 1;					// car looking for dead level from counts
				up_level = rdinp(i_UL);
				if (DPP_Count >= ul_dl_offset)
					dn_level = 1;
				else
					dn_level = 0;
			}
			else if ((rdoutp(o_DNR) == 1) && (in_pfc_sfc_test == 0))
			{
				leveling = 1;					// car looking for dead level from counts
				dn_level = rdinp(i_DL);	
				if (DPP_Count <= ul_dl_offset)
					up_level = 1;
				else
					up_level = 0;
			}
			else
			{
				ul_dl_offset = 0;
				leveling = 0;
			}
		}
		else
		{
			lev_latch = 0;
			if ((leveling == 1) && ( ((up_level == 0) && (rdoutp(o_UP) == 1)) || ((dn_level == 0) && (rdoutp(o_DNR) == 1)) ))
			{
				record_fault(f_lev_stop_cnt);
				level_stop_fault = 1;
			}
			ul_dl_offset = 0;
			leveling = 0;
		}
	}
	else
	{
		leveling = 0;
		ul_dl_offset = 0;
		level_stop_fault = 0;
		relev_stop_count = 0;
		lev_latch = 0;
	}
}

#endif
																				   
// ****************************************
// This is the set preference procedure
// ****************************************
void setpref()
{
    if((dpref == 2) && (dcalls != 2) && (dcalls != 3))
        dpref = 0;  // prefrence was down no calls below clear preference
    if((dpref == 1) && (dcalls != 1) && (dcalls != 3))
        dpref = 0;  // preference was up no calls above clear preference
    if(dpref == 0)  // no preference selected
    {
        if((dcalls == 1) || (dcalls == 3))  // calls above
            dpref = 1;
        if(dcalls == 2)     // calls below
            dpref = 2;
    }
	if(((fvars[fvattmandir] & 0x04) !=0)&& (manual_door == 1) && (cons[att] == 1))
	{								    
		if(allow_run == 0) 
		 	dpref = 0;
		if(onward_cc == 1)
			dpref = 1;
		if(onward_cc ==2)
			dpref = 2;		
	}
	set_dir_arrow();
	return;
}


//***************************************************
// This routine set the position from the pulse count
//***************************************************

#if (Traction == 1)
void set_position(int16 dir)
{
	int16 i;

	if (dir == 1)
	{		// car was going up
		for(i=cons[bottomf];i<cons[topf];i++)
		{
			if (DPP_Count < (DPP_Floor_Pos[i+1] + DPP_Fl_Offset[i+1]))
			{
				position = i;
				break;
			}
		}
		if (DPP_Count > (DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]]))
			position = cons[topf];
	}
	else if (dir == 2)
	{		// car was going down
		for(i=cons[topf];i>cons[bottomf];i--)
		{
			if (DPP_Count > (DPP_Floor_Pos[i-1] + DPP_Fl_Offset[i-1]))
			{
				position = i;
				break;
			}
		}
		if (DPP_Count < (DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]]))
			position = cons[bottomf];
	}
}
#endif

//************************************************************
// This routine set the position from the SELECTOR pulse count
//************************************************************

#if (Traction == 1)
int16 set_position_from_selector(void)
{									  	// 0 = position preset failed
										// 1 = position preset valid
	int16 i;
	
	if ((Hoistway_Learned == 0) || (SEL_Count_Valid == 0))
		return 0;

	if ((unsigned)(SEL_Count) < (unsigned)(SEL_Bottom_Count))
		SEL_Count = SEL_Bottom_Count;

	Dist_Ratio = (float)(SEL_Count - SEL_Bottom_Count) / (float)(SEL_Top_Count - SEL_Bottom_Count);

	Pos_Cnt_Ref = (long)(Dist_Ratio * (float)((DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]]) - (DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]]))) + 
		(DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]]);

	for(i=cons[bottomf];i<cons[topf];i++)
	{
		if (Pos_Cnt_Ref < (((DPP_Floor_Pos[i+1] + DPP_Fl_Offset[i+1]) - (DPP_Floor_Pos[i] + DPP_Fl_Offset[i]))/2) + (DPP_Floor_Pos[i] + DPP_Fl_Offset[i]))
		{
			position = i;
			break;
		}
	}
	if (Pos_Cnt_Ref > (DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]]))
		position = cons[topf];
								 
	if (abs((DPP_Floor_Pos[position] + DPP_Fl_Offset[position]) - Pos_Cnt_Ref) > (Pulses_per_Inch * 12.0)) 
		return 0;
		 
	return (1);
}

// ****************************
// preset the selector position 
// ****************************
void preset_selector_position(void)
{
	Dist_Ratio_S = (float)((DPP_Floor_Pos[position] + DPP_Fl_Offset[position]) - (DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]]))/
					(float)((DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]]) - (DPP_Floor_Pos[cons[bottomf]] + DPP_Fl_Offset[cons[bottomf]]));
	Pos_Cnt_Ref_S = (long)(Dist_Ratio_S * (float)(SEL_Top_Count - SEL_Bottom_Count)) + SEL_Bottom_Count;
	SEL_Preset_Count = Pos_Cnt_Ref_S;
	SPB_can.command |= spbc_init_pos;
}

//************************************************************
// This routine set the position from the Encoder pulse count
//************************************************************

int16 set_position_from_encoder(void)
{									  	// 0 = position preset failed
										// 1 = position preset valid
	int16 i;
	
	if (Hoistway_Learned == 0)
		return 0;

	Pos_Cnt_Ref = DPP_Count;

	for(i=cons[bottomf];i<cons[topf];i++)
	{
		if (Pos_Cnt_Ref < (((DPP_Floor_Pos[i+1] + DPP_Fl_Offset[i+1]) - (DPP_Floor_Pos[i] + DPP_Fl_Offset[i]))/2) + (DPP_Floor_Pos[i] + DPP_Fl_Offset[i]))
		{
			position = i;
			break;
		}
	}
	if (Pos_Cnt_Ref > (DPP_Floor_Pos[cons[topf]] + DPP_Fl_Offset[cons[topf]]))
		position = cons[topf];
								 
	if (abs((DPP_Floor_Pos[position] + DPP_Fl_Offset[position]) - Pos_Cnt_Ref) > (Pulses_per_Inch * 12.0)) 
		return 0;
		 
	return (1);
}


#endif

//*************************************************************
//**  The routine set the up and down direction arrows
//*************************************************************

void set_dir_arrow (void)
{
    if(firef == 0)
    {
		if(dpref == 0)
		{
			clr_dir_arrow();
		}

		if (cons[RGB_CC] == 1)
		{
			if (((cons[att] == 1) || (cons[att] == 2)) && (rdinp(i_ATT) == 1))
			{
				if ((dcalls & 0x1) != 0)	// Call above
					setoutp(o_ATUL);
				else
					clroutp(o_ATUL);

				if ((dcalls & 0x2) != 0)	// Call below
					setoutp(o_ATDL);
				else
					clroutp(o_ATDL);
			}
		}

		if ((((cons[dispis] & 0x08) != 0) || ((cons[dispis] & 0x10) != 0))	&&
			((cons[att] == 1) || (cons[att] == 2)) && (rdinp(i_ATT) == 1))
		{		// Attendant direction arrows on the car using the UDA and DDA
			if ((dcalls & 0x1) != 0)	// Call above
				setoutp(o_UDAC);
			else
				clroutp(o_UDAC);

			if ((dcalls & 0x2) != 0)	// Call below
				setoutp(o_DDAC);
			else
				clroutp(o_DDAC);
		}
		else if ((cons[dispis] & 0x10) != 0)
		{				  // Turn off the arrows if not on att
			clroutp(o_UDAC);
			clroutp(o_DDAC);
		}
		else
		{	   // use uda and dda on automatic
			if(dpref == 1)
			{
				setoutp(o_UDAC);
				clroutp(o_DDAC);
			}
			if(dpref == 2)
			{
				clroutp(o_UDAC);
				setoutp(o_DDAC);
			}
		}


		if(dpref == 1)
		{
			up_dir_arrow = 1;
			dn_dir_arrow = 0;
		}
		if(dpref == 2)
		{
			up_dir_arrow = 0;
			dn_dir_arrow = 1;
		}
		if ((servf == 25) && ((fvars[fvsabbdis] & 0x04) != 0))
		{
			clr_dir_arrow();
		}
	}
	else
	{
		clr_dir_arrow();
	}
}


#if (Traction == 1) || (Tract_OL == 1)

//**************************************
// Verify UL and DL direction sequence
//**************************************

void verify_uldl_seq(int16 init_flag)
{
	if (init_flag == 1)
	{
		dlul_seq = 0;
		uldl_seq = 0;
		uldl_dir_fault = 0;
		tmr_uldl_dir = 0;
	}
	else if (dirf == 2)
	{	  // detect a wrong direction sequence going down
		if ((rdinp(i_UL) == 0) && (rdinp(i_DL) == 0) && (uldl_seq != 4))
			uldl_seq = 1;
		else if ((rdinp(i_UL) == 1) && (rdinp(i_DL) == 0) && (uldl_seq == 1))
			uldl_seq = 2;
		else if ((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1) && (uldl_seq == 2))
			uldl_seq = 3;
		else if ((rdinp(i_UL) == 0) && (rdinp(i_DL) == 1) && (uldl_seq == 3))
			uldl_seq = 4;
	}
	else if (dirf == 1)
	{	  // detect a wrong direction sequence
		if ((rdinp(i_UL) == 0) && (rdinp(i_DL) == 0) && (dlul_seq != 4))
			dlul_seq = 1;
		else if ((rdinp(i_UL) == 0) && (rdinp(i_DL) == 1) && (dlul_seq == 1))
			dlul_seq = 2;
		else if ((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1) && (dlul_seq == 2))
			dlul_seq = 3;
		else if ((rdinp(i_UL) == 1) && (rdinp(i_DL) == 0) && (dlul_seq == 3))
			dlul_seq = 4;
	}
	else
	{
		dlul_seq = 0;
		uldl_seq = 0;
	}

	if ((uldl_seq == 4) || (dlul_seq == 4))
	{
	 	if ((tmr_uldl_dir > 20) && (fvars[fvuldldirfltdis] == 0) && (chk_ins() == 0))
		{		   // Timer to prevent trip on power cycle
		 	if (estop == 0)
		 		record_fault(f_uldl_dir_flt);
		 	estop = 1;
		 	if ((cons[ansi] >= 2000) && (gripper_fault == 0))
		 	{			// Trip the gripper if over 125
		 		gripper_fault = 1;
		 		SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
		 		gripper_test = 20;		// don't run the gripper test accidentally
		 		clroutp(o_GR1R);
		 		clroutp(o_GR2R);
		 		clroutp(o_LE);
		 		clroutp(o_LE1);
		 	}
		 	uldl_dir_fault = 1;
		}
	}
	else
		tmr_uldl_dir = 0;
}


//*******************************************
// Verify direction the car hits the limits
//*******************************************

void verify_limit_seq (int16 init_flag)
{

	if (init_flag == 1)
	{	 // init variables for test
		limit_0 = 0;
		limit_0_tog = 0;
		limit_1 = 0;
		limit_1_tog = 0;
		limit_2 = 0;
		limit_2_tog = 0;
		limit_3 = 0;
		limit_3_tog = 0;
		limit_4 = 0;
		limit_4_tog = 0;
		limit_5 = 0;
		limit_5_tog = 0;
		limit_6 = 0;
		limit_6_tog = 0;
		limit_ts = 0;
		limit_ts_tog = 0;
		limit_dir_fault = 0;
		tmr_lim_dir = 0;
	}
	else if (dirf == 2)
	{
		if (rdinp(i_UT6) == 1)
		{
			limit_6 = 1;
			limit_6_tog = 0;
		}
		else if ((limit_6 == 1) && (rdinp(i_DT6) == 1))
			limit_6_tog = 1;

		if (rdinp(i_UT5) == 1)
		{
			limit_5 = 1;
			limit_5_tog = 0;
		}
		else if ((limit_5 == 1) && (rdinp(i_DT5) == 1))
			limit_5_tog = 1;

		if (rdinp(i_UT4) == 1)
		{
			limit_4 = 1;
			limit_4_tog = 0;
		}
		else if ((limit_4 == 1) && (rdinp(i_DT4) == 1))
			limit_4_tog = 1;

		if (rdinp(i_UT3) == 1)
		{
			limit_3 = 1;
			limit_3_tog = 0;
		}
		else if ((limit_3 == 1) && (rdinp(i_DT3) == 1))
			limit_3_tog = 1;

		if (rdinp(i_UT2) == 1)
		{
			limit_2 = 1;
			limit_2_tog = 0;
		}
		else if ((limit_2 == 1) && (rdinp(i_DT2) == 1))
			limit_2_tog = 1;

		if (rdinp(i_UT1) == 1)
		{
			limit_1 = 1;
			limit_1_tog = 0;
		}
		else if ((limit_1 == 1) && (rdinp(i_DT1) == 1))
			limit_1_tog = 1;

		if (rdinp(i_UT) == 1)
		{
			limit_0 = 1;
			limit_0_tog = 0;
		}
		else if ((limit_0 == 1) && (rdinp(i_DT) == 1))
			limit_0_tog = 1;

		if (rdinp(i_UTS) == 1)
		{
			limit_ts = 1;
			limit_ts_tog = 0;
		}
		else if ((limit_ts == 1) && (rdinp(i_DTS) == 1))
			limit_ts_tog = 1;

	}
	else if (dirf == 1)
	{
		if (rdinp(i_DT6) == 1)
		{
			limit_6 = 1;
			limit_6_tog = 0;
		}
		else if ((limit_6 == 1) && (rdinp(i_UT6) == 1))
			limit_6_tog = 1;

		if (rdinp(i_DT5) == 1)
		{
			limit_5 = 1;
			limit_5_tog = 0;
		}
		else if ((limit_5 == 1) && (rdinp(i_UT5) == 1))
			limit_5_tog = 1;

		if (rdinp(i_DT4) == 1)
		{
			limit_4 = 1;
			limit_4_tog = 0;
		}
		else if ((limit_4 == 1) && (rdinp(i_UT4) == 1))
			limit_4_tog = 1;

		if (rdinp(i_DT3) == 1)
		{
			limit_3 = 1;
			limit_3_tog = 0;
		}
		else if ((limit_3 == 1) && (rdinp(i_UT3) == 1))
			limit_3_tog = 1;

		if (rdinp(i_DT2) == 1)
		{
			limit_2 = 1;
			limit_2_tog = 0;
		}
		else if ((limit_2 == 1) && (rdinp(i_UT2) == 1))
			limit_2_tog = 1;

		if (rdinp(i_DT1) == 1)
		{
			limit_1 = 1;
			limit_1_tog = 0;
		}
		else if ((limit_1 == 1) && (rdinp(i_UT1) == 1))
			limit_1_tog = 1;

		if (rdinp(i_DT) == 1)
		{
			limit_0 = 1;
			limit_0_tog = 0;
		}
		else if ((limit_0 == 1) && (rdinp(i_UT) == 1))
			limit_0_tog = 1;

		if (rdinp(i_DTS) == 1)
		{
			limit_ts = 1;
			limit_ts_tog = 0;
		}
		else if ((limit_ts == 1) && (rdinp(i_UTS) == 1))
			limit_ts_tog = 1;
	}

	if ((limit_6_tog == 1) || (limit_5_tog == 1) ||	(limit_4_tog == 1) ||
		(limit_3_tog == 1) || (limit_2_tog == 1) || (limit_1_tog == 1) ||
		(limit_ts_tog == 1) || (limit_0_tog == 1))
	{

#if (Traction == 1)
		if ((tmr_lim_dir > 30) && ((dmd_vel_fpm > 100) || (enc_vel_fpm > 100)) && (fvars[fvlimdirfltdis] == 0) && (chk_ins() == 0))
#else
		if ((tmr_lim_dir > 30) && (rdoutp(o_RUN) == 0) && (fvars[fvlimdirfltdis] == 0) && (chk_ins() == 0))
#endif
		{
			if (estop == 0)
				record_fault(f_limit_dir_flt);
			estop = 1;
			if ((cons[ansi] >= 2000) && (gripper_fault == 0))
			{			// Trip the gripper if over 125
				gripper_fault = 1;
				SPB_can.command |= spbc_set_umotion;			// set unintended motion fault
				gripper_test = 20;		// don't run the gripper test accidentally
				clroutp(o_GR1R);
				clroutp(o_GR2R);
				clroutp(o_LE);
				clroutp(o_LE1);
			}
			limit_dir_fault = 1;
		}
	}
	else
		tmr_lim_dir = 0;
}
#endif

void set_rcm(void)
{
	static int rcm_pick_attempt;

	

	if ((cons[RCM_HWDoor] == 1) && (((cons[dispis] & 2) == 0) || ((cons[sercom] & 0x01) != 0)))
	{
		if (chk_ins() != 0)  
		{
			if ((chk_ins_sw() != 0) && 
				(rdinp(i_ACC) == 0) && 
					(((rdinp(i_GBP) == 0) && (rdinp(i_LBP) == 0)) || 
																(rdinp(i_INS) == 0)) ||
				(rdoutp(o_DC) == 1) || 
				((cons[rear] == 1) && (rdoutp(o_DCR) == 1)))
					setoutp(o_RCM); //cons[RCM_HWDoor] == 1
				else
				{
					clroutp(o_RCM); //cons[RCM_HWDoor] == 1
				}
		}
		else
		{ 
#if (Traction == 1)
			 if ((rdinp(i_DZ) == 0) || (hsf == 1) || (Dmd_Velocity > (Pulses_per_Inch * 30.0)))
#else
			 if ((rdinp(i_DZ) == 0) || (hsf == 1))
#endif
			 {
				if ((rdoutp(o_DC) == 1) || (dirf != 0) ||
					((cons[rear] == 1) && (rdoutp(o_DCR) == 1)))
				{
						setoutp(o_RCM); //cons[RCM_HWDoor] == 1
				}
				else
				{
					clroutp(o_RCM);	 // Retiring Cam  cons[RCM_HWDoor] == 1
				}
			}
			else
			{
#if (Traction == 1)
				if ((Dmd_Velocity < (Pulses_per_Inch * 30.0)) &&   // less than 150 fpm.
					(hsf == 0) && (rdinp(i_DZ) == 1) &&
				 	(((procf >= 14) && (procf <= 16)) || ((fvars[fvrcmctl] & 0x02) != 0) || ((fvars[fvpredo] & 0x01) != 0) || ((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))) &&
					(doorf != 3) && (doorf != 4) && ((cons[rear] == 0) || ((rdoorf != 3) && (rdoorf != 4))) )
#else
				 if ((hsf == 0) && (rdinp(i_DZ) == 1) && 
				 	(((procf >= 14) && (procf <= 16)) || ((fvars[fvrcmctl] & 0x02) != 0) || ((fvars[fvpredo] & 0x01) != 0) || ((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1))) &&
					(doorf != 3) && (doorf != 4) && ((cons[rear] == 0) || ((rdoorf != 3) && (rdoorf != 4)))  )
#endif
				{

					if ((statusf & sf_SAFE) != 0)
						timers[tpredo] = 0;

					if (timers[tpredo] > fvars[fvpred])
						clroutp(o_RCM);	 // Retiring Cam cons[RCM_HWDoor] == 1
					else
 						setoutp(o_RCM);		//	cons[RCM_HWDoor] == 1
				}
				else
				{	  // door is closing or speed greater than 150 fpm
					if ((fvars[fvpredo] & 0x01) == 0)
						timers[tpredo] = 0;
					setoutp(o_RCM);			//cons[RCM_HWDoor] == 1
				}
			}
		}
		return;
	}

	if((cons[mand] == 9) && (auto_rcm != 0) && (chk_ins() == 0))
	{
		if(auto_rcm == 1)
		{
			if(doorf == 0)
				setoutp(o_RCM);
			else
				clroutp(o_RCM);

		}
		else
		{
			if(rdoorf == 0)
				setoutp(o_RCM);
			else
				clroutp(o_RCM);

		}

		return;
	}

	if (((cons[mand] != 0) || (cons[frghtd] != 0)) && (((cons[dispis] & 2) == 0) || ((cons[sercom] & 0x01) != 0))) 
	{
		if (cons[RCM_HWDoor] == 0)
		{
			if (((manual_door != 0) || (cons[frghtd] != 0))
					&& (ccmsk[cons[carnmb]][position] != 0) 
					&& (((fvars[fvrcmctl] & 0x01) == 0) || (doorf == 1)) )
				drop_front_rcm = 1;
			else
				drop_front_rcm = 0;

			if (((manual_rdoor != 0) || (cons[frghtd] != 0))
			       && (cons[rear] != 0) && (rccmsk[cons[carnmb]][position] != 0) 
			       && (((fvars[fvrcmctl] & 0x01) == 0) || (rdoorf == 1)) )
				drop_rear_rcm = 1;
			else
				drop_rear_rcm = 0;

			if (chk_ins() == 0)
			{		// not on inspection
				if ((((timers[tnit] > fvars[fvhcdt]) && (dpref != 0)) || (relevel_req == 1) || (dirf != 0) ||
					(((procf == 1) || (procf == 21)) && (rdinp(i_DZ) == 0) && ( (rdoutp(o_DC) == 1) || (rdoutp(o_DCR) == 1) ) ) ||
							((rhjackf >=2) && (procf == 18)) ) &&
					(car_gate() == 1) && (man_dcc() == 1) &&
					(timers[tmotion] < fvars[fvstall]) &&	   // The car is not stalled
				  	(doorf != 1) && ((rdoorf != 1) || (cons[rear] == 0)))
				{
					timers[trcdrdly] = 0;
					if ((procf >= 14) && (procf <= 16))	
					{
						if((rcm_pick_attempt >= 4) || (RCM_Lock_Fault == 1))
						{
							if(RCM_Lock_Fault == 0)
							{
								record_fault(f_rcm_lock_off);
								RCM_Lock_Fault = 1;
							}
							else
							{
								if(timers[trcmon] > 400)
									shutdown = 1;
							}
							clroutp(o_RCM);	 // Retiring Cam
						}	
						else if (timers[trcmon] < 300)
						{
							setoutp(o_RCM);	 // Retiring Cam
						}

						else if (timers[trcmon] < 350)
						{
							clroutp(o_RCM);	 // Retiring Cam
						}
						else
						{
							timers[trcmon] = 0;	
							rcm_pick_attempt++;
						 }	
					}
					else
					{
						setoutp(o_RCM);	 // Retiring Cam
						rcm_pick_attempt = 0; // This line was added because the manual door car was faulting out after five succesful runs (5.52.48)
					}
				}
				else if (((timers[trcdrdly] > fvars[fvrcdrdly]) || (doorf == 1) || (rdoorf == 1)) && (rdinp(i_DZ) == 1))
				{
					rcm_pick_attempt = 0;
					if ((drop_front_rcm == 1) || (drop_rear_rcm == 1))
						clroutp(o_RCM);
					else if (((timers[tnit] > 3000) && (procf >= 14) && (procf <= 16)) || 
								(timers[tmotion] >= fvars[fvstall]))		// greater than 5 minutes (tnit not cleared until dead level)
						clroutp(o_RCM);
				}
			}
			else	// on inspection
			{
				RCM_Lock_Fault = 0;

				
				if (((chk_ins_sw() != 0) || (access_run_req() != 0)) &&
		  			(((car_gate() == 1) && (man_dcc() == 1)) || ((access_door_safe() != 0)||(0))) &&
				  		(doorf != 1) && ((rdoorf != 1) || (cons[rear] == 0)))
				{
					setoutp(o_RCM);	 // Retiring Cam
				}
				else
				{
					clroutp(o_RCM);
				}
			}
		}
	}
	if(rcm_frght_out_en == 1)
	{
		if (rdoutp(o_RCM) == 1)
		{
			if (timers[trcpkdly] > fvars[fvrcpkdly])
				setoutp(o_RCF);
		}
		else
		{
			timers[trcpkdly] = 0;
			clroutp(o_RCF);
		}
	}
}

void set_scnd_position(void)
{	
int static update_scnd_pos;

	if((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1) && (rdinp(i_DZ) == 1))
	{
		scnd_pos = position;
	}

	switch(update_scnd_pos)
	{
		case 0: // at floor
			if((rdinp(i_UL) == 1) && (rdinp(i_DL) == 1) && (rdinp(i_DZ) == 1))
			{
				update_scnd_pos = 1;
			}
			break;
		case 1: // check direction of travel
			if( (rdinp(i_DL) == 0) && (rdinp(i_UL) == 1) && (rdinp(i_DZ) == 0)) //dn
			{	
				scnd_pos--;
				update_scnd_pos = 0;
			}
			else if((rdinp(i_UL) == 0) && (rdinp(i_DL) == 0) && (rdinp(i_DZ) == 0))	//up
			{
				update_scnd_pos = 0;
			}
			break;
		default:
			break;
	}
}


/* Revision History	
	

  5/20/01  1.02  mhd	1. Added Video display(see video_exist).

  5/31/01  1.03  mhd 	1. In reset function, moved firef != 0 check 
  						   behind of "make sure elevator not lost" section.
						2. Added integral software simulator (see Simulator).
  6/8/01   1.04  mhd	1. Added velocity check and leveling enable check in motion routine
						   to prevent premature stop when hitting a door zone.
						2. Make a temporary video window so 80x43 video mode will work
						   for car 2.
						3. Changed loop count in brdinit to initialize added boards.
  7/5/01  1.06  mhd		1. Added y-delta start for generator using OT2.
						2. In atfloor, check tmppos != position only if the car is dead level.
						3. In reset, set position = tmppos only if dead level.
						4. Deleted GENERATOR compile flag (set gen output for all traction cars).
						5. If Traction car and no DEL input, turn off up,uf or dn,df outputs.
  7/11/01 1.07  mhd		1. Use OT1 output for fire service on output (FS0).

  7/17/01 1.07  rjc/mhd 1. changed in doors to check dpr input only if not releveling and
   						   to allow time for mfc to drop out and str to pick up before faulting
						2.  made the same changes to rear door.
						3. Pulse the RST output every 15 seconds until the drive resets (in sstring).
						4. If traction and MG set, must have DEL else estop is set to 1 (prevent from picking the brake).
						5. Use (cons[hydro] != 1) in set_io_board_status instead of (hydro == 0)
						6. Added Field Weakening Control (see FWB).
  7/26/01 1.08 mhd	    1. In rdcons, for both loops, reading in the floor markings and reading the call masks, changed the index from 31 to 32.
  7/27/01 1.08 rjc		1. Made changes to work with old galcom untill Gal com can be changed 
  						    for additional floors.  void diag mode 8
						2. Made changes to work with old galcom untill Gal com can be changed 
  						    for additional floors.  void diag mode 17
  7/31/01 1.08 mhd		1. Added calculation for velocity. see Enc_vel and enc_vel_timer.
  8/1/01  1.08 mhd		1. Changed initialization of video display: Use set_vmode, set_vert_res
						   and set_font instead of textmode().  This was done to get 28 rows for
 						   the i/o screen and to call only set_font when changing from i/o to
						   group screen.
						2. Moved Encoder RPM and PPR to field variables.
						3. Change password to have a minimum of 3 characters instead of 4.
						4. Only check for safe test date if auto_elevator == 1 and not running
						   the simulator.
  8/22/01 1.09 mhd		1. Use first 1014 board if binary position inputs used.	see set_io_ board_status.
						2. Read in the inputs ports for expansion boards in inctime routine.
						3. Cancel car calls first time placed on IND. 
  8/27/01 1.09 mhd		4. Always put the fire buzzer on if on fire and inspection.  Also when returning from
						   inspection and in reset mode, do not close door if at return floor.
  9/05/01 1.09 mhd		5. Do not clear the servf flag on inspectionf if the firef flag set.
						6. If firef flag == 3 (phase 1 complete) when inspection hit, set the fire flag to the return
						   sequence of 1 or 2.
  8/23/01 1.10 mhd		1. Changed Com_Modes to transmit additional data for 29 floors. see com_nmb_fl and com_nmb_io.  Also added
						   Com_Mode 40 to detect later version of laptop software.
						2. Added rear car call cancel for simulator.
						3. Changed Com_Mode 3, 26,27,and 28 to send more data to laptop.
  9/12/01 1.10 mhd		4. Added statusf flag to aid with diagnostic data.
  9/13/01 1.10 mhd 		5. Added check for DEL when releveling.
  10/1/01 1.10 mhd		6. When checking password, exit for loop after first valid password is found.
						7. Added User Baud field adjustable variable.
						8. Check all field adjustable variables to be valid within the min and max. If not
						   valid then set to the min.
  10/2/01 1.10 mhd		9. Change the number of field variables sent to GALCOM if com_upd_nmb >= 1.
  10/5/01 1.10 mhd		10. In Com_mode = 17, send dpref instead of iodata for UDA and DDA. The car will
						    change to red when homing down.
						11. Do not allow the user interface laptop to update the user interface baud rate in 
							Com_mode = 2.
 10/12/01 1.10 mhd		12. Pass parameter to main for default baud rate 
 10/16/01 1.10 mhd		13. Added Com_mode = 41 for jump to pwrup routine to allow file transfer.
 10/18/01 1.10 mhd		14. Added hydro == 6 for vector open loop drive. Not speed S-curve board.
 10/18/01 1.10 mhd		15. Read drive type for each car. Replace cons[hydro] with Drive_Type[carnmb].
					    16. Changed Array sizes in group to six cars. Also read in data for six car
						    from cons.dat file.
 10/25/01 1.10 mhd		18. When setting door dwell mode, if no DOL and doorf != 1 or 2, set mode to open (=1).
						19. Set servf in setfsf routine. With the change in 18 and 19, the change in item 5
							version 1.09 can be deleted. Also in item 4, version 1.09, close the door 
							when not on DZ and don't check for firef = 1,2 or 3.
						20. When (drive_type == 6), traction open-loop, turn on MCC output when running up or down and then turn
							it off when dead level.
						21. Added status flag for DZ fault and GATE AND LOCK fault.
						22. Set the statusf flag to zero in reset, inspection and sstring.
						23. Delete the statusf flag for Year, Month and day safety test.
						24. Set the direction preference when on attendant and homing.
						25. Add variable to disable parking.
11/11/01 1.11 mhd		1. Checksum variables when being received from laptop in com_mode  = 2.
						2. Changed velocity calculation: decrement enc_vel_timer by 1 instead of setting to zero.
						3. Set Com_Mode after each field variable packet sent (See Com_Mode = 1).
						4. Set Recbuf to zero after reading in character in asigetc.
						5. Changed modem setup commands.
						6. Changed parking variable to 0=disable parking, 1-4 = number of cars to park
12/11/01 1.11 rjc		7. Modified Field Forcing in chkrun
01/03/02 1.12 mhd		1. Com_Mode 1 and 2 transfer field adjustable data using checksum only.
01/21/02 				2. Execute Tranbuf_Empty[comnmb] = 0 while interrupts are disabled in sendc routine.
						   Also added transmit timer for user comm.
02/06/02 				3. Deleted hall call power loss status flag	(statusf |= sf_HC) since this is not a car function.
						4. Set com_upd_nmb = 2.	Added tcom_que timer.
						5. Send year with fault data.
						6. Send car number in packets 3,9,26,27,28,and 47.
						7. Send fault log to group and to HI (for all cars).  Also clear fault log for all cars.
						8. Check DSR line to make sure terminal is connected.  When connected first time, reset comm, when disconnected
						   first time, set Com_Mode to zero. Also reset modem if carrier is lost.
02/20/02				9. Added fault data display subroutine for VGA display.
03/07/02 1.14 mhd		1. Added field variables for emergency power.
					    2. Added emergency power software for traction elevators.  Also added setempf routine.
						3. Allow car to relevel on emergency power only if allow to recall or selected to run.
						4. Do not allow the car to leave reset mode if not on the door zone and on emergency power.
03/19/02 1.14 mhd		5. Changed interaction between fire service and emergency power recall for Ansi 2000. Affected needstop, dirsel, 
						   chkdoor, setfsf, motion and setempf.	Set stepf and recover_sd flags on estop.
						6. Changed interaction between fire service and low oil for Ansi 2000. Affected needstop, dirsel, 
						   chkdoor, setfsf, inspection and motion. Set stepf and recover_sd flags on estop.
						7. Moved user interface comm to Comm.cpp.
4/1/02	2.00 mhd		1. Re-arranged timers for new group comm routine.
05/24/02 2.02 mhd		1. Clear closetry, rclosetry and Door_Lock_Fault when on inspection, on reset and on first stop out 
						   of motion.
05/29/02 2.02 mhd		2. Set inservice (ISER) output when car in automatic service.
06/12/02 2.02 mhd		3. Added random call run test from INCRS input when no inconspicious riser service. Use Handicap 
						   door timer for delay timers[fvexdt] (normaly extends door time when ED input is active).
06/13/02 2.02 mhd		4. If car uses binary presets and powers up on UL or DL, then let the car relevel to find it's
						   position.
						5. Use tvel_DPP to calculate Enc_vel to eliminate conversion error from long to float.
06/24/02 2.03 mhd		1. Added car call lockout security
						2. Added reading security flag from cons file.
06/25/02 2.03 mhd		3. Set the doorf to close when exiting the reset mode on automatic.	see reset_close_doors().
07/9/02 3.00 mhd		1. When using iodata array, use labels instead of numbers such as DNRD instead of 7.
						2. Set timer count value each inttime routine.
10/08/02 				3. If phase 1 return is complete and car is place on inspection the sound the buzzer.
10/21/02 3.01 mhd		1. For Tract non-distance feedback controllers, use UPF and DF as speed command signals B1:B0.
						2. Changed chk_start for Traction ndf to match regular traction.
						3. Check to make sure DFI and UFI turn off after stopped and dead level.
						4. Deleted Car_Flts array and use Flts array for all cars.
						5. Deleted ANSI2000 and GAL compile flags.
12/18/02 3.02 mhd		1. Added Serial hall call board software.  See set_io_board_status.
						2. In inctime, read iodata directly instead of using rdinp() routine since the car calls change locations
						   depending cons[sercom].
						3. Moved BP8 to ETH, renamed ETH to EQ and moved to I/O #190, moved COL to I/O #191, and if non-distance
						   feedback than use TPL for BKS input.
						4. Set io_board[9] if serial hall call comm and discrete PI and greater than 5 floors. 
						5. Use drive_type == 1 for hydro, drive_type == 3,4,5 for distance feedback, and deleted
						   using drive_type == 6 for non-distance feedback because there may be other cases for ndf
2/11/03 				6. Moved ATT,ATTUP and ATTDN i/o's to new locations.
2/12/03					7. Implemented attendant operation. Use FS2C input for attendant bypass.
						8. In needstop, check for position at bottom floor going down or position at top floor going up to return a
						   1 to slowdown.
						9. Do not allow the car to recall on emergency power if on ind, att, fire 2 or stall.
3/18/03	3.03 mhd		1. Moved gc_uc_mask, gc_dc_mask, gc_rdc_mask and gc_ruc_mask from comm.cpp and renamed to g_ucmsk, 
						   g_dcmsk, g_rucmsk and g_rdcmsk. 
  						2. Added menu system for group in video.cpp.  Video and menu control executed from video_display_control routine.
4/25/03 3.03 mhd		3. In chkrun(), anded (gripper_test < 3) with (firef == 0) to allow car to run on fire service without doing
						   a gripper test.  (Without this change, on phase 1 return, if the car stops to reverse direction, 
						   it will lockup at the floor.	
7/22/03 3.03 mhd		4. In inspection, use time delay to check for ss and lc lost.  Also added timer to delay gripper fault for 40 msec.
						5. Delay start for non-interference timer plus soft stop time.	
						6. Keep the door open if stop switch, door open and turned on fire service.			   
4/3/03 3.04 mhd			1. Use hall call serial comm if car serial comm used (sercom & 3) != 0.
6/4/03 3.04 mhd			2. When on RTL, hold door open when at the lobby and cancel car calls.
 						3. Added return to lobby service.
 						4. Added check for valid floor.  Since invalid floor will not have a doorzone magnet, do
						   not allow the car to stop at an invalid floor.
						5. Use ccmsk, ucmsk and dcmsk as a pointer based mask to select witch floors calls can be accepted. If on
						   Security, change the pointer to the new security mask for car and hall calls.  
						6. Place security call assigment configuration in cons.dat file.
						7. Change PI location for special case when serial hc board used and floors > = 14 and <= 21.
						8. Allow DOB to reopen the door on nudging if Field variable set (DOB over Nudg).
						9. Add new field variable (DOB over Nudg) and (Emerg Dispatch).
						10. Added Emergency hall call dispatch for cars that cannot become the group
						11. Added debounce time (2 sec) to delay reading in binary presets at floor level. Also don't
						   read the preset in the motion routine and only set the preset once at the floor.
						12. If on IND and fire recall, do not open the door if FS_DOB_DIS flag is set.  This will cause
						   the car a running car on IND to stop at the next landing and return to the fire floor without 
						   opening the door.
						13. Read gripper_fault on powerup from battery memory and write to memory after gripper fault.
						    The gripper_fault is initialized to zero when battery backed ram is initialized.
						14. Added keybrd_ctrl and prt_scr routines to prevent the user from resetting the cpu from the keyboard.
						15. If binary preset error, log the error but continue running with the current position (do not go
						   through reset routine). If in atfloor and a reset occured, set the position from the binary inputs.
						16. Moved update_serial_io() to after diag() so serial car calls set from diag will work properly.
						17. Do not allow car 2 to cancel ucl and dcl if ((sercom & 3) == 0). (when car 2 is not the group)
						18. Added rear car lockout security.
 						19. Add car call lockout security input from hall call board.
						20. Add ir and code blue floor mask for hall call board.
						21. Altered code for car call lockouts to make it more readable.
						22. Added next up operation and subroutine calls for next up and lobby request.
7/31/03 3.05 mhd		1. Added Code Blue operation
8/11/03 3.06 mhd		1. Delete using brake lift switch (BRKS) to energize brake cool relay (BRKC).
						2. Use brake lift swith to find brake fault. Add field variable fvbklftsw to enable brake switch function.
						3. Added load weighing anti-nuisance and field variable fvlwa.
						4. Added g_statusf2 int in group_io.
						5. Increased field variable table to 120.
						6. Add load weighing bypasss, load overload and earthquake operation.
						7. Deleted random call test.
						8. For ICR input, use top floor + 1 for input location.	(changes set_io_board_status)
						9. Add Load weighing dispatch.
 						10. If onward calls are cancelled during ncu sequence 3, then re-open the door.
 						11. Disable the DCB when on next up and there are no onward calls.
 						12. Leave the servf flag set to zero (in motion routine) if not on auto door operation.	
8/29/03 3.07 mhd		1. Relocate LWB and LWA when using an NDF controller.
						2. Changes cons[antinu] to cons[loadw].  Add io_board[][8] if load weighing selected.
						3. Set dpref = 1 in next up and make sure car does not go back on next up when door opend with dob.
						4. Clear nudging timer once in door routine when switching from doorf == 1 to 2.
						5. Do not set the call above flag when ncu_door_seq == 3 and up hall call at the lobby.
						6. Ring the up lobby lantern when the car becomes next up or ring at slowdown when not running next up.
						7. Do not stop going up to next up floor if car call above the lobby.
 9/9/03 3.07 mhd		8. Prevent LWA when on fire service.
9/22/03 3.08 mhd		1. Added new cons variable cons[ansi] -- previously cons[hydro].
						2. Prevent gripper test unless cons[ansi] == 2000.
						3. If in reset mode, doors open, not on the level zone and ansi 2000 (rope gripper) allow 10 seconds more
						   in reset mode to allow the mechanic to close the doors without setting the rope gripper.
						4. Add check for LC and GTS during gripper check in inctime routine to prevent a false trip during power down.
						5. Don't use the 1014 board for just lwd input.
						6. Added electric eye anti-nuisance. 
9/30/03 3.09 mhd		1. Deleted dpi output and udac and ddac on serial cop board.
10/2/03 				2. Use (sercom & 1) != 0 so car serial comm can be used without hall serial comm.  Also check
						   gc_hall_io_dev for serial hall i/o devices.
						3. Use LU and LD as lobby lantern output if cons[dispis] == 2.
						4. Add variable for independent to override car call security.
10/07/03 3.10 mhd		1. Add earthquake service.
						2. Changed timing for delta on traction start.
						3. On inspection, clear startf after MCC and MC are turned off. This will prevent the car from running until
						   the softstop ended.
						4. Read eqf on power up and store eqf on change of state.
						5. Changed the order of when setcodebf, setfsf, setempf and seteqf routines are called so the service
						   is displayed properly.
						6. Deleted doorf == 6 and doorf == 7 (not used).
						7. Use DF output for Field Forcing (FF) with a dc-scr drive.
10/17/03 3.10 mhd		8. Changed slowdown check when setting nextstop. Use procf flag with (hsf == 0) to determine slowdown since
						   DF is used for FF on DC-SCR drives.
10/31/03 3.11 mhd.		1. Zero brake and drive on timers in brk_iotest routine when run is lost.
						2. In atfloor routine, when checking that car is not level but cannot relevel, added "+15" in check for
						   soft stop timer: (timers[tsoftstp] <= (fvars[fvsst] + 15)).
						3. Added EML output for code blue.
						4. Deleted - Clear nudging timer once in door routine when switching from doorf == 1 to 2. This prevented nudging
						   from working.
11/11/03				5. Do not turn off EML until car goes off of code blue and is not on independent.
11/13/03 3.12 mhd		1. Added swing door operation see cons[mand] == 2.
						2. Open door from carcb[] instead of cc[] input.
						3. In door and rdoor, clear DC when on DCL only when dpref == 0.
						4. Zero the tsafe timer until we have a preference and doors are closing.
						5. Make sure door stays open if swing door and door not closed when on fire 1, 2, ind and att.
						6. Disable DCB if swing door and hall door not closed.
						7. Stay in reset if outside swing door is closed.  
						8. In reset, keep door close until gate and locks are made.
12/2/03 v3.14 mhd		1. Made subroutines for Update_Control_Flags, Update_Flight_Times and Update_Job_Statistics and placed them
						   in the utils.cpp file.
12/04/03 3.14 mhd		1. Corrected gate and lock fault in door routine to clear front nudging timer instead of rear.
12/10/03 3.15 mhd		1. Modified recovery for Traction distance feedback after estop and check dpp_target at ut or dt.
						2. Also modified earthquake recovery after estop.
						3. In atfloor, make sure that the position has been updated before testing position against the ut and
						   dt limits. see (preset == 1).
						4. In reset, if binary preset input on and on a level limit, do not go to atfloor if on counterweight derailment.
12/17/03 3.16 mhd		1. Set timers[vpat] = 0 after velocity set during relevel to allow for ramp to work.
						2. Added parameter fvars[fvbkcrel] to enable dropping the brake cool relay immediately during a relevel
						   to proved a partial brake lift on relevel.
						3. Added parameter fvars[fvbksrel] for a seperate brake pick delay during relevel.
						4. Prevent the car from releveling with the doors open if the doors are open and not in the door zone.
						   Close the doors first then relevel. (see ((rdinp(DZ,DZB,DZD) == 0) && ((door_locks() == 0) || (car_gate() == 0)))
						   in atfloor, door and rdoor).
						5. Added Retiring cam output on OT3 for cons[mand] == 2.
						6. Added inspection check to retiring cam fix.						
12/23/03 3.17 mhd		1. Added Handicap Buzzer enable input.						
12/22/03 3.17 mhd		1. Add new security_type[] = 4 for seperate car call and hall call lockouts.  Use the rear car call 
						   lockouts for the hall calls.
12/24/03				2. Added trigger mechanism for up peak.
						3. Added parameters and variables for up and down peak operation.
1/5/03					4. If while in motion, car hits the up or down normal limits, do an estop and wait for the fault
						   timer to expire before going to the atfloor routine.	Also do not clear the softstop timer in this 
						   condition.
						5. Dynamically set the next_up flag and send to each car.
1/8/04 3.17 mhd			6. When on access with no run inputs, the car is still safe.  see safe() routine.
						7. If running and a lock is opened, do not set the brake cool relay, instead make sure it is cleared to cause
						   the brake to drop quicker.
1/12/04 3.18 mhd		1. Changed to open door from cc[] instead of carcb[] since carcb[] will not open the door. 
1/16/04 3.19 mhd		1. Added up and down peak software.
						2. Added hall call cross assignment procedure and variables.
						3. Added Overspeed test and Buffer.
						4. Added special operation for extended door hold w/light and car call cancel door hold time operation.
2/17/04 3.20 mhd		1. Renamed this routine to Control.cpp and moved door routines to door.cpp to correct "too much global data" error.
						2. Added Mass. Medical Emergency Service.  Note: Fire service does not override medical emergency service nor 
						   does med em serv. override fire service.
						3. Use booleans for fire buzzer, nudging buzzer and medical emergency buzzer to fix buzzer bug when using serial
						   comm board on the car (fire and nudging buzzer are the same output).
3/4/04 mhd				4. Corrected error in setting med_buz instead of fire_buz during phase 1.
3/2/04 4.00 MHD			1. Deleted special pi output spis[].
						2. Deleted [io_sel] array acces to i/o's.  Most i/o's use labels from hmmap.
						3. Added watch-dog check for new CPUs.
						4. Added TOC can comm error.
4/21/04 4.00 mhd		1. Setup new io locations for 1038 board. Changed board initialization, io addresses and started io array at 0.
5/6/04 4.00 mhd			2. Changed drop delay for mc from 1.5 seconds to 1.0.
5/10/04 v4.0 mhd 		3. Allow fire phase 1 car to go off of phase 1 if the key switch is turned to bypass on ansi 96 or reset then off
                           for ansi 2000 if the car is not in sevice and is not in the recall process.
						4. Added variable to select which floor the fire car returns to when the machine room or hoistway sensors
						   are activated.
5/13 v4.01 mhd			1. Modify com3 to use with Magnetek drive.
						2. Modified gripper operation.
						3. Go from safety string mode to inspection mode if car on inspection and not on ss.
5/26/04 v4.01 mhd		4. Set directions arrows with returning on code blue and medical emergency service.
6/25/04 V4.01 mhd		1. Use UDAC and DDAC on the TOC all the time eventhough the pi's are not used.  These are needed for attendant.
						2. Change io_dbn_time from 500 msec to 1 sec. see chk_start.
7/1/04  mhd				3. Set power up reset error each time the car powers up.
7/16/04 v4.02 mhd		1. Changed entire fault code mechanism.
						2. Moved check for io_fault reset to inctime.
8/12/04 v4.03 mhd		1. Qualified up and down directional fault with drive ready.
8/27/04 v4.03 mhd		1. Added reset jack routine (procf == 18).
						2. Modified servf flag when parking to reset back to servf = 1.
9/20/04 v4.03 mhd		1. Added changes for Chicago fire service (see cons[firesv] == 3).
10/18/04 				2. Modified Chicago Fire Service phase 2 with phase 1 switch off.
11/3/04					3. Do not test for brake switch during fire service.
						4. Added front and rear slowdown for hall lanterns.  Changed (nstopf == 1) to (nstopf != 0) in serveral places. 
						5. Added rear hall lanterns. 
12/2/04 	mhd			6. Added pattern delay on relevel.  Use DON input to qualify the start of pattern delay and brake pick delay. This 
						   function can be disabled. 
12/5/04 v3.36 mhd		1. Added cons[access_type] to verify the locks correctly at the top or bottom.
						2. Modified chicago fire service to allow the following:
								a. Car to returns to fire alternate floor from main floor smoke sensor. 
								b. Fire key switch has been activated and car returns to main fire floor.
								c. Fire key swith is de-activated while main fire floor smoke sensor is still active.
								d. Car return to alternate floor.
							Use fire_sensor flag set to 1 = main recall, 2 = alternate recall.
1/3/05 v4.04 mhd		1. Prevent car from running with Safety processor board can error.
1/10/05 4.05 pn			1. Added field variable to invert brake lift switch input.
						2. Added field variable to invert in-service light output. 
1/10/05 4.05 pn			3. Added field variable to change a car other than 1 or 2 to become the master
1/21/05	4.06 mhd		1. Added cons[shortfl] software option.
						2. During reset, set position to top or bottom if ndf or hydro and running
						   servf 12 or 13 to find a floor.
						3. During reset, close doors if waiting for door to run.
						4. Do not check DF or UF in chkrun when UT or DT are made (for hydro only).
2/24/05 4.06 mhd		5. Make correction to short floor to not increment or decrement position when on terminal
						   limit and running between the short floor to the limit.
						6. Added staggered rear floor DTR control.
2/9/05 v4.07 mhd		1. Added pre_torque and load antinuisance for analog load weigher.
2/10/05	v4.07 mhd		2. Allow reset floor recovery five consecutive time and then give up.
						3. Added load weighing calibration routine servf = 18.
						4. Set timers[tmotion] = 0 in chkrun just prior to a run.
						5. Added tpatdly 10 msec timer and corrected timer index. 
						6. Added fault_run to shutdown after 4 runs with consecutive pulse or stall fault.
3/22/05 4.08 mhd		1. Fix display service change in return_to_lobby.
4/24/05 4.08 mhd		2. Deleted ot1, ot2 and ot3.
						3. Changed LU, LD, LUR and LDR to lant_up, lant_dn, rlant_up AND rlant_dn.  Use LU and LD for
						   lobby lantern only.
						4. Changed UDA and DDA to up_dir_arrow and dn_dir_arrow.
						5. User ISER and TCU when not using lobby lanterns.
3/24/05 mhd,pn v4.08	6. Divided don_dly by 10 when using motion timer.
						7. Fixed non-interference timer in chkrun.
						8. Make sure tpatdly timer does not go above 32000.
4/9/05 mhd v4.09 		1. Corrected trst timer index from 30 to 40.
						2. Fix index on loop_cnt_ptr from >9 to >=9.
						3. Debounce the safe() inputs in motions routine for 300 msec.
						4. In reset(), set Enc_Base_Count each time DPP_Count is set.
4/17/05 mhd v4.10		1. Use RCM (Retiring Cam) whenever manual doors are used. Changed (cons[mand] == 2) to
						   (cons[mand] != 0) on check for RCM.
4/18/05 mhd v4.11		1. Use car call dwell timer when cons[mand] == 2.
4/22/05 mhd 			2. Changed Security_Type to allow both car call lockouts and group car call lockouts.
4/23/05 mhd v4.12		1. Use manual_door flag that is set from cons[mand] and staggered rear mask to allow special
						   rear manual door and automatic front.
						2. Added Sabbath service.
						3. In set_door_close_during_reset, deleted check for ind to set door close.
						4. Set low oil flag if at floor level and low oil switch on.
4/28/05 mhd v4.16		1. Added limit_fault for UT, UTS, DT and DTS.
						2. Use status sf_LC flag to only set fault code once for LC blown fuse fault.
5/12/05 v4.18 mhd		1. Added man_dcc() routine to check door close contacts for manual doors. Manual door close contacts
						   are added in the lock circuit as well.
						2. Do not allow the car to run from a motion fault until the fault timer expires and the car is safe().
						3. Clear RST output when leaving safety string mode.
						4. Do not leave safety string mode unless ready is made.
						5. If READY and LC not made in RESET mode loop, jump to safety string mode.
						6. Check statusf for LC, READY and SS to set error code. 
						7. Set statusf flag for GTS input if not A17.1 2000 code.
5/27/05 v4.19 mhd		1. Use pattern delay timer to lift the brake on traction df cars.  
						2. Change timing on failure check for DON and BRKI inputs.
						3. Add Car Switch Software.
						4. Move retiring cam output to TCU/LLU.
						5. Deleted setting TCU because this function is done with LLU software.  Also clear LU AND LD in clrlant routine.
6/9/05 v4.20 mhd		1. In atfooor and car switch software, reset position on dt or ut limits.
						2. Place car switch direction in front of reset pilot in dirsel routine.
						3. Run the car from the car switch on reset.
						4. Delete setting timers[tmotion] just after chk_start because this causes the y-delta time to run twice.  This
						   change should be okay since the brk timing is done from the pattern delay timer.
6/16/05 v4.21 mhd		1. Exit low pressure routine if on inspection or safeties.
6/17/05 V4.22 mhd		1. In reset mode, car on fire phase 1 at a floor but not the fire floor, car is lost (rset == 3), allow the car to
                           reset (do not return to atfloor mode, check for rset == 3).
6/22/05 v4.23 mhd		1. When entering main, disable the 18.2 msec DOS interrupt any unused DOS interrupts. 
6/22/05 V4.23 mhd		2. Added local gettime, getdate, settime setdate so that the 18.2 msec DOS interrupt could be disabled.
6/23/05 V4.23 mhd		3. Allow cross assignment variable to be set to 2 max.
6/27/05 v4.24 mhd		1. Change the ids_cc_sec and ids_rcc_sec to arrays for each car.
6/6/05 v4.24  mhd		2. Output LU all the time unless manual doors (RCM being used)
						3. Added pulse count error codes.
7/14/05 v4.25 mhd		1. Added default statement at the end of all switch case commands is there were none.
						2. Use tsoftstp instead of tgen for FF.
7/21/05 v4.25 mhd		3. Corrected emergency recall to the recall floor. see (( empf == 0) || (empf == 6)) in motion and needstop.
						   Also in dirsel() recall_fl was set to cons[bottomf] instead of fvars[fvepfl] for emp recall.
						4. Fix rear cab lantern.
						5. Moved the check for front and rear slowdown in needstop so the correct door would open on ind() when
						   the car slowed down at a terminal limit.
7/27/05 V4.26 mhd		1. Changed fault code from MC to MCA.
8/15/05 V4.27 mhd		1. Made correction to RCM output logic. (Added back dpref != 0)
8/16/05 mhd v4.28		1. Leave Run output on during softstop until ready to drop MC then drop run and mc at the same time.
                           Since a Run contact is in series with mc anyway also for the HPV drive, you can ramp down the 
						   torque after the run command to the drive (up or dnr) turns off but mc (and run contactor) is still on.
8/22/05 mhd v4.29 		1. Added brake control subroutines drop_brake() and pick_brake()
						2. Clear hb_en (handicap enable buzzer output enable) when in atfloor and dpref is zero or when
						   setpref is called and the preference has changed. 
						3. Must have ready and gts to leave safety or if no gts then controller can go on inspection. Could not 
						   reset rope gripper from inspection switch because car was on safeties and could not exit.
9/7/05 mhd v4.30		1. Allow the car to relevel on the normal limits as long as the car is in the door zone DZ == 1.
						2. Change handicap buzzer to use boolean variable for handicap_buz and hb_cc_buz.  Added car call buzzer
						   to beep when a car call is pressed and the handicap buzzer is enabled.
9/9/05 mhd v4.31		1. Fix bug for handicap enable buzzer.  Delete clearing hb_en in setpref and have code only in start
                           of atfloor.  Buzzer would not sound at the last floor if there were no onward calls.
						2. Set the brake pick time minimum to 1 so for software updates, this variable will be preset 
						   to the default.
9/13/05 mdh v4.32		1. Use UDA and DDA as attendant up and down lights when on attendant.
						2. Added door ovl door operator operation. see cons[door_type] == 1
						3. Added heavy front and rear door output.
9/23/05 pn v4.34		1. Added procedure call for peelle doors if freight option in cons file is set to 2.
10/19/05 mhd v4.36		1. Set Gripper sf_GRIP from inctime. Reset gripper from LCD interface. Delete using gripper_reset flag.
10/31/05 mhd v4.37		1. Added safety string status and power status. Created safeties routine.
11/01/05 mhd v4.37		2. Added Emergency Power Transfer input to shut the cars down prior to power transfet.
						3. Added Safeties routine to have the car go on safeties instead of just SS input.
						4. Do not pre-torque during relevel.  Set_Pre_torque must still be called to set the pre_torque_set flag. To 
						   disable the pre_torque, the torque value is set to zero immediately after calling set_pre_torque.
11/4/05 mhd v4.38 		1. Added 60 field variables (fvars).
						2. Added state to gripper_test so now gripper test ends at 4.
						3. Modify gripper fault check to set gripper_trip_enable flag when on access or car top with door lock bypass.
11/8/05 mhd v4.39		1. Added motion_fault flag if car overspeeds > 1.25% of contract speed and turn off PFC relay.  
						2. Deleted turning off PFC relay for i/o fault.
						3. Added function of FSX (aux fire hall switch) for a17.1 2000 code. 
						4. Changed output function of FSO on 1038 board to turn on during any fire service or only 
						   when phase 1 in effect (use fvfsofl). ALSO use bit from fvfsofl to flash output.
						5. Added FSO output on car security boards. 
						6. Added function with fire reset adjustable variable to allow fire service to be reset if phase 1 activated by
						   the FS key switch and the the key switch is then turned off.
						7. Allow car to return to alternate recall floor if first placed on phase1 from ALT sensor, car returns to alternate floor,
						   car then moved to the main recall floor by the FS key swtich, then the FS key switch turned to off.	
						   Per A17.1 Interpretation Inquiry 03-15. (This also prompted the change in item 6).
						8. Deleted setting onward_cc and onward_calls in dir_sel.  These variables are only set in get_onward_call routine.
						9. Deleted return for P input fault in chkrun.  This is being checked in chkstart.
						10. Added safe_closetry counter if safe() == 0 in chkrun.  This will cause the door to stop cycling after 6 tries but
						    the DCB will cause the door to close and try again. 
						11. Added door open delay see tdodly.
11/21/05 mhd v4.40		1. Added security recall to recall car to lobby when security input first activated.
						2. Change to prevent DOB to override security unless adjustable variable is set.
11/23/05 v4.41 mhd		1. Change DIO1 port to input and use DIO2 port for outputs.
						2. Set gripper_test = 0 when exiting motion from eexit or estop.  This will prevent a gripper trip 
                           on a false start.
11/29/05 v4.41 mhd		3. Added security recall floor.
12/8/05 v4.43 mhd		1. Use input on DIO1 for dynamic brake resistor temperature trip instead of external temperature sensor from SPB.
						2. Deleted Dynamic Brake Resistor temperature variable.
12/13/05 v4.44 mhd		1. Clear FL when leaving Fire 2 and not on phase 1.
						2. Allow empower car to be considered recalled when on phase 1. (Revamped the recalled statement).
						3. Change reset to always time in the reset loop before checking inspection or safeties.  This is to allow
						   a clean reset on powerup and to prevent a nuisance gripper fault.
12/22/05 v4.45 mhd		1. Changed hydro feature to set iser if fvins > 100 to fvins > cons[speed].  This is to allow seperate operation
                           to run car at top speed on inspection: setting iser in control or setting df/upf in inspection.
						2. Changed default inspection from 75 fpm to 40 fpm so that high speed inspection run would not be activated on
						   most jobs automatically.
1/13/06 V4.48 mhd		1. Added Fire Fighters Stop switch for A17.1-2004 Code.
1/16/06 v4.48 mhd		2. Modified estop to find correct position. Deleted using recover_sd (with the correct position is was no longer needed).
1/23/06 v4.49 pn		1. Added courion and ems automatic freight doors.
2/1/06 v4.50 mhd		1. Added Terminal limit debounce.
						2. Modified Fire Fighters Stop switch to have the stop switch immediately after SS.  The FFS input is qualified with SS.
						3. Allow LWA, LWB and OVL for hydro and traction ndf cars.
						4. Changed lant_dn = 1 to rlant_up = 1 (fixed mistake).   
2/2/06 v4.51 mhd		1. Changed front_slowdown and rear_slowdown to set slowdown and door open bits.  The door open bits will cause
                           the door to open even if the car or hall call inputs go away.
                        2. Added short dwell door timer so that when ee or se hit with only hall or only car call, the door time will be shortened.
                        3. Added fix to security recall to set servf = 1 if sec_recall == 1 and off of security.                  
2/3/06 v4.52 pn			1. Call the hall lantern routine when freight doors are used.
2/6/06 v4.53 mhd		1. Added DZA test.
						2. Added SFC,PFC TEST.
						3. Added fix to run down (turn on RUN and RUNA) on reset for hydro cars.
2/9/06	V4.54 PN		1. Added parameter to select a second car to swing in IR.
2/16/06 v4.55 mhd		1. Add operation for swing door w/pwr gate staggerd rear and automatic front: set manual_door = 2.
						2. Do not use RCM when Lobby lanterns used.
2/24/06 V4.56 mhd		1. Use MST to control motor contactor when using a soft starter (Drive_Type == 9).
						2. Get i/o fault and shutdown if UFi or DFi turn on while leveling.
3/8/06 V4.58 mhd		1. Corrected reset_jack routine to set and clear RUNA with RUN and MCA with MCC.
3/14/06 v4.59 mhd		1. Added parameters to invert TPL, LPS and LOS.
						2. Added parameter to nudge door with no onward calls.
						3. Clear the up and dnr output if pfc/sfc test interrupted - search for (chkdoor() == 1).
						4. Added fvfireop variable to allow blinking FSL after fire key switch active on chicago service.
3/23/06 V4.60 mhd		1. Allow relevel up on a hydro with drive_type == 9.
						2. Added check for FSTI in chk_start.
						3. Allow emergency power sequencing for hydros.
4/4/06 V4.61 mhd		1. Made TDC input an array to use EQR input.
						2. Added parameter to set car call from hall call when on attendant.
						3. Clear the rear door operator open and close in the clrall routine.
4/6/06 V4.62 mhd		1. Added cons variable pbdoor for push button door operation.
4/12/06 v4.63 mhd		1. When using UDA and DDA for attendant arrows, turn off output when not on attendant if cons bit set.
4/24/06 v4.64 mhd		1. Added grp_codebf[] variable to alert car to flash indicator when car on ind and code blue requested.
						2. Added hospital service 22 instead of going on independent.
5/3/06 V4.65 mhd		1. Record fault even if same fault code repeated.
						2. Rename group_cc_lockouts to group_lockouts and call routine when Grp_HC_Lockouts == 1 also. This fixes
						   bug when security_type == 32 only.
						3. Modified access in safe() routine to return 0 if front access and rear gate open or rear access and front gate open.
						4. In reset mode check safeties() to validate if GTS input is on.
						5. Add gripper reset time.
5/19/06 v4.67 mhd		1. Added fvtorqoff variable.  
						2. Force get_load value for manual door all the time in atfloor routine.
						2. Do not check for top or bottom floor when ut and dt on and buffer_test is 1.
						3. Added P input debounce while in motion.
						4. Test velocity from SPB to set gripper for unintended motion.  Use fvars[fvspbgrip] set to 1 to enable test.
						5. Reduced debounce time for safe while moving from 3 to 1.
						6. Added debounce timer for brake drop to set the gripper and check for LC.  This is to prevent a false gripper fault
						   on power down.
5/24/06 v4.67 pn		7. Added option for courion model D door operator. 
5/30/06 V4.68 mhd		1. Added ED for remoted car call station instead of INDC.
6/2/06 V4.69 mhd		1. For car switch, bypass hall call when switch is in. (see motion and needstop).
6/27/06 v4.74 mhd		1. Use the in-service light variable fviser to also change the in-service light to an in-use light.
7/7/06 v4.75 mhd		1. Change car_dat[7] to car_bld_no[7][2].
						2. Added variables fvdonodol and fvdisglt.
7/12/06 v4.76 mhd		1. Added special conditions when to increment the fault count.
7/27/06 v5.00 mhd		1. Add fault check for UL and DL.
7/28/06 v5.0 mhd		2. Corrected UT position check in atfloor routine for short floors.			
						3. Move door zone fault check to atfloor from ckdoor
						4. Reset inspection fault timer when leaving sstring routine.
8/15/06 v5.01 mhd		1. Added fvars[fvrlvst] relevel start speed.
8/16/06 v5.02 mhd		1. Added fvars[fvemdec] (Em_Decel) for the emergency decel rate.
8/30/06 V5.03 mhd		1. Added tfltdelay timer to wait for fault packet for non-group car to user interface.
8/30/06 v5.04 mhd		1. Added cons[mand] == 6 for rear swing door and automatic front.
						2. Changed access in safe and access_door_safe routine to always have middle door locks and aux locks
						   to run on access.
						3. Close both doors simultaneously during close_doors_during_reset() routine.  Added mechanism to keep the
						   door close output on to make the locks (see force_close flag).
						4. Added return to lobby flag to cycle door at the lobby and to cycle door on reversal.
10/6/06					5. Change default for gripper test from safety processor board from 1 to 0.
10/3/06 5.05 mhd		1. Hydro car: In inctime, with emp lowering, check for position == ep_recall_fl to consider the car recalled.
						2. In motion routine, set tmotion timer to 0 if safe() != 1 so that the stall timer dose not expire if the
						   door is open.
						3. Rename f_low_oil to f_stall_fault since that is what is displayed and set stall fault for traction when
						   the stall timer expires.
						4. Added update_pos to keep an updated position.
						5. Added staggerd auto/swing door option.
						6. If on independent and close door on car call bit is set then cancel remaining car calls at slowdown.
						7. Make sure hydro car is at the floor on emergency power transfer EPT before timing the dwell time.
						   Also zero the dwell timers at the final stop.
10/13/06 v5.06 mhd		1. Added parking type fvars[fvparktype] variable.
10/30/06 v5.06 mhd		2. Set lobby up request mask to 1 or 5.  When set to 1 that car is assigned the lobby up request or a standard
					   	   up hall call. When set to 5, the car is assigned the lobby up request but uses the secf input to determine
					       if the standard up hall call can be assigned to this car.  Bit 2 is set in software to disable the standard
					       up hall call assignment when SECF is on.  To use this feature, the secf feature must also be programmed. 
11/1/06 v5.07 mhd		1. Added DZDE door zone door enable output control.
11/6/06 v5.08 mhd		1. Added UT6/DT6, UT5/DT5 and UT4/DT4 slowdown limit count and speed check.
						2. Use Velocity as the calculated value for the speed profile but use Dmd_Velocity as the clamped velocity
						   to the drive, display and the check velocity.  This is to correct a problem that if limit_velocity routine
						   changed Velocity (as in older versions) when the car first hits roll mode, a velocity calculation error can
						   occur causing a f_zero_vel_error, or the velocity to go to zero undetected and the car to stall, or causing
						   the velocity to decel and then jump back up to the clamp velocity after zero reached. Seperating the clamped velocity
						   from the calculated velocity fixes this problem.
						3. Added non-simultaneous door operation. Added fdoor_req to prevent car from running if an opposite door was being
						   requested to open.  Added nudging status "nudgst" to keep track if a door was nudged closed with an up or down preference.
						   Use nudgst in direction selection (dirsel) to prevent the dpref from changing back to a door that was nudged closed.
						4. Added flag for cab lanterns to send in can bus PI packet.
						5. Added clr_door_vars() routine to clear the new door control variables.
11/29/06 v5.09 mhd		1. Added variable for pre-opening door and for percent overspeed. User preopen variable instead of cons[predo] and
						   use percent overspeed fvars[fvovrspd] for trip value from 110 to 125. 
						2. Modified variable for gripper trip from spb speed and overspeed. Set gripper when flag set and car overspeeds.
						   Set gripper on 125 percent overspeed always (provided 2000 code or above).
12/4/06 5.10 mhd		1. Inverst default for clf.
						2. Turn on EMLH (light in hall) when car on hospital service.
						3. Added system to update Position pulse count while moving and not in slowdown.
						4. Reset relevel timer trelev only after car dead level and MCC has dropped out.
1/3/07 v5.11 mhd		1. Keep the lanterns on if the cab lantern on timer is greater than the dwell time.
						2. Use -1 for max number of cars and -2 for max number of floors for max adjustable variables and
					       use -1 for car number and -2 for bottom floor for the min variables.
						3. Allow traction car to relevel immediately if overshoots the floor.
						4. Change lowoilf to stallf and lowoil() routine to stall() routine.
						5. Use stallf flag to latch turn off of run outputs instead of using tmotion timer and fvstall time (in atfloor).
						6. Added adjustable variable to set relevel time.
						7. Added lowoil switch fault.
						8. Allow stall timer to stop car after recovery from a stall (in motion).
						9. Set reset fault only if (rset_run_cnt < 5) so that reset faults don't fill up the buffer.
						10. Don't try to run again if there was a stall fault.
						11. Set preset_pos = 1 if emergency mode entered (mode 8) so that when the car stops the position is
						    updated from the binary preset. 
						12. Changed all double data types to float for the djgpp compiler.
						13. In reset, if count less than 5, try to run anyway, don't care about direction.
1/12/07 v5.12 mhd		1. Use stall flag to lacth LOS condition in motions to allow car to run down otherwise each re-try causes
                           another fault until you get an estop.
1/12/07 v5.13 mhd		1. Do not set the call above or call below flag in dirsel for an at floor hall call if manual doors otherwise 
                           the RCM output will pulse.
						2. Add bit in fire option to turn off fire buzzer when car reaches fire floor.
1/17/07 v5.15 mhd		1. Clear timers[tnit] if freight door and direction change and calling for a door open.  This will prevent 
						   dirsel from being call until the tnit timer expires allowing the lanterns to work properly.
						2. Added cons[FSX_rear] to open either door at walk-thru floor with two fire switches at the main landing.
						   FS opens the front door and FSX opens the rear.
						3. Modified chicago fire to use field variable fireop2 bit 1 to wait until the door has been opened to allow
						   a phase 2 return if the phase 2 switch is off.
						4. Modified atfloor() routine to check for DFI and UFI all the time while at the floor, a run is not commanded
						   and the upf and df output are not on.  Removed the check for UFI and DFI within the floor level and not able to 
						   level section of the code. 
						5. When closing door in reset, ignore EE but if the EE hit turn on the buzzer and close at nudging speed.
						6. Moved stall timer in at floor to look for stall only when you are trying to relevel.
1/26/07 v5.15 mhd		1. Set Door Close Contact status flag in reset mode and in chkdoor when swing door is open.
						2. Set stop switch status flag in reset mode and stop switch hit.
						3. Clear the statusf flag BPI on entry into at_floor.
						4. Don't zero statusf flag in reset only clear the POS bit.
						5. In reset routine, moved the check for door close contact open for swing door after DZ check and delete tha check for DZ == 0 since
						   it is not down previously.  This is to show the Door Close Contact status if stuck in reset from no dcc.
1/29/07 v5.15 mhd		7. Changed default brake opto trigger default from 200 to 5500.
2/9/07 v5.18 mhd		1. Changed iodata and related arrays from 85 to 145	and also changed gpi and related arrays from 11 to 30.
						2. Increased the number of car io boards from 27 to 48 and increased the number of group io boards from 20 to 46.
						3. Modified the hall call comm loss to accomodate the additional boards and added more timers.
						4. Changed Group_IO_Com array to allow for 60 floors.
						5. Made arrays out of variables that used one bit for floor from 1 32 word to 2.
						6. Added more pages for the car and group io display.
						7. Made the floor mask large enough for 60 floors.
						8. Added a bp32 for more than 31 floors.
						9. Set board types for 48 boards instead of 27. 
2/22/07 v5.19 mhd		1. Call setfsf() routine from sstring() routine to set fire buzzer if car top stop switch open and car goes on fire service.  Also
  						   check for safeties() == 0 in setfsf() routine.
						2. Added functions for IDS: rtl, ad_off, heof, ind and alt_fl_sec.
						3. Use UL, DL, UL_ON_Fault, DL_ON_Fault and DZ_ON_Fault to qualilfy pre-opening the door.
						4. In inctime to increment uctim and dctim use grtop_rfl instead of cons[rear].
						5. Added interim revision number int_revision.
						6. Don't accidentally clear the lanterns in atfloor() when doing the pfc_sfc test.
3/8/07 v5.19 mhd		7. Made ids_ind, ids_rtl, ids_heof and ids_ad_off array values.
						8. Allow security floor to be zero so all floors can be secured. If zero then recall to bottom floor.
3/15/07 v5.20 mhd		1. With swing door (manual_door == 2), use doort instead of fvars[fvccdt] to release the direction pilot so that the door times 
   						   according to hall or car call.
3/25/07 v5.21 mhd		1. Qualify the ETH and COL inputs with LC to prevent a false trip of counterweight derailment on power cycle
4/3/07 v5.22 mhd		1. When switching security floor mask, cancel the car calls at the floors with the invalid mask.
						2. Use fire_floor instead of position to set servf if firef == 3 and servf != 9 or 10.
						3. Set motion timer and fault timer to zero in motion routine if safe() = 0, fire_stopsw_hold == 1, or on emergency power.
						4. Added fvars[fvlevfltcnt] leveling fault count variable.
						5. Added torque down variable fvars[fvtorqdn].
						6. Added leveling fault check to detect fault if brake does not drop.
						7. Added RCM_SwingDoor cons flag to use RCM in a special mode with a swing door.
4/16/07 v5.23 mhd		1. Reset the dza, dz, ul, dl and gripper test flags in an emergency decel mode.  If car cannot leave the floor, the car
                           will fault from the flag not being cleared but the test is not valid.  Actual flags cleared:
						   DZ_ON_Fault, DZA_ON_Fault,UL_ON_Fault,DL_ON_Fault,gripper_test
						2. Correct reset jack operation to activate only if the car is at the floor, and no calls are present.
						3. Modified leveling fault check. Made default leveling fault count to 3.
						4. Set gripper if brake swith not made 200 msec before soft stop ends.
						5. Store DPP_Count in EE RAM every 10 msec.
						6. Set soft stop minimum value to .2 sec.
						7. Added multiple error codes for hoistway verify routine.
						8. Added software to use the SPB as an absolute selector.
5/14/07 v5.24 mhd		1. Cancel car call while in motion if on independent or attendant and FS2C (cancel) input pressed.				
5/25/07 mhd				2. In motion routine with rear door deleted || (rfiref >= 4) in preopen section to not allow door to
                           preopen during fire service at all.
						3. Added function for in-service output to not show out of service if on inspection.
						4. Renamed option RCM_SwingDoor to RCM_HWDoorCL to better describe the operation (retiring car to close hoistway).
						5. Added code to hold the RCM until time-out if not a valid floor for the manual door
6/12/07 v5.26 mhd		1. Modified the setting of rev_stepf flag when car stopped in mid flight to correct the car position.  Corrected direction car would run
                           after a low oil switch on fire service and also when the fire stop switch hit.
						2. Reset the DZA and DZ OFF fault if input comes back on while level to the floor.
6/15/07 v5.27 mhd		1. Add code for very short floor (see cons[vshort_tfl]).
						2. Modified check for (lby_up_req_car[] & 0x04) != 0 to set or clear bit 0x02 only.
						3. Replace BDC with BDC[bdc_io_sel] to move BDC from EMH to EQ if Mass. Med Em service used.
6/20/07 v5.28 mhd		1. Seperate front and rear down hall and cab lantern timing. 
						2. Call dirsel() and needstop() during slowdown (motion routine) to set front_slowdown and rear_slowdown 
						   variables so that lantern timing works properly even if the car is in slowdown after the call is placed.  
						3. Move car_sw control in dirsel() routine in front of emergency power section to prevent the car from
                           recalling unless the car switch is active.
						4. perform a jack reset function if manual doors are enabled.
						5. When car is placed on medical emergency or emergency power or fire service, turn off the security floor mask (SECF).
						6. Clear hall lantern timers in motion routine when the hsf flag is 1.
7/3/07 v5.29 mhd		1. Added variable for code blue car selection.
						2. Added variable for car assigned floor security.
7/10/07 v5.30 mhd		1. Added phase 1 door close time-out variable.
						2. Added RTLDC for emergency return to lobby security (Close door).
8/6/07 v5.31 mhd		1. Added variable fvnohcreop to prevent hall call from reopening when set and onward hall call.
						2. Add 60 second delay timer before starting jack reset.
						3. Added cons variable for jack reset.
						4. Do not call group_park() for simplex homing (simplex car is always a group).
						5. Call group_lockouts() if cons[ids] is set so that the ids security get sent to the cars.
8/9/07 v5.32 mhd		1. Added option for valid emergency power car to be selected to run.
						2. Clear the fire stop switch hold if at the floor and the stop switch not hit.	If not at the floor
						   and not on phase 2, clear fire stopsw hold and set dirf flag to allow car to run.
8/13/07 v5.33 mhd		1. Add bit in fireop2 to disable blink for phase 2 fire light (chicago only). Default is to blink
						   fire light when motor room or hoistway smoke detector active.
						2. Allow load weigh disable with any type load weigher.
8/17/07 v5.34 mhd		1. Allow hydro car to run up to emergency power floor (dirsel) if emergency power sequencing is enabled ((cons[EMPop] & 0x02) != 0).
                           This is when the building has an emergency power generator to run the car.  Also change needstop to also allow the car to 
						   continue running up with emp seq.
8/20/07 v5.34 mhd		1. Added drive ready fault counter.
8/24/07 v5.35 mhd		1. Added short_fl_run flag to limit Vel_Max_Set on a short floor run.  Short floor cons flag should be set on traction car
                           if floor distance less than 30 inches.
						2. Added Micro Releveling operation
8/28/07 v5.35.1 mhd		1. Add Automatic Swing Door Open with manual gate.	Note: cons[mand] == 1.
9/13/07 v5.36 mhd		1. Change accel and decel max to 300 and jerk rates to 480.
						2. Add e-stop to iser ouput check also increase max value for fviser parameter to 7 so +4 can be used.
9/24/07 				3. Also do not turn on iser for ind (fviser & 0x04) != 0) used for out of service alarm.
						4. Added fvrtldt (return to lobby door dwell time)
10/1/07 V5.37 mhd		1. Increased number of variables from 180 to 360. 
						2. Added NCU Lantern Control Variable used to turn off cab and hall lantern while car on next up after next up time.
						3. Added NCU Preference Control Variable to allow the direction preference to change after the next up time without closing the door.
						4. Modified Codeblue to use g_rcb_fl variable for rear door.
10/4/07 v5.38 mhd		1. Add variables for second Riser.  Also add variable fvsrctl for second riser control.	
						2. Added variable fvsrlant to turn on cab lantern only when ir call answered.					
10/9/07 v5.38.1 mhd		1. Set minimum RPM variable to 1 fpm.
						2. Prevent run on fdoor_req or rdoor_req only when firef and rfiref = 0 otherwise fire car can be stuck at the floor.
						3. Add parameter for attendant eta preference time.
						4. When going through reset routine do not automatically close the door if car on attendant.
						5. Don't take off in a run mode (procf = 4) after a buffer or an overspeed test.
						6. Modified brake switch test to fault if brake does not pick after 3.0 seconds, or fault after 1.5 seconds
						   if the brake has dropped. Either fault will cause the car to stop at the next landing.  This fault condition
						   is ignored on fire service.
10/19/07 v5.38.2 mhd	1. Prevent car from running if gripper fault and gts did not break (see end of reset routine).
10/30/07 v5.38.4 mhd	1. No PI or handicap buzzer if not a valid_fl[].
11/1/07 v5.38.4 mhd		2. Added debounce for drive ready (every where except reset since reset has a delay then checks once).
						3. Do not set gripper fault when GTS is lost. Might just  be a bad input or switch.
						4. Zero GTS timer when fire stop switch hit to debounce gts when switch activated.
11/1/07 v5.38.5 mhd		1. Delete gripper fault if GOV lost. When GOV opens the gripper will loose power and drop.  Manual reset will
                           will be from the Governor.
						2. Add debounce timer for safeties during moving.
						3. Quailfy UN, UT, DN and DT with ((safeties() == 1) && (rdinp(i_GTS) == 1) && (rdinp(i_READY) == 1) && 
						   (rdinp(i_STP) == 1)) before setting the position to top or bottom.  Delete setting the position to top or bottom
						   unless it is absolutely necessary.
11/2/07 v5.38.6	mhd		1. Modify chicago fire service to not open the door when car away from the fire floor without phase 1 in effect
						   and phase 2 switch turned off (use the (fvfireop2 & 1) == 0) to enable this feature since it controls the door
						   operation when are away from floor and phase 2 is off.
						2. Default fireop2 = 1 so that chicago fire servcie defaults to correct operation.
11/6/07 v5.38.7 mhd		1. Added gripper fault when GOV tripped.
						2. Change fire on/off delay to 1 second.
11/6/07 v5.38.8 mhd		1. Delete gripper fault if GOV lost.  Allow safeties to go to reset if gripper_fault == 0.  Added gov_flt_timer.
11/13/07 v5.39 mhd		1. Added Vip service.
11/20/07 v5.39.1 mhd	1. Added parameters for Emergency Power park and op outputs.
11/20/07 v5.39.2 mhd	1. Modified hoistway elevator off to be able to recall and to shut off the Cab light and fan.
11/28/07 V5.39.4 mhd	1. Move EDL to P5 from P1 and do not use P5 or P6 output when EDL is used.	
						2. Use lobby_fl variable instead of fvars[fvlob] so that lobby_fl can be changed to alternate lobby fvars[fvaltlob]. 	
						3. Added alternate lobby floor, alternate parking floor, lobby request control and 
						   handicap hall button control variables.
12/11/07 v5.39.5 pn		1. When ever the car is on an emergency service mode (e.g. fire service),
						   run the elevator between short floors at 25 fpm.  
12/11/07 v5.39.5 pn		1. Added new paramter to time-out closing of the doors if it is
						   a freight door.
12/10/07 v5.39.6 mhd	1. When starting motion from a fault, check for slowdown limits and if hit run car at 25fpm in emergency slowdown mode.
						2. Added leveling time-out.
						3. Run at 25 fpm on recovery if after a stall fault or a leveling time-out.
						4. Added rdoort for seperate door times.
12/14/07 v5.39.7 mhd	1. Added run time, leveling time and preopen time variables.
12/20/07 v5.39.8 mhd 	1. Added field variables fvhandcap and fvhandwait for handicap car capacity.
12/26/07 v5.39.9 mhd	1. Detect a short floor run when the floor position count is less than 30 inches.  
						2. Added short floor velocity parameter.
						3. Disable preopening if short floor run.
1/3/08 v5.40.1 mhd		1. Added earthquake operation for hydro.
						2. Added i/o change cons[F1_CT] (Fire 1 Car Top) to place FBNB and FL on 1040 TOC board in place of EML and EQL.  When this option 
                           is selected, EML, EQL, and OLL are moved to P2, P3 and P4 on the 1040 Car call board.  HVD is moved to DZDE location and REV is 
						   moved to the DTR location on the 1040 (if option for HVD and REV selected).
						3. Added outputs F1ML and F1AL to EQL and EML outputs.  These outputs will follow the location of EML and EQL even when cons[F1_CT]
						   selected.
						4. On earthquake for traction, (in dirsel()), attempt to run only if not dead level. Also cancel car call is stopped at the floor
						   to prevent car from latching car calls on fire service.  Also if on fire serive, flash FL.
						5. Fixed problem that if stop switch hit while car running, MCC and MCA would stay on keeping the motor running.  Instead of zeroing the 
						   fault timer, the code to allow the car to run after the fault timer expires is placed in the else part of the code.
						6. Reset leveling time-out when estop is cleared.
						7. If medf flag set to 2 but car not at med floor then change back to medf 1 to look for floor.
						8. Do not allow fireservice to revert back to phase 1 if on earthquake when not at the fire floor.  The fireman will loose control of the
						   car.
						9. When car on phase 2 and counterweight derailment occurs car stops then starts to recover. If fire stop switch is hit and then reset
						   car must not move until car call hit.  Modified dirsel() when (eaq >= 3) to prevent a direction until a call is placed.
1/15/08	v5.40.2 mhd		1. Add variable "RCM Hold" to hold retiring cam at valid floor until a door open is requested.
1/24/08 V5.40.3 mhd		1. Corrected fire service: if door open and call entered so that you have a direction then cancel the call with the fire cancel switch,
                           the car would maintain the direction and would not let you place a call in the opposite direction.  In chkrun, do not return if doorf 
						   not zero if on fire service this way dirsel() gets call regardless of the door position.
						2. Any place that FS2C is used to cancel car calls, clear the pilot so that dirsel() will be called to allow car calls in the
						   opposite direction.
						3. Move RCM_HWDoorCL outside of manual door operations so that it can be used with automatic doors.
						4. Changed name of RCM_HWDoorCL to RCM_HWDoor. Change variable RCM HOLD TO RCM Control added bit 2 for advanced RCM when RCM_HWDoor set.
2/5/08 mhd				5. Deleted check for fire service in chkrun (item 1) when doorf is non-zero.  This fix is accomplished in door and carcall routines.
2/4/08 v5.40.4 mhd		1. Added variable fvrecallfs1a to allow return from alt fire floor if main hall swith on even when aux switch used.  For Mass Fire service.
						2. On ansi 2004 fire service, once returned to the main fire floor from the FS switch, do not allow car to return to another landing.
2/5/08 v5.41 mhd		1. Added GOV gripper_fault if encoder velocity or spb velocity > 150 to latch the gripper on a GOV overspeed. 
						2. Added board type for board 6 on 1038 (for brake io).
						3. When special retiring cam used (cons[RCM_HWDoor] == 1) for auto door, make sure LU is not being set since RCM uses the same io as LU.
						4. Do not start an up level or down level unless the (in_pfc_sfc_test == 0).  Check is for a hydro with softstart that an attempted start
						   if MST is out will cause the softstart to fault and then the next io check would fail.
3/1/08 v5.41.1  hdl		1. Added timer tattbzcyc and boolean att_buz_on to allow control of attendant buzzer as an intermittent buzzer
						2. Modified check for can init in inttim() routine.
3/6/08 v5.41.2 pn/hdl 	1. RCM was not dropping when the car arrive to the floors unless demand was previously set. Change the condition so as the cars gets to the floor it will drop the
						   retiring cam for all types of courion doors.
3/10/08 v5.41.4 mhd		1. Run viscosity operation only if TPL on and relay test has run already (pfc_sfc_test > 10).
3/12/08 v5.42 mhd		1. Added brake pick rate timer and brake start voltage and pick rate parameters for pick and relevel. 
3/13/08 v5.42.1 mhd		1. Modified short floor mechanism for ndf traction and hydro cars to have slowdown limits overlap the door zones of the short floors.
						2. Added second short floor and slowdown timer for run between short floors. 
3/18/08	v5.42.2 hdl		1. Changed routine used to control RCM to no drop with the stall timer in inspection mode.
3/20/08			mhd		2. Change fire on/off delay from 1 second to 1.5 seconds.
						3. Added short floor up and down slowdown timers for short and mid short floors.  Changed current timers to down and added ones for up.
3/21/08 v5.42.3 mhd		1. In dirsel(), if cons[car_sw] == 1 and servf == 19 (EOF input on so elevator is off) then don't allow the dcalls flag to be set so the 
                           car won't run.
						2. Added fvars[fvheoffl] to select floor for hall switch elevator operations.  If zero use lobby floor.
						3. Added fvars[fvgovgrip] to enable the gripper to trip and latch when the GOV is open. 
3/25/08 v5.42.4 mhd		1. Added seperate speed profile variables for short floor run.
3/25/08 v5.42.5 mhd		1. Modified distance feedback short floor to make a short floor run to a very short floor instead of releveling (for 12" floor).
						2. Modified ndf short floor to ignore slowdown magnets between short floor and use timer on a short floor run (bit selectable) and to allow
						   the slowdown magnets to be placed between the short floors when the short floor distance is greater than 30 inches but less than required for
						   a high speed run. (See short floor control variable).
3/28/08 v5.42.6 mhd		1. Change in version 5.41.4 caused a problem to keep the MC contactor on during phase 2.  Moved check for (pfc_sfc_test > 10) to affect just
						   viscosity in atfloor().
						2. Set min for hoistway learn stall timer to 1.0 second.
4/3/08 v5.43 mhd		1. If car has an estop because safe() is lost and the car is on the door zone and gs is open then allow the car to relevel in atfloor() mode.
4/9/08 v5.43.1 mhd		1. Added security recall mechanism on each run when remote car call station security used.
						2. Added Hoistway Switch Elevator off latch and reset mechanism to use for high water in pit operation.
4/10/08	v5.43.2 mhd		1. Clear DCR and DC first time into atfloor().
						2. Set DCA output (eml) when either freight_fdoor_alarm or freight_rdoor_alarm is set.
4/15/08 v5.43.3 pn		1. Changed "cons[ids] == 1" check to "((cons[ids] & 1) !=0)" since I added
						   an option for cons[ids] bit 2 for adding an additional GPIO board for 
						   montoring of external signals through lift-net.
4/17/08 v5.43.4 mhd		1. Changed setting for DPP_Target "DPP_Target = DPP_Floor_Pos[get_valid_fl(position,2)]" to position +1 going up and position - 1 going down 
                           to prevent the car from starting a slowdown without clearing the hsf flag.  If the hsf flag is not cleared the car will not stop at the
						   next floor.
4/17/08 v5.43.5 mhd		1. Added power up start time delay to allow cars to power up in sequence.
						2. Added EP recall delay variable.
						3. Added EP recall delay timer.
4/18/08 v5.43.6 mhd		1. Added stop at lobby check in needstop() so that if you want the car to stop at the lobby even if an onward hall call, the car will still stop.
						2. Added call for grp_cc_override() for group security car call override (visitor pass).
4/22/08 		mhd		3. Added debounce for ul and dl off fault (especially for tapeless selector).
4/23/08	v5.43.7 mhd		1. Added Emergency Sheave brake control software (brake on geared sheave).
4/25/08 v5.43.8 mhd		1. Modified panic recall for grp_cc_ovrride feature to only recall if a car call is already in the call buffer.
						2. If car in motion mode and safe is lost, set servf flag to 0 after fault time to take car out of group.
5/5/08 v5.44 mhd		1. Modified fault structure so that fault code is a word instead of a byte.  Deleted com1src, com3src, com3src, gcsrc and renamed tx_empty to device.
						   Added unused1, unused2 and unused3 to keep the structure the same size.
						2. Added brake fault codes.
5/16/08 				3. Added hc on and off brightness variables.
						4. Changed min brake pick and hold voltage to 20 and min brake relevel voltate to 10.
						5. And (cons[SecFlCfg] == 1) with Sec_Fl_Mask when changing mask for second_riser.
6/11/08 v5.44.2 mhd		1. For Chicago fire service, deleted statement "|| ((cons[firesv] == 3) && ((fvars[fvfireop2] & 0x01) == 0))" for door hold section firef == 4 so that
						   door does not automatically open when the fs2 switch is turned off and phase 1 is not in effect.	Also deleted statement "|| (cons[firesv] == 3))"
						   in rear fire door operation rfiref == 4 for the same reason.
6/13/08 v5.44.3 pn		1. Removed reference for traction to include hall elevator off feature for hydro.
7/2/08 v5.45 mhd		1. Copied from version 5.44.5.
						2. Use enc_vel_fpm as well as the safety processor velocity to detect a gripper fault.
						3. Turn off PFC if gripper fault.
						4. Allow gripper trip in reset mode.
						5. Added access top and bottom floor parameters (fvacctopfl, and fvaccbotfl).  
7/9/08 v5.45.1 mhd		1. Set flag to set unintended motion flag on SPB if gripper fault.  Also set flag to reset unintended motion fault to SPB for no gripper fault on power up.
						2. Added stop at dead level from position count.
						3. Added variable fvars[fvppstop] to enable stop on count.
7/22/08 v5.45.2 mhd		1. Renamed ul_dl_error to ul_dl_offset.
						2. Deleted DPP_DZU_Count[], DPP_DZD_Count[] and DPP_FL_Offset[] to use DZU_Dist, DZD_Dist, Up_fl_level_dist and Dn_fl_level_dist instead.
						3. On emergency brake control changed chk_ins() == 0 to chk_ins() != 0.
						4. Default gripper test from safety processor board speed and overspeed setting to 3.
						5. Changed the minimum Emergency brake drop delay to 10.0 seconds from 1.0 seconds.
8/5/08 V5.45.4 mhd		1. Changed (gripper_test < 4) to (gripper_test < 10) and gripper_test = 10 to gripper_test = 15 to allow for the sheave brake test.
8/15/08 v5.45.5 mhd		1. Add parameter for sabbath restart time fvars[fvsabtim].
						2. Deleted (rset != 3) in check for for valid floor for tapeless selector (reset() routine).  Allow the check to be made so if limit is 
						   incorrect and position is correct the car will remain at the floor out of service.  
						3. Use cons[EM_BRK] == 4 for secondary emergency brake on PM AC machine if A17.1 2007 required instead of cons[EM_BRK] == 1.
8/18/08 v5.45.5 pn		1. Wait unitl DEL is on before turning on the UP output on 
						   a relevel for a hydro.
8/19/08 v5.45.6 mhd		1. Added Independent Service security operation (Security recall and activation of Independent Service).
8/20/08 V5.45.6 mhd		2. Added Security Recall as service 24.
						3. Clear zone_fl in dirsel() when on independent (servf == 2).
						4. Added cons[EM_BRK] = 5 for seperate EBC and UTM control.
						5. Moved Emergency brake control to brake.cc.
9/3/08 v5.45.8 mhd		1. Added HUGS Security Service.
9/22/08 v5.45.9 mhd		1. Check direction flag after estop and make sure it is non zero.
						2. Modified gripper test for SPB from (fvars[fvspbgrip] == 1) to ((fvars[fvspbgrip] & 0x01) != 0) so that when the vriable is set to 3 it still works.	
9/24/08 v5.46 WC/mhd    1. Automatically display fault on LCD  when it occurs. Function Refresh_LCD in LCD.cc was modified
                           as well as the function record faults in control.cc
						2. Adjustable varible fvfltdpy in globle.cc and control was to created to turn on or off the above feature
9/29/08 v5.46 mhd		3. Added reset low oil from LCD display for 2007 code.
						4. Added GOV reset.
						5. Save the stallf flag in eeprom for hydro.  Since this flag can be non-zero on power up, allow the car to run down in reset mode if 
						   stall flag is not zero.
10/2/08					6. Added behind car call cancel variable.
						7. Added door request time-out timer to allow the car to run if door_req is set but both doors are closed for 5 seconds.
10/10/08 v5.46.1		1. Clear the short floor timer "tshortfl" while the car is still on DZ to make the time-out more consistant since the car has to be moving
						   for the timing to start.
10/16/08 V5.46.1 hdl	1. Added temperature sensor shutdown for hydro.
10/20/08 v5.46.2 mhd	1. Added door enable timer for non-simultaneous doors to start the opposite door open before the first door closes.
10/21/08 v5.46.3 mhd	1. Added DTR2 if DTR is being used by staggered rear floor.
						2. Added variables, Group service parking, Binary Preset Always, Short floor hsf without hsv. (only use Binary Preset with this version)
10/22/08 v5.46.4 mhd	1. Use fvars[fvsfnohsv] parameter to set no_high_speed flag so that short floor run sets the hsf flag but does not turn on the high speed output.
						2. Added ul, ul-1 and dl, dl-1 opposite check.
10/30/08 v5.46.4 mhd	3. Added soft start on relevel.  
						4. Set Vel_Step to zero after emstop so the take-off after error is cleared also uses the soft start.
11/18/08 v5.46.6 mhd	1. Added modbus protocol parameter.
12/01/08 v5.46.5 mhd/pn 1. In main procedure check to see if d.date is greater than
						   3000, set d.date to 3000 and call local_setdate.
12/16/08 v5.46.8 hdl	1. Added check for cons[att] == 2 to set attendant hall annunciator lights.
12/4/08 v5.46.9 mhd		1. Modified set_ul_dl() to simply start the count when ul or dl first and stop motion when the offset is reached. 
						2. Added DPP_FL_Offset[position] for floor stop in set_ul_dl().
12/15/08 				3. Added DPP_Fl_Offset[position] to target floor count.
						4. Added DPP_FL_Offset[position] to DPP_Floor_Pos[position] for DPP_Count when count reset.
01/06/09 v5.47 pn		1. Added 2 timers to alternate between regular ascii pi's and alternate
						   ascii pi's.
1/10/09 v5.47.2 mhd		1. Added service timer activation of sabbath service.
1/23/09 5.47.3 mhd		1. Zero relevel timer if stop switch input lost (could be from SPB) and car wants to relevel. This is to give the SPB time to reset.
2/9/09 v5.47.5 mhd		1. Added variable "Alt Rcl FS Off" (fvaltrclfs) to allow car to return to fire alternate floor after car has returned to main recall floor from FS switch 
						   and FS switch is then turned off.
2/10/09 v5.47.6 mhd		1. Added car call push button security service activation.
						2. Added service activation timer for car call pushbutton security.
						3. Added cons variale to use local service activation timers.
						4. Added better video board exist check.
						5. When checking to update call in chkrun(), read dayofweek from local_getdate() prior loading old_dayofweek
						   so that an invalid read of local_getdate() does not cause a continuous call to Up_Date_Calls() routine.
3.1.09 v5.47.7 mhd		1. Added Clear_All_Codes_All_Floors() routine to clear floor codes in a periodic basis instead clearing all at once.
3/11/2009 v5.47.9  hdl	1. Added one timer timers[theoff] to debounce signal for HEOF. when we had "cons[Elev_off] & 4) != 0" the signal
							would misfire and make the car go out of service
3/12/09 v5.47.10 mhd 	1. Added emergency power recovery mode.
						2. Set enc_dir_timer = 0 if encoder direction changes. 
						3. With binary presets or tapeless selector, do not allow procf flag to go into atfloor if rset == 3 unless on UT or DT.  This will cause car with preset error
						   to run to terminal landing. 
						4. Added inspection decel stop parameter.
3/18/09 v5.47.11 mhd	1. Allow car to recover at Recovery_Vel (up to 100 fpm). Added fvrecvel parameter (Recovery Vel).
						2. Added Brake voltage drop ramp down parameters: fvbkdrop (Brake Drop Voltage), fvbkdroprate (Brake Voltage Drop Rate) and
						   fvbkdroplev (Brake Drop timing during Leveling flag). 
						3. Added Emergency Power Recover Direction flag variable fveprdir to select direction from load or movement. 
						4. Added Ep_Recov_Vel for emergency power recovery velocity.
						5. Added Em_Lev_Decel Emergency Deceleration to Leveling Rate.
						6. Added PI cross reference position output.
						3. Added Cycle Run operation to cycle the car on a hourly basis to prevent the bearings from sticking (Old otis machine with babbath bearings).
3/25/09 v5.48 mhd		1. Modified fire phase 1 code to NOT look at HC power input to qualify valid phase 1 if cons[HCP_Fuse] is 1.  If you loose the Main or Alternate 
						   input from the HC fuse blowing, phase 1 still should activate.	Change statement to include LC instead so that if the 120 VAC drops before 
						   the 5V drops you won't accidently go on phase 1.
4/09/09 v5.48.1	hdl		1. Mapped the DLW input to HBEN for situations where EMS and ATT are already used.
4/14/09 v5.48.2 mhd		1. Added RCM drop delay timer to delay drop when closing door on reset and peele door.  
						2. Pick the RCM in when in reset, or empdir and closing the door.  The controller door zone is 
                           smaller than the RCM zone so if the car is not in the door zone and the door is open, car must pick the RCM.
						3. In motion routine, safe() lost but on DZ to allow the car to exit estop to level into the floor.
						4. Modify ep recovery mode to wait until dead level to issue door open command.
4/16/09					5. Corrected setting enc_dir_timer = 0 only after direction has been debounced.
4/15/09 v5.48.3 mhd		1. Added lcd delay timer for KEB drive tlcd_keb_dly.
						2. Set drive software reset, drv_soft_reset, once each time reset output turns on.
4/22/09 v5.48.4 mhd		1. Added hall call red, green and blue on and off parameters.
						2. Swapped error codes f_hcb_stuck_dn with f_hcb_stuck_up.
5/15/09 v 5.48.5 hdl	1. Addded field variable to control the Door open light output on the first car call security board
						2. The empf never turned to ep_home (4). It will reset back to ep_wait_door(2) once the car was at the ep recall floor instead of going
						   to ep_home so added the checck "if ((position != ep_recall_fl))" prior to setting empf to ep_wait_door to correct the problem.
5/18/09 v5.48.6 mhd		1. Added timers for power loss brake and serial expansion. 
						2. Added fault codes for power loss brake.
						3. Added comm init subroutine call for sx_initcom() and loop call for UPS_comm().
5/28/09 v5.48.8 mhd		1. Moved cons[Dual_Ser_Riser] location in table. Using array for primary and secondary riser bits for each floor in cons file.
						2. Added additional color parameters for serial hall buttons.
						3. Added hoistway sensor 2 return floor variable.
						4. Added cons[Smoke_2004] for second hoistway smoke sensor HWS2.
						5. Added cons[INS_EN_SFC] for inspection enable and SFC input status.
6/3/09 v5.48.9 mhd		1. Added fault code for ul,dl setup count fault.  If rpm is incorrect the calculation for 8 inches is incorrect.
6/12/09 v5.48.10 hdl	1. changes array for REV for OVL door operator so it works for front and rear even when cons[F1_CT]
6/12/09 V5.48.11 mhd	1. Added SPB sfc fault check.
						2. Added UL and DL check for ropegripper trip when car has cons[Car_sw] == 1.
						3. Added fault for SPB/SFC fault, and ep recall time-out and ots faults. 
6/15/09 V5.49 mhd		1. Added new swith logic for FS2 when cons[FS2_SW] == 1. fs2_on = NOT FS2 and NOT FS2H.	Not that FS2 is then displayed as FS2OF.
7/20/09 v5.49.1 mhd		1. Added errors for up and down normal limit setup.						
7/23/09 v5.49.2 hdl		1. Added timer tattbzini to replace the non-interference timer everywhere
							in the logic for attendant buzzer operation.
7/27/09 V5.49.3 mhd		1. Deleted check for DEL on (Drive_Type == 10) in chk_start() since Quattro drive controls the MC.
						2. Added DEL check in motion() for (Drive_Type == 10) for Quattro drive.
7/30/09 v5.49.5 mhd		1. Added advanced pre-torque operation.
8/12/09 v5.49.8 mhd		1. Added selector preset fault code.
8/19/09 v5.49.9 mhd		1. Set FF output directly when car releveling if SCR drive.
8/20/09 v5.49.10 mhd	1. Added  cons[mand] == 8 for Swing front/manual doors at staggered floor with manual rear.
8/27/09			mhd		2. Added .01 second to relevel pattern delay check to call set_pre_torque().
8/28/09 V5.49.11 mhd	1. Added car call light color and brightness control variables.
						2. Added Governor trip ouput control in the location of MTB.
9/16/2009 v5.50.1 hdl	1. Added a bit to field variable stop at lobby fvars[fvstplby]. Only for a simplex car it
							forces a car call at the lobby as soon as it answers a hall call.
9/17/2009 v5.50.2 hdl/mhd	1. Corrected fs2_to_fs1 transition not to take place if the car is in ep. There was a bug where 
							the door will open at any floor if the fs2 switch was turned off while in fs2
9/30/09 v5.50.3 hdl		1. Modified location of ISER output.
9/30/09 v5.50.3 mhd		2. Added Sabbath control variable.
10/12/09 v5.50.4 mhd	1. Changed temperature sensor timer to voltage sensor timer.
10/12/09 v5.50.4 mhd	1. Added parameters for low line voltage and low door voltage.
						2. Renamed g_fire_status[] and g_ins_status[] to Group_IO_Com[i][g_fire_status] and Group_IO_Com[i][g_ins_status].
						3. Renamed Group_IO_Com[i][g_statusf] and Group_IO_Com[i][g_statusf2] to Group_IO_Com[i][g_statusf1_l] and Group_IO_Com[i][g_status1_h].
						4. Created a new statusf variable statusf2 and named group variabls Group_IO_Com[i][g_statusf2_l] and Group_IO_Com[i][g_statusf2_h].
						14. Send Galileo car control variables from group to car - ui_ind, ui_rtl, ui_heof, and ui_ad_off
						6. Added gate and lock safe faults.
						7. Added activation of group User Inteface variables ui_uppeak, ui_dnpeak, ui_alt_fl_sec, ui_ncu, ui_alt_lby and ui_alt_park.
10/22/09 v5.50.5 mhd	1. Added Emergency power speed profile parameters.
						2. Added inspection ISER parameter to use ISER as inspection speed output.
						3. Added Top speed parameter.
						4. Added Emergency power recover time-out parameter.
						5. Modified emergency power operations to set empf to ep_wait_door if group sends grp_empf[0] flag set to ep_timed_out, 
						   ep_out_of_svc or ep_wait_door.
						6. Added parameter to allow fire light to be turned off if car not selected to run on emergency power.
						8. Allow phase 2 to phase 1 during emergency power recall.
						9. Recover the car in the direction of the recall floor if car on fire service.	A17.1-2007
						10. To allow fire service car to recover after power up when the car is on phase 2, a car call must be entered.(a17.1-2007)
						11. Added emergency power manual select enable flag to prevent the manual selection from occuring until after the car return to the 
						    recall floor.
						12. In reset() routine, only delay on the first time through.  Use procf = 0 to set the timer and then goto procf = 1.
						13. Added check for ids and galileo (((cons[Elev_off] & 3) != 0) || ((cons[ids] & 1) != 0) || ((cons[Galileo] & 1) != 0)) in elevator_off() routine. 
						14. Allow DOB to be operative at fire recall floor and at any landing if the car cannot run.
						15. Added fvars[fvflots] fire light out of service parameter to turn off FL if car cannot run.
11/9/09 v5.50.6 mhd		1. Moved advanced pre-torque check for DPM in chkrun() to just before dirsel() otherwise the preference can
						   change before the door closees.
						2, Corrected sabbath control with ir by using fvsabbctl control bit.
11/11/09 v5.50.7 hdl	1. Added eor_io_sel to locate the EOR input at EQR terminal on main io board or in a separate board
11/25/2009 v5.50.8 hdl 	1.	if servf == 25 disable direction arrows and lanterns
11/30/2009 v5.50.9 hdl	1. For RCM_HWDoor == 1 added logic in diag() to reset timers[tpredo] to zero
							prior to this change, if FS turned on in flight, car will stop and 
							RCM never picked up unless the doors contacts were broken
12/7/09 v5.50.11 mhd	1. Corrected bug. When reading DZSA, UNS and DNS (located at array 120), the data gets put in the array for car 2 if not using Tract_HR software
                           because the regular traction software uses only 85 bytes for iodata.	 Check for Tracth_HR and cons[sel_type] == 2.
						2. Added power control epr_set_power() for single phase UPS recovery.
						3. Added error codes for run inhibit from reset count, at floor shutdown and emergency motion exit from inspection.
						4. Added inspection debounce timer and change saftey string debounce time.
						5. Clear rset_run_cnt if there is a manual condition keeping the car in reset such as stop switch, Door close contact
						   or fire hold switch, etc.
12/15/09 v5.50.12 mhd	1. Request encoder position from SPB before reset timer
						2. Call set_dir_arrow() in both places that hlants() is called.
12/18/09 v5.51 mhd		1. After an estop during motion(), always recover to the nearest floor before continuing to call (traction cars).
12/28/09 v5.51.2 mhd	1. Added ee cancel dwel parameter.
						2. Added logic for sabbath_active flag to turn off sabbath when car is at lobby and ((fvars[fvsabben] & 0x04) != 0).
						3. Turn on SABO output when on sabbath.
						4. Replaced ((rdinp(SAB,SABB,SABD) == 1) || (tmr_svc[s_sabbath] == 1)) with (sabbath_active == 1)
						   in motion() routine.
						5. Corrected logic for SABUZ output.
						6. Modified in service light for swing door operation.
1/6/10 v5.51.4 mhd		1. Blink fire light if car on phase 1 from a hall sensor but hoistway sensor goes off after the recall starts.
						2. On emergency power, set the empf flag to ep_home if the group sets it to ep_home.
						3. Allow the car to go off of phase 2 if not selected on emergency power but at fire floor.
						4. Allow fire phase 2, attendant and independent service to run when car on emergency power recall.
						5. In ep_recall_ok() routine use servf == 2 and servf == 4 instead of looking at I/Os so that when the car is on ind or att and emp
						   and then goes on fs1, the car can go off of fs2 then turned off.
						6. Allow the phase 2 car to run during emergency power recall.
1/15/10 v5.51.5 hdl		1. Added ids_allw_door, ids_return_flr, ids_return_typ, g_ids_return to handle the operation for liftnet emergy recall services. The return type is done to
							bypass the incar stop switch. Bothe returns work off the same elevator off routine.	
1/18/10 v5.51.6 hdl		1. Added logic for swing door to advance safe_closetry counter in the even that the door lock does not come on.
							Problem was the car will keep cycling doors indefinetely.
1/21/10	v5.51.7	hdl		1. Checked for code blue before turning on the Binary PI in the COP board. P1 adn P2 in the car stations were still turning on and off even though
							the PIs were not mapped in the car station board. Also EML was following DPI3
1/26/10 v5.51.9 mhd		1. Communicate to UPS when EP Recover and Eaton UPS system.
						2. When power is being transferred using single phase ups, stop the car if it is running.
						3. Change pwl_com() to UPS_com().
2/8/10 v5.51.10 mhd		1. Added parameter to assign parking floor to car with door open.
3/12/10 v5.51.14 mhd	1. Added call to group to swap floor assignment tables for security.
						2. Set security car call scan from security flag, sec_fl_ctrl[i], sent from the group.
						3. Added security activation timers for Floor security configurations 2, 3, and 4.
3/18/2010 v5.51.15 hdl	1. Added Hall lantern delay paramemter to delay lanterns to come on.
3/23/10 v5.51.16 mhd	1. Take car off code blue once car is placed on hospital service.
						2. In dirsel() set the dirf and dpref to zero if codebfl == 0.
						3. Clear the dwell timer instead when code blue car times out to allow the car to stay on code blue if the button is stuck (the EML light
						   will go out after the time-out but fix the stuck button).
						4. Added variables for Sabbath start at lobby and to use cab lanterns for direction arrows.
						5. Added code to used cab lanterns for direction arrows.
3/24/10 v5.52 mhd		1. Added fault messages for RGB Car Call Board.
						2. Made Rear Car Calls and Cab lanterns arrays.
3/25/10 v5.52.1 mhd		1. If variable set to close door on access run then make sure gate switch is up to run on access.
						2. Add variable fvclantctl to allow cab lantern to ring when door start to open or when door looses DPM.
4/6/10	mhd				3. Move clrcc() subroutine to inside if statement when on SECF security. Accidentally move outside 
						   in version 5.51.14
3/31/10 v5.52.2 mhd		1. When checking to set rhjackf = 2, check for freight door (cons[frghtd] != 0).
						2. In reset_jack() routine, check timers[trhjack] > 200 to give RCM time to pick waiting for safe() before going to reset mode.
4/1/10 v5.52.2 mhd		3. Changed (cons[dispis] == 1) to ((cons[dispis] & 0x01) != 0) to allow for additional bit usage.
						4. Added mechanism to reset hydro soft starter if P input goes off or power switches from emergency power to 
						   normal or vice versa.
						5. Don't allow the hydro car with soft starter run automatic if P input is off.
						6. Check if dpref changes in chkrun() when using advance pre torque to exit routine.
4/27/10 v5.52.4 mhd		1. Deleted commented-out test code for Hernan.
						2. Added ETS_Dist to change the UTS/DTS Distance depending on car top speed.
4/30/10 v5.52.5 mhd		1. Deleted statement "timers[tsoftstp] = 0;" in atfloor() when starting to relevel for hydro because it will cause the car not to relevel.
                           This bug was introduced in version 5.51.9.
5/3/10 5.52.7 mhd		1. Added error code for hall call low supply voltage.
						2. Added inputs FiDOB, FiDCB, FiFS2C, FiDOBR, FiDCBR, and output FiFL for rgb car call boards.
5/7/10 v5.52.8 mhd		1. Added RCM change to drop the retiring cam when doorf = 1 or rdoorf = 1 and on door zone regardless of the retiring cam timer.
						2. Added car call and cop color parameters for attendant up/down, fire, medical, emergency and OTS.
						3. Added parameter fvbklton to be able to turn off the emergency outputs completely when the rest of the button stay lit for an off state.
5/14/10 v5.52.7 hdl		1. Added logic for cons[hben] == 4 for having the car call buzzer but no passing floor handicap buzzer
6/3/2010 v5.52.8 hdl	1. Added logic to delay the hall lanterns based on the "time to stop". If we do not enough time to delay the lanterns,
							then they will trigger the old style. As soon as the car starts to slow down.
6/7/10 v5.52.9 mhd		1. Changed number of field variables from 360 to 420.								
						2. Added parameters and variables for hall call light control for up and down, ir, code blue and vip.
						3. Added parameters Vip lantern control and Group Car Call Override Control.
						4. Turn on up or down hall lanterns when Vip car reaches the vip floor. (fvars[fvviplant] == 1  Vip lantern control).
						5. Added fault_prog_flag1 and 2 in record_fault() routine.
						6. Added can sync timers for car call security and attendant.

6/21/10 v5.52.10 hdl	1. Added 3 exclusion fault field variables and control variables for each (6 fvars). You can choose not to display faults based on ctrl
						2. Changed logic for retiring cam to attempt 4 times to make up locks before declaring a fault and shutiing down
						3. Added RCM / lock fault 
6/28/10 V5.52.12 mhd	1. Added an additional 180 parmeters locations to go from 420 to 600.
						2. Corrected mistake for DON and BRKi input during motion.  Had used tstopsw timer to set to zero from STP == 1 but this prevented the check all the time.
						   Changed timer name to tdonbrkflt and debounce for 100-200 msec before setting error and estop wnen DON or BRKi failed. 
						3. Modified the detection of the levelint stop count fault in set_ul_dl() to set the fault only when moving up and ul lost or moving down and dl lost.
						4. Added check for ebrk_can_error to prevent the car from running automatic.
						5. Put emergency brake drop delay minimum back to 0.0 sec from 10.0 sec.
7/8/10 v5.52.14 mhd		1. Added Brake check for Aux_Brake == 1. see XBKS1.
7/09/10 v5.52.14 hdl	1. Added cons[FSautoRST] to allow fire service to reset automatically. It works as bypass but it only activfates once the car is done recalling
							and the fire condition is cleared 
7/26/10 v5.52.16 mhd	1. Moved VIP lantern operation to hlants() routine to allow hall lantern to activate during slowdown.
						2. Added 20 extra cons[] parameters from 111 to 130 read from cons.dat file. 
						3. Added special arrival lantern to activate on arrival even without onward call.  This is used in building where the elevator gives direct access to the
						   tenant's appartment.  The lantern and gong will activate to alert the tenant.
8/02/10 v5.52.18 hdl	1. Modified the logic on (openL) when fvars[fvopenlctl] & 0x04 so it turn the output on even if the cars is selected to run in Emergency power
8/3/10 v5.52.19 mhd		1. Added parameters for code blue second riser and code blue selection of ir car.

8/6/10 v5.52.21 hdl		1. Modified the logic for the UT and DT target faults. Fault would occur if the switch was at close to floor and CPU saw transition while in relevel.
							Added logic for excluding procf = 10
						2. Reset Max_Lant_time before calling the hall lanterns roiutine while at floor. The lanterns were being delayed when the car was already at the floor where call came in.
8/12/10 v5.52.23 mhd	1. Modified emergency recovery to cycle door instead of keeping it open.
						2. Declare a leveling_fault only if the doors are closed.
8/18/10 v5.52.25 mhd	1. Added group hall call security "group_sec_car_fl_keysw()" to secure hall calls per floor per car from
						   a key switch for each car and floor.

8/23/10 v5.52.26 hdl	1. Added HUGO. This outputs maps by default to P1 in the car station. It wwill with cons[hugs] == 1 and it will only flash when the car is taken out of service.
						2. Added INSEC output and fvars[fvinsec] for inverting the output. It outputs whether the in car security is enabled or not
						3. Added the logic for the rear for the openL output to work as well
8/26/10 v5.52.27 hdl	1. Since the hall lantern delay was introduced, the double stroke on the rear lanterns was not working properly. Logic was reversed for the timed lanterns.
							correction in hlants() when double stroke is enabled	
9/03/10 v5.52.28 mhd	1. In dirsel(), prevent independent or attendant car from running during recall only when at the floor and ansi code < 2007. Added the "when at floor part of the code".
						2. In reset(), if hydro and on ep recall and direction flag is up, then change direction flag to down.  Also in reset(), do not allow the car to go into procf 3 if dirf is not
						   set non-zero because the car cannot move without the dirf set. 	
						3. Added  fvattmandir to retain the from running until an attup/dn input is pressed. 						   				
9/8/10 v5.52.29 mhd		1. Check del at the end of ckstart() when you have (cons[EM_BRK] == 6).
						2. Added Encoder Dbn Interval parameter.
						3. Do not clear UP or DNR output if DEL not on when (cons[EM_BRK] == 6) in motion() routine.
9/24/10	v5.52.33 hdl	1.Added fvhboncct handicap buzzer on car call beep time in 1/10 sec
10/4/10 v5.52.35 mhd	1. Added timers[tvipseqto] to time-out vipf == 4 if car on vip and request is still there after doors have timed out.
10/6/10 v5.52.36 mhd	1. Added (Drive_Type[cons[carnmb]] == 15) for Yaskawa L1000 drive.
					   	2. Added service ups parameter to allow the ups to be disconnectd from the comm while it is being serviced.
10/14/10 v5.52.37 mhd	1. Clear GR1 and SFC test flags (SPB_can.command &= ~spbc_GR1_test; and SPB_can.command &= ~spbc_SFC_test;)
						   when in_pfc_sfc_test flag cleared.
10/25/10 v5.52.39 pn/hdl 1. inside setfsf --> if(firef == 8){if DCL==0 then firef = 5} added logic to allow the firef to be set to 5 in the event of
		`					the door open button being pressed and the door not being open

10/26/10 v5.52.41 mhd 1. Changed Arrays to add I/O board:
							 For example for Tract_HR: iodata from 145 to 157
							     					   IO_board from 49 to 53
               						   	 for All others: iodata from 85 to 97
							  			  			     IO_board from 29 to 33
						2. Added io boards to move hall fire and emergency power inputs off 1064board for 24V inputs.
						3. Used the define command to name array inputs and outputs with one name instead of two. See iomap.h, 
							i.e. rdinp(i_DCL) instead of rdinp(i_DCL) to make the code easier to read.
						4. Changed epr_set_power() to turn on EPO (turn off UPS power) after 2 minutes regardless of the position of the doors.

11/1/10 v5.52.42 hdl	1. Added the Extinguish_FSL global variable to control different operation where the fire light should extiniguiosh due to the low oil switch. 
							there is a state machine at the beginning of the setsf()

11/6/10 v5.52.44 hdl	1. Added bit (fvars[fvattmandir] & 0x04) to allow the car only to start motion after the doors are closed and the car has a registered car call.
							checkrun() and setpref routines were modified. It only affects manual door cars with attendant feature
11/11/10 V5.52.46 mhd	1. Added security variables to activate modified express service security for hall calls on individual cars.	 See Hall Call secure direction.
11/19/10 V5.52.47 mhd	1. Added UPS baud rate parameter also added (cons[UPS_Type] == 2) for Eaton UPS with SHUT protocol.

11/23/10 v5.52.48	hdl	1. Added fvhcattbuz to allow car to aknowledge hall calls bu buzzing for 1 second every new call comes in. To be used in attendant cars
						2. added rcm_pick_attempt = 0 if the car is not atfloor. Cars with completely manual doors will only run succesfullly for 5 times before
							shutdown with an RCM_Lock_Fault
11/28/10 v5.52.49 mhd	1. Deleted all parameters to activate modified express service except for Hall Call assignment secure type.

12/10/10 v5.52.52 hdl	1. Corrected the RTL recall sequence to set a rear car call if no front opening is available.
						2. Added the microreleveling signals UPML and DNML tot he clrall() routine so they clear when the car goes in inspection


12/20/10 v5.52.53 hdl	1.Added variable for Second code blue car selection: if fvars[fvcbcar2] == 0 -> auto dispatch; if fvars[fvcbcar2] == fvars[fvcbcar] do nothing
							for any other values, force trhe next car 
						2. Added Filed variable for  Elevator Off Options 2. The only one bit being used is DC to keep doors closed. This is used to force the doors to stay closed
							when the car is recalled with HEOF and latched the car in this mode. Securty reason to trap the person inside the car until the EOR is activated

1/7/11 v5.52.54 hdl		1. Added timer to flash Alarm status on PI.
1/10/11 v5.52.55 mhd	1. In dirsel() for hydro, allow phase 2 car to run up or down if EMPop & 0x02 != 0.
						2. In setempf() for hydro, add logic for time-out and out of service and at home floor to cycle door closed i.e. set ep_home in empf.
1/11/10 v5.52.56 mhd	1. Put all encoder software into subroutines and placed in encoder.cc.
						2. Replaced setting the encoder directly with preset_encoder_count() routine.
					 	3. Added cons[sel_type] = 3 for tapeless selector with absolute CAN encoder on governor going into the CPU encoder board.
1/18/11					4. Modified emergency power for hydro to have seperate door cycle for car at home floor from cycling door in other conditions.
							see epc_wait_close.

1/14/11	 v5.52.57 hdl	1. Modified the logic for off_fsl_state and Extinguish_FSL. Now if the car is in a fire service recall, low oil triggers and recalls tot he bottom floor,
							we will extiniguish the light because you can run the car any longer. 
						2. Modified timer from (timers[tsafe] > 0) to if (timers[tsafe] > 1) in order to declare a safe fault - TRACTION.

1/26/11 v5.52.58 pn		1. Changed the maximum value for fvshortdis from 60 inches to 72 inches 
1/28/11	v5.52.58 hdl	2. Modified timer from (timers[tsafe] > 0) to if (timers[tsafe] > 1) in order to declare a safe fault - HYDRO.
2/2/11/ v5.52.58 hdl	3. Modified the logic for cons[Prison] It uses a jail_break routine to work parallel to the elevator off routine. They can't cohexist.

2/10/11	v5.53.1 hdl		1. Added fvcbbuz to enable buzzer to go off when in code blue return

2/18/11 v5.53.2 hdl		1. Added  fvcbovrind in the setcodebf() routine. This allows the cars to be taken out of independent service  after Fire phase1 door time-out times out
				pn		2. Coorrected location for HWS2. It was mapped in the wrong IO
2/23/11 v5.53.3 hdl     1. Added cons[Super_Sabbath] to allow the outputs sabuz and sabee to come on. Otherwise they will not work
2/24/11 v5.53.4 mhd		1. Added power loss brake cycle timers to pulse the brake contacts to prevent the car from running away.

3/11/11 v5.53.07 hdl	1. Added the change for the security tables to switch hall calls in addition to the car calls. Previously only the car call arrays were only being switched.


3/15/11 v5.53.08 hdl	1. added writedbgtoFC() that only runs when the debug_io_enable compile flag is enabled

3/24/11 v5.53.10 hdl/mhl	1. Corrected the logic for preset encoder count to be done only in the instances where the (cons[sel_typ] != 3). Before the DPP count was getting reset to 
								an incorrect number and this will cause the encoder preset fault.
							2. Added filed variables fvattempcar  fvopencandir fvemprecall


4/11/11 v5.53.11 hdl	1. Added output OSER. It shows up automatically as long as no lobby lantersn and no earthquake is selected
						   Added timers: tosernocall toserbtwfl	toserssopen
						   Added field variable	fvoser1 to control logic.
						   When the field variable is zero, it will just work as an out of service light. Otherwise it turns on depending on the options. The timers were
						   hard coded for btw floors and safety string to be one mionute and not answering calls for ten minutes									
										 

4/14/11	v5.53.12 hdl	1. Added cons[hugs] = 2 for jobs that required hugs security in addition to hall call security. It utilizes the group car call security boards
						2. in hugs_sec[] was not being set in sethugsf for the second byte of data. It was setting the ha_sec instead. (bug)
						3. insec output will only operate if the security is not set for car call latch outputs in the car call security boards


4/26/11 v5.53.16 mhd	1. Clear the slowdown flags when not in slowdown so that a momenatry hall call causes the door to open.  Do not clear them
						   at the start of needstop().
						2. Use level_stop_fault variable to prevent calling preset_encoder_count() if floor count was off.
						3. Reset level_stop_fault one time if releveling the car before stopping the relevel. 
						4. Do not update the DPP_Count after 2 second delay if stopping from the pulse count.

4/29/11 v5.53.16 hdl	1. Chaged the names on some of the vcariables used for debug_io_enable to amke it easier when searching for debug 1. debug2 and so on.

5/10/11 v5.53.19 wc     1.  Replace	 open_can_save_timer  	with  EncCanOpen_SavingInProgress flag. This flag is set and clear 
							depending on the third  Bit of the Status  Register (0x214).
						2. Allowed both open_can_save_timer and  EncCanOpen_SavingInProgress to coexist depending on the encoder board version

5/20/11 v5.53.20 WC     1. Added Packet	 37 in pack_grp_com() and unpack_grp_com() to allow Car1  to send Galileo information to the rest of the group Cars
						2. Modify Packet 77 in Comm_diag()  to put packet 37 into put_pkt_req().
						3. Added ui_cc_sec_PREV[][]  to retain previous value of ui_cc_sec[][].
5/24/11	v5.53.21 hdl	1. Added the setting for the OSER output to be done from an external board (cons[distress] = 1 ). There will be a buzzer and and acknowledge signals
							there will be timers and two control variables to determine the logic of operation of the oser outputcons[distress] = 1 


5/25/11 v5.53.22 hdl	1. Added field variable fvfhws2loc to give the customer the option of flashing or having a steady FL output for HWS2 

5/25/11 v5.53.22 hdl	1. Added a timer tlocalgetdate to delay the check for date in check run to be done only once every ten seconds instead of every loop

5/26/11	v5.54.00 hdl	1. Added fvrcdrdly for RCM to drop sooner when you have manual doors. Otherwise it would look for doorf = 1 which does not occur on cons[mand] = 1

5/20/11 v5.54.02 mhd	1. Added parameters for direction check and ee memory location.
						2. Added limit direction check and ul/dl direction check.



6/1/11 v5.54.03 mhd		1. Added cons[Australia] variable to use external i/o board for hall fire and emergency power i/o. 
						2. TDC, BDC, MDC and MDCR inputs added for automatic doors.
6/2/11 v5.54.04 mhd		1. Modified ansi 2000 fire service for use in Australia. 
							a. Fire Car Key switch has off, on and start (hold input used for start)
							b. Close door on phase 2 by holding spring loaded start switch.
							c. Run from floor with start pressed and call.
							d. Re-open door if start released before door fully closed
							e. No hall fire sensors.
						2. Set cons.dat variables for Australia = 1, ansi = 2007,  Fire Service = 2 (ansi 2000), Note: FI_EP_Ext does not need to be set
						   even though the external board is used.  Also note added FS2S (fs2_start) input.
6/15/11 V5.54.05 HDL	1. Modified the locations for OSERL, OSERB and OSERA to be in the external fire service board instead of the brake io
						2. Added the changes for cons[TUG]. It enables an interface for Aethon Robots for medical supplies transport

6/28/11	v5.54.08	hdl	1. Added a bit on fvars[fvaltrclfs] & 0x02) != 0 to allow tyhe car to return to ALT landing for massachussets if the smoke sensor is rest
							car will still return to alt landing after fs is turned off
6/29/11 V5.54.09 hdl	1. Moved GOVR output to EMLH for hydros.
7/5/11 v5.54.10 mhd		1. Allow fire phase 2 hold when manual door not open. 

7/8/11 v65.54.11 mhd	1. TAVL output for TUG security had array number 95 instead of 94.
						2. MED output was set from medf instead of codebf and hsvf ALSO for TUG service.
7/8/11 v5.54.12 mhd		1. Deleted checking cons[GOV_Reset} == 0 when Drive_Type[] == 9(hydro soft starter) so that the governor reset can be used with roped hydros.
 						   The GOVR output for hydros is moved to EMLH.

7/8/11 v5.54.12 mhd		1. Modified Mass Medical to override the stop switch when car moving.
7/11/11 v5.54.12 mhd	2. Changed logic for TAVL to be on when on ins or safties.
						3. Allow OSERL OutCtrl 2 to be changed to zero. Set to 1 gives control to OSERL Outctl 1.
						4. When ind service activated, go off of tugs service.
7/12/11 v5.54.13 mhd	1. Corrected FST test for f_FST_failed_on if on MED.
7/12/11 v5.54.14 mhd	1. Added mechanism to not override ind when on MED or to override after time delay, both from parameters.
						2. Allow fire service to override MED if at the fire floor and NOT (medf == 3) (med tech using the car).
						3. Fixed bug that car stops at every floor when on fire 1 and MED.  (Where stop switch was overriden (FST))
7/25/11 v5.54.18 hdl	1. Modified retiring cam operation when using both front and rear manual doors.
7/27/11	v5.54.19 mdh	1. Reset encoder base count if flag set from count being too high (can bus encoder).  Also use leveling variable to 
						   allow presetting encoder count.
8/11/11 v5.54.20 hdl	1. Changed the defaults for Out of Service Light control to be zero so the light comes off just as a "out of service" only

8/12/11 v5.54.22 hdl	1. Modified pisout() to not output anything if hugs is enabled since P1 is being used. Also there was a typo in the doeblue check in the same line that was corrected


8/15/11	5.54.22 hdl		1. Added fvars fvhsaftercb and fvextdoormsg, fvhsaftercb makes the ems input work under code blue only after the code blue recall is complete
							fvextdoormsg makes the PI driver board show User message 2 (DH) int he PIs when in extended door time
9/8/11	5.54.24 hdl		1. Removed fvreopendoorfs2 fvar number 445 and save it as a spare

9/13/11 v5.54.24 hdl 	1. Changed the fvnohcreopen to nohcreopen to allow up peak to changed this logic

9/22/11 v5.54.25 mhd	1. Added second call to group_em_power(feeder) to control cars on two seperate power feeders.
						2. Moved timers[tepsw] and timers[teprcldly] to bottom of timer list to allow for two consecutive timers of each.
						3. Replace grp_empf[0] with gempf.  gempf is set from grp_empf[pwr_feed][car] depending on the power feeder used for this car

9/19/11 5.52.25 hdl		1. Only register a RLM RLM-1 opposite or RGS & RGS-1 Opposite if controller has rear openings 
						2. Chenge motion checks when leaving the floor for cars that are less than 50 fpm

9/29/11	5.52.26	hdl		1. separated the retring cam logic in a function set_rcm()
							Added logic for cons[mand] == 9, where it would only drop the output to unlock a landing with
							special cam so the door is unlocked and access could be given to the elevator
						2. Added cons[hugs] == 3 to have hugs security based on car. It enables outputs HUGA HUGO (alarm and ouput)
							and inputs HUGI and HUGB (input and bypass)

10/5/2011 v5.52.29 hdl	1.	Added an expcetion to run the verify_uldl_seq if you have a very short floor. Sequence could be affected when
							passing by the magnets between the very short floor and the floor right below it.
						2. When doing a run at a very short floor run, do not check for UL_ON_Fault or DL_ON_Fault since they may overlap between the floors

10/7/2011 v5.54.30 hdl	1. in ind() add a check for car in hugs security to prevent the car to be placed in independednt service if hugs sensor is tripped

10/12/2011 v5.54.31	hdl 1. change the max fvrcpkdly value to 7 secs
						2. added fvrcmfrght to enable output for  Retiring Cam for freight RCF under car options (reboot required)
						3. Added Changes for very short floor runs
								a. in relevel, add reset_nonit when switching positions
								b. in run, add ignore_uldl_fault to allow the UL and DL on faults to be ignored while doing a very short floor run
10/13/11 v5.54.32 mhd	1. Read Encoder once every five iterations during a start sequence (roughly 1-2 msec).

10/14/11 v5.54.33 mhd	1. change logic to reset_enc_base_count to be done at any floor instead of just top and bottom

11/25/11 v5.54.37 hdl	1. in second riser, we need to reset the security Sec_Fl_Mask to zero when ccmsk[i] = &ccnmsk[i][0]when switching the second riser masking tables
12/8/11 v5.54.42 mhd	1. Added velocity difference check between SPB velocity and Encoder velocity.
12/12/11 v5.54.43 hdl	1. Added a new location for EOR. Since rthe HEOF input is relocated to the expansion io board for fire service, we located the input in the same board
12/12/11 v5.54.44 WC    1. Added packet 91 in comm_diag() to send Galileo Alarm Array
01/03/2012 v5.54.46 pn	1. Changed Exclusion fault feature from 3 to 6 and eliminated the exclusion fault control option for each exlusion fault.								

01/06/2012 v5.54.47 WC  1. Added packet 92 in comm_diag() to send Galileo  all current faults  for every car in the group								

1/9/12 v5.54.48	hdl		1. Added a new bit to the open light control (OpenL) to allow it to come on only at the lobby as well

1/11/12 v5.54.49 hdl	1. Added ee_io_sel and cons[dflt_MOVFR] to remap the EE back to the car top input even if a can movfr is being used.

1/30/12 v6.0 mhd		1. Added velocity difference check between SPB velocity and Encoder velocity.
						2. Modified unintended motion for check with SPB or ENcoder velocity to give the car 700 msec to start to slow down otherwise clear the intended_motion flag to
						   allow a trip.
						3. Added seperate flag for encoder velocity unintended motion in fvspbgrip variable.
						4. Deleted parameter fvdisglt that allows the gate and lock check for NY to be disabled.
2/1/12 v5.54.53 mhd		1. Added parameters fvdobovrdcb	and fvdenfsv to allow DOB to override DCB on phase 2 (for Miami) and special recall operation for Denver to close the doors after
						   the car recalls on phase 1.  Doors are reopened from the hall call button at the recall floor.
						2. Added parameter fvf1dwell for denver phase 1 dwell time
2/28/12 v6.0.0 mhd		1. Set st_enc_vel and st_spb_vel to zero when intended motion flag is set to zero.
						2. Changed unintended motion check to use UP or DNR to detect run instead of RUN.
		 				3. Use Drv_Velocity instead of Dmd_Velocity to check for velocity difference to set the gripper.
						4. Modified timing for velocity overspeed check see ovs_dbn_tim.
3/8/12 v6.0.1 mhd		1. Added Slip velocity difference disable.  Also changed SPB velocity difference fault to Slip velocity difference fault.
2/24/12 v5.54.58 mhd	1. Added changes to emergency power to cycle the door closed at the homing floor if the car is on fire service and the variable is set for denver fire service.
3/1/12 v5.54.60 mhd		1. Set st_enc_vel and st_spb_vel to zero when intended motion flag is set to zero. Also added em_stop_time back in.
						2. Changed unintended motion check to use UP or DNR to detect run instead of RUN.
		 				3. Use Drv_Velocity instead of Dmd_Velocity to check for velocity difference to set the gripper.
						4. Modified timing for velocity overspeed check see ovs_dbn_tim.
						5. Corrected gservf from being set to 2 from i_EPT on car. See emp_bits in comm.cc.

3/3/12 V5.54.61 hdl 	1. Blocked the SABO from alternating for regular sabbath
						2. Added (cons[Elev_off] & 0x10) to enable the ELOO to show just for telling the car finished recall of elevator off mode

3/8/12 v5.54.62 mhd		1. Added Slip velocity difference disable.  Also changed SPB velocity difference fault to Slip velocity difference fault.

3/14/12 v5.54.63 hdl	1. change the default Encoder Debounce Interval field variable (fvencinterval) to 3

3/14/12 v5.54.64 hdl	1. Change for cons[Elev_off] & 0x10) to allow car calls to stay in and to clear ELOO once it is in auto
3/14/12 v5.54.65 hdl	1. Clear fire_stopsw_hold once the car goes in firef == 1 or firef ==2 because the rule for stop switch does not longer apply
3/29/12 v5.54.71 mhd	1. Added cons[MR_INE] for motor room inspection enable.
4/18/12 v6.0.06 mhd		1. When cons[EM_BKS] is set the brake switch input is monitored for cons[EM_BRK] 1, 4 or 5 and can be taken out of the DEL circuit.
						2. Added delta off fault if car trying to relevel and del does not pick.
						3. Increased time for intended_motion being cleared from 600 msec to 1 second when looking at decrease in velocity.
5/1/12 v6.0.7 mhd		1. Added new brake control cons[EM_BRK] == 7.  This is to have a controled drop of the emergency brake even after MC drops.
						2. In chk_start() for traction, use MST only if generator and governor reset is not used.
						3. If you loose del during a run do an emergency slowdown and set the fault run count.
						4. Added rset_error_cnt to prevent setting multiple reset faults.  Also moved setting reset faults after check for inspection.
6/4/12 v6.09 mhd		1. For traction cars, do not turn off UP or DNR if DEL lost.  The drive will turn off and drop the brake which will prevent DEL from picking.

*/

